// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: wallet.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import {
  GetIdentityRequest,
  GetIdentityResponse,
  ListConnectedPeersResponse,
  NetworkStatusResponse,
  SoftwareUpdate,
} from "./network.js";
import { TemplateRegistration } from "./sidechain_types.js";
import { UnblindedOutput } from "./transaction.js";
import { CommitmentSignature, Empty, Signature } from "./types.js";

export const protobufPackage = "tari.rpc";

/**
 * Copyright 2020. The Tari Project
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 * disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

export enum TransactionDirection {
  TRANSACTION_DIRECTION_UNKNOWN = 0,
  TRANSACTION_DIRECTION_INBOUND = 1,
  TRANSACTION_DIRECTION_OUTBOUND = 2,
  UNRECOGNIZED = -1,
}

export function transactionDirectionFromJSON(object: any): TransactionDirection {
  switch (object) {
    case 0:
    case "TRANSACTION_DIRECTION_UNKNOWN":
      return TransactionDirection.TRANSACTION_DIRECTION_UNKNOWN;
    case 1:
    case "TRANSACTION_DIRECTION_INBOUND":
      return TransactionDirection.TRANSACTION_DIRECTION_INBOUND;
    case 2:
    case "TRANSACTION_DIRECTION_OUTBOUND":
      return TransactionDirection.TRANSACTION_DIRECTION_OUTBOUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionDirection.UNRECOGNIZED;
  }
}

export function transactionDirectionToJSON(object: TransactionDirection): string {
  switch (object) {
    case TransactionDirection.TRANSACTION_DIRECTION_UNKNOWN:
      return "TRANSACTION_DIRECTION_UNKNOWN";
    case TransactionDirection.TRANSACTION_DIRECTION_INBOUND:
      return "TRANSACTION_DIRECTION_INBOUND";
    case TransactionDirection.TRANSACTION_DIRECTION_OUTBOUND:
      return "TRANSACTION_DIRECTION_OUTBOUND";
    case TransactionDirection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransactionStatus {
  /** TRANSACTION_STATUS_COMPLETED - This transaction has been completed between the parties but has not been broadcast to the base layer network. */
  TRANSACTION_STATUS_COMPLETED = 0,
  /** TRANSACTION_STATUS_BROADCAST - This transaction has been broadcast to the base layer network and is currently in one or more base node mempools. */
  TRANSACTION_STATUS_BROADCAST = 1,
  /** TRANSACTION_STATUS_MINED_UNCONFIRMED - This transaction has been mined and included in a block. */
  TRANSACTION_STATUS_MINED_UNCONFIRMED = 2,
  /** TRANSACTION_STATUS_IMPORTED - This transaction was generated as part of importing a spendable UTXO */
  TRANSACTION_STATUS_IMPORTED = 3,
  /** TRANSACTION_STATUS_PENDING - This transaction is still being negotiated by the parties */
  TRANSACTION_STATUS_PENDING = 4,
  /** TRANSACTION_STATUS_COINBASE - This is a created Coinbase Transaction */
  TRANSACTION_STATUS_COINBASE = 5,
  /** TRANSACTION_STATUS_MINED_CONFIRMED - This transaction is mined and confirmed at the current base node's height */
  TRANSACTION_STATUS_MINED_CONFIRMED = 6,
  /** TRANSACTION_STATUS_REJECTED - The transaction was rejected by the mempool */
  TRANSACTION_STATUS_REJECTED = 7,
  /** TRANSACTION_STATUS_ONE_SIDED_UNCONFIRMED - This is faux transaction mainly for one-sided transaction outputs or wallet recovery outputs have been found */
  TRANSACTION_STATUS_ONE_SIDED_UNCONFIRMED = 8,
  /** TRANSACTION_STATUS_ONE_SIDED_CONFIRMED - All Imported and FauxUnconfirmed transactions will end up with this status when the outputs have been confirmed */
  TRANSACTION_STATUS_ONE_SIDED_CONFIRMED = 9,
  /** TRANSACTION_STATUS_QUEUED - This transaction is still being queued for sending */
  TRANSACTION_STATUS_QUEUED = 10,
  /** TRANSACTION_STATUS_NOT_FOUND - The transaction was not found by the wallet its in transaction database */
  TRANSACTION_STATUS_NOT_FOUND = 11,
  /** TRANSACTION_STATUS_COINBASE_UNCONFIRMED - This is Coinbase transaction that is detected from chain */
  TRANSACTION_STATUS_COINBASE_UNCONFIRMED = 12,
  /** TRANSACTION_STATUS_COINBASE_CONFIRMED - This is Coinbase transaction that is detected from chain */
  TRANSACTION_STATUS_COINBASE_CONFIRMED = 13,
  /** TRANSACTION_STATUS_COINBASE_NOT_IN_BLOCK_CHAIN - This is Coinbase transaction that is not currently detected as mined */
  TRANSACTION_STATUS_COINBASE_NOT_IN_BLOCK_CHAIN = 14,
  UNRECOGNIZED = -1,
}

export function transactionStatusFromJSON(object: any): TransactionStatus {
  switch (object) {
    case 0:
    case "TRANSACTION_STATUS_COMPLETED":
      return TransactionStatus.TRANSACTION_STATUS_COMPLETED;
    case 1:
    case "TRANSACTION_STATUS_BROADCAST":
      return TransactionStatus.TRANSACTION_STATUS_BROADCAST;
    case 2:
    case "TRANSACTION_STATUS_MINED_UNCONFIRMED":
      return TransactionStatus.TRANSACTION_STATUS_MINED_UNCONFIRMED;
    case 3:
    case "TRANSACTION_STATUS_IMPORTED":
      return TransactionStatus.TRANSACTION_STATUS_IMPORTED;
    case 4:
    case "TRANSACTION_STATUS_PENDING":
      return TransactionStatus.TRANSACTION_STATUS_PENDING;
    case 5:
    case "TRANSACTION_STATUS_COINBASE":
      return TransactionStatus.TRANSACTION_STATUS_COINBASE;
    case 6:
    case "TRANSACTION_STATUS_MINED_CONFIRMED":
      return TransactionStatus.TRANSACTION_STATUS_MINED_CONFIRMED;
    case 7:
    case "TRANSACTION_STATUS_REJECTED":
      return TransactionStatus.TRANSACTION_STATUS_REJECTED;
    case 8:
    case "TRANSACTION_STATUS_ONE_SIDED_UNCONFIRMED":
      return TransactionStatus.TRANSACTION_STATUS_ONE_SIDED_UNCONFIRMED;
    case 9:
    case "TRANSACTION_STATUS_ONE_SIDED_CONFIRMED":
      return TransactionStatus.TRANSACTION_STATUS_ONE_SIDED_CONFIRMED;
    case 10:
    case "TRANSACTION_STATUS_QUEUED":
      return TransactionStatus.TRANSACTION_STATUS_QUEUED;
    case 11:
    case "TRANSACTION_STATUS_NOT_FOUND":
      return TransactionStatus.TRANSACTION_STATUS_NOT_FOUND;
    case 12:
    case "TRANSACTION_STATUS_COINBASE_UNCONFIRMED":
      return TransactionStatus.TRANSACTION_STATUS_COINBASE_UNCONFIRMED;
    case 13:
    case "TRANSACTION_STATUS_COINBASE_CONFIRMED":
      return TransactionStatus.TRANSACTION_STATUS_COINBASE_CONFIRMED;
    case 14:
    case "TRANSACTION_STATUS_COINBASE_NOT_IN_BLOCK_CHAIN":
      return TransactionStatus.TRANSACTION_STATUS_COINBASE_NOT_IN_BLOCK_CHAIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionStatus.UNRECOGNIZED;
  }
}

export function transactionStatusToJSON(object: TransactionStatus): string {
  switch (object) {
    case TransactionStatus.TRANSACTION_STATUS_COMPLETED:
      return "TRANSACTION_STATUS_COMPLETED";
    case TransactionStatus.TRANSACTION_STATUS_BROADCAST:
      return "TRANSACTION_STATUS_BROADCAST";
    case TransactionStatus.TRANSACTION_STATUS_MINED_UNCONFIRMED:
      return "TRANSACTION_STATUS_MINED_UNCONFIRMED";
    case TransactionStatus.TRANSACTION_STATUS_IMPORTED:
      return "TRANSACTION_STATUS_IMPORTED";
    case TransactionStatus.TRANSACTION_STATUS_PENDING:
      return "TRANSACTION_STATUS_PENDING";
    case TransactionStatus.TRANSACTION_STATUS_COINBASE:
      return "TRANSACTION_STATUS_COINBASE";
    case TransactionStatus.TRANSACTION_STATUS_MINED_CONFIRMED:
      return "TRANSACTION_STATUS_MINED_CONFIRMED";
    case TransactionStatus.TRANSACTION_STATUS_REJECTED:
      return "TRANSACTION_STATUS_REJECTED";
    case TransactionStatus.TRANSACTION_STATUS_ONE_SIDED_UNCONFIRMED:
      return "TRANSACTION_STATUS_ONE_SIDED_UNCONFIRMED";
    case TransactionStatus.TRANSACTION_STATUS_ONE_SIDED_CONFIRMED:
      return "TRANSACTION_STATUS_ONE_SIDED_CONFIRMED";
    case TransactionStatus.TRANSACTION_STATUS_QUEUED:
      return "TRANSACTION_STATUS_QUEUED";
    case TransactionStatus.TRANSACTION_STATUS_NOT_FOUND:
      return "TRANSACTION_STATUS_NOT_FOUND";
    case TransactionStatus.TRANSACTION_STATUS_COINBASE_UNCONFIRMED:
      return "TRANSACTION_STATUS_COINBASE_UNCONFIRMED";
    case TransactionStatus.TRANSACTION_STATUS_COINBASE_CONFIRMED:
      return "TRANSACTION_STATUS_COINBASE_CONFIRMED";
    case TransactionStatus.TRANSACTION_STATUS_COINBASE_NOT_IN_BLOCK_CHAIN:
      return "TRANSACTION_STATUS_COINBASE_NOT_IN_BLOCK_CHAIN";
    case TransactionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GetVersionRequest {
}

export interface GetVersionResponse {
  version: string;
}

export interface GetAddressResponse {
  interactiveAddress: Uint8Array;
  oneSidedAddress: Uint8Array;
}

export interface GetCompleteAddressResponse {
  /** Binary format addresses */
  interactiveAddress: Uint8Array;
  oneSidedAddress: Uint8Array;
  /** Base58 encoded addresses */
  interactiveAddressBase58: string;
  oneSidedAddressBase58: string;
  /** Emoji encoded addresses */
  interactiveAddressEmoji: string;
  oneSidedAddressEmoji: string;
}

export interface TransferRequest {
  recipients: PaymentRecipient[];
}

export interface SendShaAtomicSwapRequest {
  recipient: PaymentRecipient | undefined;
}

export interface CreateBurnTransactionRequest {
  amount: Long;
  feePerGram: Long;
  claimPublicKey: Uint8Array;
  paymentId: Uint8Array;
}

export interface PaymentRecipient {
  address: string;
  amount: Long;
  feePerGram: Long;
  paymentType: PaymentRecipient_PaymentType;
  paymentId: Uint8Array;
}

export enum PaymentRecipient_PaymentType {
  STANDARD_MIMBLEWIMBLE = 0,
  ONE_SIDED = 1,
  ONE_SIDED_TO_STEALTH_ADDRESS = 2,
  UNRECOGNIZED = -1,
}

export function paymentRecipient_PaymentTypeFromJSON(object: any): PaymentRecipient_PaymentType {
  switch (object) {
    case 0:
    case "STANDARD_MIMBLEWIMBLE":
      return PaymentRecipient_PaymentType.STANDARD_MIMBLEWIMBLE;
    case 1:
    case "ONE_SIDED":
      return PaymentRecipient_PaymentType.ONE_SIDED;
    case 2:
    case "ONE_SIDED_TO_STEALTH_ADDRESS":
      return PaymentRecipient_PaymentType.ONE_SIDED_TO_STEALTH_ADDRESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentRecipient_PaymentType.UNRECOGNIZED;
  }
}

export function paymentRecipient_PaymentTypeToJSON(object: PaymentRecipient_PaymentType): string {
  switch (object) {
    case PaymentRecipient_PaymentType.STANDARD_MIMBLEWIMBLE:
      return "STANDARD_MIMBLEWIMBLE";
    case PaymentRecipient_PaymentType.ONE_SIDED:
      return "ONE_SIDED";
    case PaymentRecipient_PaymentType.ONE_SIDED_TO_STEALTH_ADDRESS:
      return "ONE_SIDED_TO_STEALTH_ADDRESS";
    case PaymentRecipient_PaymentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TransferResponse {
  results: TransferResult[];
}

export interface SendShaAtomicSwapResponse {
  transactionId: Long;
  preImage: string;
  outputHash: string;
  isSuccess: boolean;
  failureMessage: string;
}

export interface CreateBurnTransactionResponse {
  transactionId: Long;
  isSuccess: boolean;
  failureMessage: string;
  commitment: Uint8Array;
  ownershipProof: CommitmentSignature | undefined;
  rangeProof: Uint8Array;
  reciprocalClaimPublicKey: Uint8Array;
}

export interface TransferResult {
  address: string;
  transactionId: Long;
  isSuccess: boolean;
  failureMessage: string;
}

export interface ClaimShaAtomicSwapRequest {
  output: string;
  preImage: string;
  feePerGram: Long;
}

export interface ClaimShaAtomicSwapResponse {
  results: TransferResult | undefined;
}

export interface ClaimHtlcRefundRequest {
  outputHash: string;
  feePerGram: Long;
}

export interface ClaimHtlcRefundResponse {
  results: TransferResult | undefined;
}

export interface GetTransactionInfoRequest {
  transactionIds: Long[];
}

export interface GetTransactionInfoResponse {
  transactions: TransactionInfo[];
}

export interface TransactionInfo {
  txId: Long;
  sourceAddress: Uint8Array;
  destAddress: Uint8Array;
  status: TransactionStatus;
  direction: TransactionDirection;
  amount: Long;
  fee: Long;
  isCancelled: boolean;
  excessSig: Uint8Array;
  timestamp: Long;
  paymentId: Uint8Array;
  minedInBlockHeight: Long;
}

export interface GetCompletedTransactionsRequest {
}

export interface GetCompletedTransactionsResponse {
  transaction: TransactionInfo | undefined;
}

export interface GetBalanceRequest {
}

export interface GetStateRequest {
}

export interface GetBalanceResponse {
  availableBalance: Long;
  pendingIncomingBalance: Long;
  pendingOutgoingBalance: Long;
  timelockedBalance: Long;
}

export interface GetStateResponse {
  scannedHeight: Long;
  balance: GetBalanceResponse | undefined;
  network: NetworkStatusResponse | undefined;
}

export interface GetUnspentAmountsResponse {
  amount: Long[];
}

export interface CoinSplitRequest {
  amountPerSplit: Long;
  splitCount: Long;
  feePerGram: Long;
  lockHeight: Long;
  paymentId: Uint8Array;
}

export interface CoinSplitResponse {
  txId: Long;
}

export interface ImportUtxosRequest {
  outputs: UnblindedOutput[];
  paymentId: Uint8Array;
}

export interface ImportUtxosResponse {
  txIds: Long[];
}

export interface CreateTemplateRegistrationRequest {
  templateRegistration: TemplateRegistration | undefined;
  feePerGram: Long;
}

export interface CreateTemplateRegistrationResponse {
  txId: Long;
  templateAddress: Uint8Array;
}

export interface CancelTransactionRequest {
  txId: Long;
}

export interface CancelTransactionResponse {
  isSuccess: boolean;
  failureMessage: string;
}

export interface RevalidateRequest {
}

export interface RevalidateResponse {
}

export interface ValidateRequest {
}

export interface ValidateResponse {
}

export interface SetBaseNodeRequest {
  publicKeyHex: string;
  netAddress: string;
}

export interface SetBaseNodeResponse {
}

export interface GetConnectivityRequest {
}

export interface CheckConnectivityResponse {
  status: CheckConnectivityResponse_OnlineStatus;
}

export enum CheckConnectivityResponse_OnlineStatus {
  Connecting = 0,
  Online = 1,
  Offline = 2,
  UNRECOGNIZED = -1,
}

export function checkConnectivityResponse_OnlineStatusFromJSON(object: any): CheckConnectivityResponse_OnlineStatus {
  switch (object) {
    case 0:
    case "Connecting":
      return CheckConnectivityResponse_OnlineStatus.Connecting;
    case 1:
    case "Online":
      return CheckConnectivityResponse_OnlineStatus.Online;
    case 2:
    case "Offline":
      return CheckConnectivityResponse_OnlineStatus.Offline;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CheckConnectivityResponse_OnlineStatus.UNRECOGNIZED;
  }
}

export function checkConnectivityResponse_OnlineStatusToJSON(object: CheckConnectivityResponse_OnlineStatus): string {
  switch (object) {
    case CheckConnectivityResponse_OnlineStatus.Connecting:
      return "Connecting";
    case CheckConnectivityResponse_OnlineStatus.Online:
      return "Online";
    case CheckConnectivityResponse_OnlineStatus.Offline:
      return "Offline";
    case CheckConnectivityResponse_OnlineStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TransactionEventRequest {
}

export interface TransactionEvent {
  event: string;
  txId: string;
  sourceAddress: Uint8Array;
  destAddress: Uint8Array;
  status: string;
  direction: string;
  amount: Long;
  paymentId: Uint8Array;
}

export interface TransactionEventResponse {
  transaction: TransactionEvent | undefined;
}

export interface RegisterValidatorNodeRequest {
  validatorNodePublicKey: Uint8Array;
  validatorNodeSignature: Signature | undefined;
  feePerGram: Long;
  paymentId: Uint8Array;
}

export interface RegisterValidatorNodeResponse {
  transactionId: Long;
  isSuccess: boolean;
  failureMessage: string;
}

function createBaseGetVersionRequest(): GetVersionRequest {
  return {};
}

export const GetVersionRequest: MessageFns<GetVersionRequest> = {
  encode(_: GetVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetVersionRequest {
    return {};
  },

  toJSON(_: GetVersionRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVersionRequest>, I>>(base?: I): GetVersionRequest {
    return GetVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVersionRequest>, I>>(_: I): GetVersionRequest {
    const message = createBaseGetVersionRequest();
    return message;
  },
};

function createBaseGetVersionResponse(): GetVersionResponse {
  return { version: "" };
}

export const GetVersionResponse: MessageFns<GetVersionResponse> = {
  encode(message: GetVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVersionResponse {
    return { version: isSet(object.version) ? globalThis.String(object.version) : "" };
  },

  toJSON(message: GetVersionResponse): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVersionResponse>, I>>(base?: I): GetVersionResponse {
    return GetVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVersionResponse>, I>>(object: I): GetVersionResponse {
    const message = createBaseGetVersionResponse();
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseGetAddressResponse(): GetAddressResponse {
  return { interactiveAddress: new Uint8Array(0), oneSidedAddress: new Uint8Array(0) };
}

export const GetAddressResponse: MessageFns<GetAddressResponse> = {
  encode(message: GetAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.interactiveAddress.length !== 0) {
      writer.uint32(10).bytes(message.interactiveAddress);
    }
    if (message.oneSidedAddress.length !== 0) {
      writer.uint32(18).bytes(message.oneSidedAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.interactiveAddress = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oneSidedAddress = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressResponse {
    return {
      interactiveAddress: isSet(object.interactiveAddress)
        ? bytesFromBase64(object.interactiveAddress)
        : new Uint8Array(0),
      oneSidedAddress: isSet(object.oneSidedAddress) ? bytesFromBase64(object.oneSidedAddress) : new Uint8Array(0),
    };
  },

  toJSON(message: GetAddressResponse): unknown {
    const obj: any = {};
    if (message.interactiveAddress.length !== 0) {
      obj.interactiveAddress = base64FromBytes(message.interactiveAddress);
    }
    if (message.oneSidedAddress.length !== 0) {
      obj.oneSidedAddress = base64FromBytes(message.oneSidedAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAddressResponse>, I>>(base?: I): GetAddressResponse {
    return GetAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAddressResponse>, I>>(object: I): GetAddressResponse {
    const message = createBaseGetAddressResponse();
    message.interactiveAddress = object.interactiveAddress ?? new Uint8Array(0);
    message.oneSidedAddress = object.oneSidedAddress ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetCompleteAddressResponse(): GetCompleteAddressResponse {
  return {
    interactiveAddress: new Uint8Array(0),
    oneSidedAddress: new Uint8Array(0),
    interactiveAddressBase58: "",
    oneSidedAddressBase58: "",
    interactiveAddressEmoji: "",
    oneSidedAddressEmoji: "",
  };
}

export const GetCompleteAddressResponse: MessageFns<GetCompleteAddressResponse> = {
  encode(message: GetCompleteAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.interactiveAddress.length !== 0) {
      writer.uint32(10).bytes(message.interactiveAddress);
    }
    if (message.oneSidedAddress.length !== 0) {
      writer.uint32(18).bytes(message.oneSidedAddress);
    }
    if (message.interactiveAddressBase58 !== "") {
      writer.uint32(26).string(message.interactiveAddressBase58);
    }
    if (message.oneSidedAddressBase58 !== "") {
      writer.uint32(34).string(message.oneSidedAddressBase58);
    }
    if (message.interactiveAddressEmoji !== "") {
      writer.uint32(42).string(message.interactiveAddressEmoji);
    }
    if (message.oneSidedAddressEmoji !== "") {
      writer.uint32(50).string(message.oneSidedAddressEmoji);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCompleteAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCompleteAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.interactiveAddress = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oneSidedAddress = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.interactiveAddressBase58 = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.oneSidedAddressBase58 = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.interactiveAddressEmoji = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.oneSidedAddressEmoji = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCompleteAddressResponse {
    return {
      interactiveAddress: isSet(object.interactiveAddress)
        ? bytesFromBase64(object.interactiveAddress)
        : new Uint8Array(0),
      oneSidedAddress: isSet(object.oneSidedAddress) ? bytesFromBase64(object.oneSidedAddress) : new Uint8Array(0),
      interactiveAddressBase58: isSet(object.interactiveAddressBase58)
        ? globalThis.String(object.interactiveAddressBase58)
        : "",
      oneSidedAddressBase58: isSet(object.oneSidedAddressBase58) ? globalThis.String(object.oneSidedAddressBase58) : "",
      interactiveAddressEmoji: isSet(object.interactiveAddressEmoji)
        ? globalThis.String(object.interactiveAddressEmoji)
        : "",
      oneSidedAddressEmoji: isSet(object.oneSidedAddressEmoji) ? globalThis.String(object.oneSidedAddressEmoji) : "",
    };
  },

  toJSON(message: GetCompleteAddressResponse): unknown {
    const obj: any = {};
    if (message.interactiveAddress.length !== 0) {
      obj.interactiveAddress = base64FromBytes(message.interactiveAddress);
    }
    if (message.oneSidedAddress.length !== 0) {
      obj.oneSidedAddress = base64FromBytes(message.oneSidedAddress);
    }
    if (message.interactiveAddressBase58 !== "") {
      obj.interactiveAddressBase58 = message.interactiveAddressBase58;
    }
    if (message.oneSidedAddressBase58 !== "") {
      obj.oneSidedAddressBase58 = message.oneSidedAddressBase58;
    }
    if (message.interactiveAddressEmoji !== "") {
      obj.interactiveAddressEmoji = message.interactiveAddressEmoji;
    }
    if (message.oneSidedAddressEmoji !== "") {
      obj.oneSidedAddressEmoji = message.oneSidedAddressEmoji;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCompleteAddressResponse>, I>>(base?: I): GetCompleteAddressResponse {
    return GetCompleteAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCompleteAddressResponse>, I>>(object: I): GetCompleteAddressResponse {
    const message = createBaseGetCompleteAddressResponse();
    message.interactiveAddress = object.interactiveAddress ?? new Uint8Array(0);
    message.oneSidedAddress = object.oneSidedAddress ?? new Uint8Array(0);
    message.interactiveAddressBase58 = object.interactiveAddressBase58 ?? "";
    message.oneSidedAddressBase58 = object.oneSidedAddressBase58 ?? "";
    message.interactiveAddressEmoji = object.interactiveAddressEmoji ?? "";
    message.oneSidedAddressEmoji = object.oneSidedAddressEmoji ?? "";
    return message;
  },
};

function createBaseTransferRequest(): TransferRequest {
  return { recipients: [] };
}

export const TransferRequest: MessageFns<TransferRequest> = {
  encode(message: TransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.recipients) {
      PaymentRecipient.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recipients.push(PaymentRecipient.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferRequest {
    return {
      recipients: globalThis.Array.isArray(object?.recipients)
        ? object.recipients.map((e: any) => PaymentRecipient.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransferRequest): unknown {
    const obj: any = {};
    if (message.recipients?.length) {
      obj.recipients = message.recipients.map((e) => PaymentRecipient.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferRequest>, I>>(base?: I): TransferRequest {
    return TransferRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferRequest>, I>>(object: I): TransferRequest {
    const message = createBaseTransferRequest();
    message.recipients = object.recipients?.map((e) => PaymentRecipient.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSendShaAtomicSwapRequest(): SendShaAtomicSwapRequest {
  return { recipient: undefined };
}

export const SendShaAtomicSwapRequest: MessageFns<SendShaAtomicSwapRequest> = {
  encode(message: SendShaAtomicSwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recipient !== undefined) {
      PaymentRecipient.encode(message.recipient, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendShaAtomicSwapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendShaAtomicSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recipient = PaymentRecipient.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendShaAtomicSwapRequest {
    return { recipient: isSet(object.recipient) ? PaymentRecipient.fromJSON(object.recipient) : undefined };
  },

  toJSON(message: SendShaAtomicSwapRequest): unknown {
    const obj: any = {};
    if (message.recipient !== undefined) {
      obj.recipient = PaymentRecipient.toJSON(message.recipient);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendShaAtomicSwapRequest>, I>>(base?: I): SendShaAtomicSwapRequest {
    return SendShaAtomicSwapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendShaAtomicSwapRequest>, I>>(object: I): SendShaAtomicSwapRequest {
    const message = createBaseSendShaAtomicSwapRequest();
    message.recipient = (object.recipient !== undefined && object.recipient !== null)
      ? PaymentRecipient.fromPartial(object.recipient)
      : undefined;
    return message;
  },
};

function createBaseCreateBurnTransactionRequest(): CreateBurnTransactionRequest {
  return {
    amount: Long.UZERO,
    feePerGram: Long.UZERO,
    claimPublicKey: new Uint8Array(0),
    paymentId: new Uint8Array(0),
  };
}

export const CreateBurnTransactionRequest: MessageFns<CreateBurnTransactionRequest> = {
  encode(message: CreateBurnTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.amount.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.amount.toString());
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.feePerGram.toString());
    }
    if (message.claimPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.claimPublicKey);
    }
    if (message.paymentId.length !== 0) {
      writer.uint32(42).bytes(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBurnTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBurnTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.amount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.claimPublicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBurnTransactionRequest {
    return {
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.UZERO,
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
      claimPublicKey: isSet(object.claimPublicKey) ? bytesFromBase64(object.claimPublicKey) : new Uint8Array(0),
      paymentId: isSet(object.paymentId) ? bytesFromBase64(object.paymentId) : new Uint8Array(0),
    };
  },

  toJSON(message: CreateBurnTransactionRequest): unknown {
    const obj: any = {};
    if (!message.amount.equals(Long.UZERO)) {
      obj.amount = (message.amount || Long.UZERO).toString();
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    if (message.claimPublicKey.length !== 0) {
      obj.claimPublicKey = base64FromBytes(message.claimPublicKey);
    }
    if (message.paymentId.length !== 0) {
      obj.paymentId = base64FromBytes(message.paymentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBurnTransactionRequest>, I>>(base?: I): CreateBurnTransactionRequest {
    return CreateBurnTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBurnTransactionRequest>, I>>(object: I): CreateBurnTransactionRequest {
    const message = createBaseCreateBurnTransactionRequest();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.UZERO;
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    message.claimPublicKey = object.claimPublicKey ?? new Uint8Array(0);
    message.paymentId = object.paymentId ?? new Uint8Array(0);
    return message;
  },
};

function createBasePaymentRecipient(): PaymentRecipient {
  return { address: "", amount: Long.UZERO, feePerGram: Long.UZERO, paymentType: 0, paymentId: new Uint8Array(0) };
}

export const PaymentRecipient: MessageFns<PaymentRecipient> = {
  encode(message: PaymentRecipient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (!message.amount.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.amount.toString());
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.feePerGram.toString());
    }
    if (message.paymentType !== 0) {
      writer.uint32(40).int32(message.paymentType);
    }
    if (message.paymentId.length !== 0) {
      writer.uint32(50).bytes(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentRecipient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentRecipient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.paymentType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.paymentId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentRecipient {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.UZERO,
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
      paymentType: isSet(object.paymentType) ? paymentRecipient_PaymentTypeFromJSON(object.paymentType) : 0,
      paymentId: isSet(object.paymentId) ? bytesFromBase64(object.paymentId) : new Uint8Array(0),
    };
  },

  toJSON(message: PaymentRecipient): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (!message.amount.equals(Long.UZERO)) {
      obj.amount = (message.amount || Long.UZERO).toString();
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    if (message.paymentType !== 0) {
      obj.paymentType = paymentRecipient_PaymentTypeToJSON(message.paymentType);
    }
    if (message.paymentId.length !== 0) {
      obj.paymentId = base64FromBytes(message.paymentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentRecipient>, I>>(base?: I): PaymentRecipient {
    return PaymentRecipient.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentRecipient>, I>>(object: I): PaymentRecipient {
    const message = createBasePaymentRecipient();
    message.address = object.address ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.UZERO;
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    message.paymentType = object.paymentType ?? 0;
    message.paymentId = object.paymentId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransferResponse(): TransferResponse {
  return { results: [] };
}

export const TransferResponse: MessageFns<TransferResponse> = {
  encode(message: TransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      TransferResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(TransferResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => TransferResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransferResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => TransferResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferResponse>, I>>(base?: I): TransferResponse {
    return TransferResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferResponse>, I>>(object: I): TransferResponse {
    const message = createBaseTransferResponse();
    message.results = object.results?.map((e) => TransferResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSendShaAtomicSwapResponse(): SendShaAtomicSwapResponse {
  return { transactionId: Long.UZERO, preImage: "", outputHash: "", isSuccess: false, failureMessage: "" };
}

export const SendShaAtomicSwapResponse: MessageFns<SendShaAtomicSwapResponse> = {
  encode(message: SendShaAtomicSwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.transactionId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.transactionId.toString());
    }
    if (message.preImage !== "") {
      writer.uint32(18).string(message.preImage);
    }
    if (message.outputHash !== "") {
      writer.uint32(26).string(message.outputHash);
    }
    if (message.isSuccess !== false) {
      writer.uint32(32).bool(message.isSuccess);
    }
    if (message.failureMessage !== "") {
      writer.uint32(42).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendShaAtomicSwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendShaAtomicSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preImage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outputHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendShaAtomicSwapResponse {
    return {
      transactionId: isSet(object.transactionId) ? Long.fromValue(object.transactionId) : Long.UZERO,
      preImage: isSet(object.preImage) ? globalThis.String(object.preImage) : "",
      outputHash: isSet(object.outputHash) ? globalThis.String(object.outputHash) : "",
      isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: SendShaAtomicSwapResponse): unknown {
    const obj: any = {};
    if (!message.transactionId.equals(Long.UZERO)) {
      obj.transactionId = (message.transactionId || Long.UZERO).toString();
    }
    if (message.preImage !== "") {
      obj.preImage = message.preImage;
    }
    if (message.outputHash !== "") {
      obj.outputHash = message.outputHash;
    }
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendShaAtomicSwapResponse>, I>>(base?: I): SendShaAtomicSwapResponse {
    return SendShaAtomicSwapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendShaAtomicSwapResponse>, I>>(object: I): SendShaAtomicSwapResponse {
    const message = createBaseSendShaAtomicSwapResponse();
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? Long.fromValue(object.transactionId)
      : Long.UZERO;
    message.preImage = object.preImage ?? "";
    message.outputHash = object.outputHash ?? "";
    message.isSuccess = object.isSuccess ?? false;
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

function createBaseCreateBurnTransactionResponse(): CreateBurnTransactionResponse {
  return {
    transactionId: Long.UZERO,
    isSuccess: false,
    failureMessage: "",
    commitment: new Uint8Array(0),
    ownershipProof: undefined,
    rangeProof: new Uint8Array(0),
    reciprocalClaimPublicKey: new Uint8Array(0),
  };
}

export const CreateBurnTransactionResponse: MessageFns<CreateBurnTransactionResponse> = {
  encode(message: CreateBurnTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.transactionId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.transactionId.toString());
    }
    if (message.isSuccess !== false) {
      writer.uint32(16).bool(message.isSuccess);
    }
    if (message.failureMessage !== "") {
      writer.uint32(26).string(message.failureMessage);
    }
    if (message.commitment.length !== 0) {
      writer.uint32(34).bytes(message.commitment);
    }
    if (message.ownershipProof !== undefined) {
      CommitmentSignature.encode(message.ownershipProof, writer.uint32(42).fork()).join();
    }
    if (message.rangeProof.length !== 0) {
      writer.uint32(50).bytes(message.rangeProof);
    }
    if (message.reciprocalClaimPublicKey.length !== 0) {
      writer.uint32(58).bytes(message.reciprocalClaimPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBurnTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBurnTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commitment = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ownershipProof = CommitmentSignature.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rangeProof = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.reciprocalClaimPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBurnTransactionResponse {
    return {
      transactionId: isSet(object.transactionId) ? Long.fromValue(object.transactionId) : Long.UZERO,
      isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
      commitment: isSet(object.commitment) ? bytesFromBase64(object.commitment) : new Uint8Array(0),
      ownershipProof: isSet(object.ownershipProof) ? CommitmentSignature.fromJSON(object.ownershipProof) : undefined,
      rangeProof: isSet(object.rangeProof) ? bytesFromBase64(object.rangeProof) : new Uint8Array(0),
      reciprocalClaimPublicKey: isSet(object.reciprocalClaimPublicKey)
        ? bytesFromBase64(object.reciprocalClaimPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CreateBurnTransactionResponse): unknown {
    const obj: any = {};
    if (!message.transactionId.equals(Long.UZERO)) {
      obj.transactionId = (message.transactionId || Long.UZERO).toString();
    }
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    if (message.commitment.length !== 0) {
      obj.commitment = base64FromBytes(message.commitment);
    }
    if (message.ownershipProof !== undefined) {
      obj.ownershipProof = CommitmentSignature.toJSON(message.ownershipProof);
    }
    if (message.rangeProof.length !== 0) {
      obj.rangeProof = base64FromBytes(message.rangeProof);
    }
    if (message.reciprocalClaimPublicKey.length !== 0) {
      obj.reciprocalClaimPublicKey = base64FromBytes(message.reciprocalClaimPublicKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBurnTransactionResponse>, I>>(base?: I): CreateBurnTransactionResponse {
    return CreateBurnTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBurnTransactionResponse>, I>>(
    object: I,
  ): CreateBurnTransactionResponse {
    const message = createBaseCreateBurnTransactionResponse();
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? Long.fromValue(object.transactionId)
      : Long.UZERO;
    message.isSuccess = object.isSuccess ?? false;
    message.failureMessage = object.failureMessage ?? "";
    message.commitment = object.commitment ?? new Uint8Array(0);
    message.ownershipProof = (object.ownershipProof !== undefined && object.ownershipProof !== null)
      ? CommitmentSignature.fromPartial(object.ownershipProof)
      : undefined;
    message.rangeProof = object.rangeProof ?? new Uint8Array(0);
    message.reciprocalClaimPublicKey = object.reciprocalClaimPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransferResult(): TransferResult {
  return { address: "", transactionId: Long.UZERO, isSuccess: false, failureMessage: "" };
}

export const TransferResult: MessageFns<TransferResult> = {
  encode(message: TransferResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (!message.transactionId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.transactionId.toString());
    }
    if (message.isSuccess !== false) {
      writer.uint32(24).bool(message.isSuccess);
    }
    if (message.failureMessage !== "") {
      writer.uint32(34).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.transactionId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferResult {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      transactionId: isSet(object.transactionId) ? Long.fromValue(object.transactionId) : Long.UZERO,
      isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: TransferResult): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (!message.transactionId.equals(Long.UZERO)) {
      obj.transactionId = (message.transactionId || Long.UZERO).toString();
    }
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferResult>, I>>(base?: I): TransferResult {
    return TransferResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferResult>, I>>(object: I): TransferResult {
    const message = createBaseTransferResult();
    message.address = object.address ?? "";
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? Long.fromValue(object.transactionId)
      : Long.UZERO;
    message.isSuccess = object.isSuccess ?? false;
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

function createBaseClaimShaAtomicSwapRequest(): ClaimShaAtomicSwapRequest {
  return { output: "", preImage: "", feePerGram: Long.UZERO };
}

export const ClaimShaAtomicSwapRequest: MessageFns<ClaimShaAtomicSwapRequest> = {
  encode(message: ClaimShaAtomicSwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.output !== "") {
      writer.uint32(10).string(message.output);
    }
    if (message.preImage !== "") {
      writer.uint32(18).string(message.preImage);
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.feePerGram.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimShaAtomicSwapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimShaAtomicSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.output = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preImage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimShaAtomicSwapRequest {
    return {
      output: isSet(object.output) ? globalThis.String(object.output) : "",
      preImage: isSet(object.preImage) ? globalThis.String(object.preImage) : "",
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
    };
  },

  toJSON(message: ClaimShaAtomicSwapRequest): unknown {
    const obj: any = {};
    if (message.output !== "") {
      obj.output = message.output;
    }
    if (message.preImage !== "") {
      obj.preImage = message.preImage;
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimShaAtomicSwapRequest>, I>>(base?: I): ClaimShaAtomicSwapRequest {
    return ClaimShaAtomicSwapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimShaAtomicSwapRequest>, I>>(object: I): ClaimShaAtomicSwapRequest {
    const message = createBaseClaimShaAtomicSwapRequest();
    message.output = object.output ?? "";
    message.preImage = object.preImage ?? "";
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    return message;
  },
};

function createBaseClaimShaAtomicSwapResponse(): ClaimShaAtomicSwapResponse {
  return { results: undefined };
}

export const ClaimShaAtomicSwapResponse: MessageFns<ClaimShaAtomicSwapResponse> = {
  encode(message: ClaimShaAtomicSwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.results !== undefined) {
      TransferResult.encode(message.results, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimShaAtomicSwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimShaAtomicSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results = TransferResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimShaAtomicSwapResponse {
    return { results: isSet(object.results) ? TransferResult.fromJSON(object.results) : undefined };
  },

  toJSON(message: ClaimShaAtomicSwapResponse): unknown {
    const obj: any = {};
    if (message.results !== undefined) {
      obj.results = TransferResult.toJSON(message.results);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimShaAtomicSwapResponse>, I>>(base?: I): ClaimShaAtomicSwapResponse {
    return ClaimShaAtomicSwapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimShaAtomicSwapResponse>, I>>(object: I): ClaimShaAtomicSwapResponse {
    const message = createBaseClaimShaAtomicSwapResponse();
    message.results = (object.results !== undefined && object.results !== null)
      ? TransferResult.fromPartial(object.results)
      : undefined;
    return message;
  },
};

function createBaseClaimHtlcRefundRequest(): ClaimHtlcRefundRequest {
  return { outputHash: "", feePerGram: Long.UZERO };
}

export const ClaimHtlcRefundRequest: MessageFns<ClaimHtlcRefundRequest> = {
  encode(message: ClaimHtlcRefundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputHash !== "") {
      writer.uint32(10).string(message.outputHash);
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.feePerGram.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimHtlcRefundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimHtlcRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimHtlcRefundRequest {
    return {
      outputHash: isSet(object.outputHash) ? globalThis.String(object.outputHash) : "",
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
    };
  },

  toJSON(message: ClaimHtlcRefundRequest): unknown {
    const obj: any = {};
    if (message.outputHash !== "") {
      obj.outputHash = message.outputHash;
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimHtlcRefundRequest>, I>>(base?: I): ClaimHtlcRefundRequest {
    return ClaimHtlcRefundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimHtlcRefundRequest>, I>>(object: I): ClaimHtlcRefundRequest {
    const message = createBaseClaimHtlcRefundRequest();
    message.outputHash = object.outputHash ?? "";
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    return message;
  },
};

function createBaseClaimHtlcRefundResponse(): ClaimHtlcRefundResponse {
  return { results: undefined };
}

export const ClaimHtlcRefundResponse: MessageFns<ClaimHtlcRefundResponse> = {
  encode(message: ClaimHtlcRefundResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.results !== undefined) {
      TransferResult.encode(message.results, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimHtlcRefundResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimHtlcRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results = TransferResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimHtlcRefundResponse {
    return { results: isSet(object.results) ? TransferResult.fromJSON(object.results) : undefined };
  },

  toJSON(message: ClaimHtlcRefundResponse): unknown {
    const obj: any = {};
    if (message.results !== undefined) {
      obj.results = TransferResult.toJSON(message.results);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimHtlcRefundResponse>, I>>(base?: I): ClaimHtlcRefundResponse {
    return ClaimHtlcRefundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimHtlcRefundResponse>, I>>(object: I): ClaimHtlcRefundResponse {
    const message = createBaseClaimHtlcRefundResponse();
    message.results = (object.results !== undefined && object.results !== null)
      ? TransferResult.fromPartial(object.results)
      : undefined;
    return message;
  },
};

function createBaseGetTransactionInfoRequest(): GetTransactionInfoRequest {
  return { transactionIds: [] };
}

export const GetTransactionInfoRequest: MessageFns<GetTransactionInfoRequest> = {
  encode(message: GetTransactionInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.transactionIds) {
      writer.uint64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.transactionIds.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.transactionIds.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionInfoRequest {
    return {
      transactionIds: globalThis.Array.isArray(object?.transactionIds)
        ? object.transactionIds.map((e: any) => Long.fromValue(e))
        : [],
    };
  },

  toJSON(message: GetTransactionInfoRequest): unknown {
    const obj: any = {};
    if (message.transactionIds?.length) {
      obj.transactionIds = message.transactionIds.map((e) => (e || Long.UZERO).toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionInfoRequest>, I>>(base?: I): GetTransactionInfoRequest {
    return GetTransactionInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionInfoRequest>, I>>(object: I): GetTransactionInfoRequest {
    const message = createBaseGetTransactionInfoRequest();
    message.transactionIds = object.transactionIds?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseGetTransactionInfoResponse(): GetTransactionInfoResponse {
  return { transactions: [] };
}

export const GetTransactionInfoResponse: MessageFns<GetTransactionInfoResponse> = {
  encode(message: GetTransactionInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactions) {
      TransactionInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactions.push(TransactionInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionInfoResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TransactionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetTransactionInfoResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TransactionInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionInfoResponse>, I>>(base?: I): GetTransactionInfoResponse {
    return GetTransactionInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionInfoResponse>, I>>(object: I): GetTransactionInfoResponse {
    const message = createBaseGetTransactionInfoResponse();
    message.transactions = object.transactions?.map((e) => TransactionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionInfo(): TransactionInfo {
  return {
    txId: Long.UZERO,
    sourceAddress: new Uint8Array(0),
    destAddress: new Uint8Array(0),
    status: 0,
    direction: 0,
    amount: Long.UZERO,
    fee: Long.UZERO,
    isCancelled: false,
    excessSig: new Uint8Array(0),
    timestamp: Long.UZERO,
    paymentId: new Uint8Array(0),
    minedInBlockHeight: Long.UZERO,
  };
}

export const TransactionInfo: MessageFns<TransactionInfo> = {
  encode(message: TransactionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.txId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.txId.toString());
    }
    if (message.sourceAddress.length !== 0) {
      writer.uint32(18).bytes(message.sourceAddress);
    }
    if (message.destAddress.length !== 0) {
      writer.uint32(26).bytes(message.destAddress);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.direction !== 0) {
      writer.uint32(40).int32(message.direction);
    }
    if (!message.amount.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.amount.toString());
    }
    if (!message.fee.equals(Long.UZERO)) {
      writer.uint32(56).uint64(message.fee.toString());
    }
    if (message.isCancelled !== false) {
      writer.uint32(64).bool(message.isCancelled);
    }
    if (message.excessSig.length !== 0) {
      writer.uint32(74).bytes(message.excessSig);
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      writer.uint32(80).uint64(message.timestamp.toString());
    }
    if (message.paymentId.length !== 0) {
      writer.uint32(98).bytes(message.paymentId);
    }
    if (!message.minedInBlockHeight.equals(Long.UZERO)) {
      writer.uint32(104).uint64(message.minedInBlockHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceAddress = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.amount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.fee = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isCancelled = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.excessSig = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.timestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.paymentId = reader.bytes();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.minedInBlockHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo {
    return {
      txId: isSet(object.txId) ? Long.fromValue(object.txId) : Long.UZERO,
      sourceAddress: isSet(object.sourceAddress) ? bytesFromBase64(object.sourceAddress) : new Uint8Array(0),
      destAddress: isSet(object.destAddress) ? bytesFromBase64(object.destAddress) : new Uint8Array(0),
      status: isSet(object.status) ? transactionStatusFromJSON(object.status) : 0,
      direction: isSet(object.direction) ? transactionDirectionFromJSON(object.direction) : 0,
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.UZERO,
      fee: isSet(object.fee) ? Long.fromValue(object.fee) : Long.UZERO,
      isCancelled: isSet(object.isCancelled) ? globalThis.Boolean(object.isCancelled) : false,
      excessSig: isSet(object.excessSig) ? bytesFromBase64(object.excessSig) : new Uint8Array(0),
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.UZERO,
      paymentId: isSet(object.paymentId) ? bytesFromBase64(object.paymentId) : new Uint8Array(0),
      minedInBlockHeight: isSet(object.minedInBlockHeight) ? Long.fromValue(object.minedInBlockHeight) : Long.UZERO,
    };
  },

  toJSON(message: TransactionInfo): unknown {
    const obj: any = {};
    if (!message.txId.equals(Long.UZERO)) {
      obj.txId = (message.txId || Long.UZERO).toString();
    }
    if (message.sourceAddress.length !== 0) {
      obj.sourceAddress = base64FromBytes(message.sourceAddress);
    }
    if (message.destAddress.length !== 0) {
      obj.destAddress = base64FromBytes(message.destAddress);
    }
    if (message.status !== 0) {
      obj.status = transactionStatusToJSON(message.status);
    }
    if (message.direction !== 0) {
      obj.direction = transactionDirectionToJSON(message.direction);
    }
    if (!message.amount.equals(Long.UZERO)) {
      obj.amount = (message.amount || Long.UZERO).toString();
    }
    if (!message.fee.equals(Long.UZERO)) {
      obj.fee = (message.fee || Long.UZERO).toString();
    }
    if (message.isCancelled !== false) {
      obj.isCancelled = message.isCancelled;
    }
    if (message.excessSig.length !== 0) {
      obj.excessSig = base64FromBytes(message.excessSig);
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      obj.timestamp = (message.timestamp || Long.UZERO).toString();
    }
    if (message.paymentId.length !== 0) {
      obj.paymentId = base64FromBytes(message.paymentId);
    }
    if (!message.minedInBlockHeight.equals(Long.UZERO)) {
      obj.minedInBlockHeight = (message.minedInBlockHeight || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionInfo>, I>>(base?: I): TransactionInfo {
    return TransactionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionInfo>, I>>(object: I): TransactionInfo {
    const message = createBaseTransactionInfo();
    message.txId = (object.txId !== undefined && object.txId !== null) ? Long.fromValue(object.txId) : Long.UZERO;
    message.sourceAddress = object.sourceAddress ?? new Uint8Array(0);
    message.destAddress = object.destAddress ?? new Uint8Array(0);
    message.status = object.status ?? 0;
    message.direction = object.direction ?? 0;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.UZERO;
    message.fee = (object.fee !== undefined && object.fee !== null) ? Long.fromValue(object.fee) : Long.UZERO;
    message.isCancelled = object.isCancelled ?? false;
    message.excessSig = object.excessSig ?? new Uint8Array(0);
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.UZERO;
    message.paymentId = object.paymentId ?? new Uint8Array(0);
    message.minedInBlockHeight = (object.minedInBlockHeight !== undefined && object.minedInBlockHeight !== null)
      ? Long.fromValue(object.minedInBlockHeight)
      : Long.UZERO;
    return message;
  },
};

function createBaseGetCompletedTransactionsRequest(): GetCompletedTransactionsRequest {
  return {};
}

export const GetCompletedTransactionsRequest: MessageFns<GetCompletedTransactionsRequest> = {
  encode(_: GetCompletedTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCompletedTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCompletedTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetCompletedTransactionsRequest {
    return {};
  },

  toJSON(_: GetCompletedTransactionsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCompletedTransactionsRequest>, I>>(base?: I): GetCompletedTransactionsRequest {
    return GetCompletedTransactionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCompletedTransactionsRequest>, I>>(_: I): GetCompletedTransactionsRequest {
    const message = createBaseGetCompletedTransactionsRequest();
    return message;
  },
};

function createBaseGetCompletedTransactionsResponse(): GetCompletedTransactionsResponse {
  return { transaction: undefined };
}

export const GetCompletedTransactionsResponse: MessageFns<GetCompletedTransactionsResponse> = {
  encode(message: GetCompletedTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      TransactionInfo.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCompletedTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCompletedTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = TransactionInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCompletedTransactionsResponse {
    return { transaction: isSet(object.transaction) ? TransactionInfo.fromJSON(object.transaction) : undefined };
  },

  toJSON(message: GetCompletedTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = TransactionInfo.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCompletedTransactionsResponse>, I>>(
    base?: I,
  ): GetCompletedTransactionsResponse {
    return GetCompletedTransactionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCompletedTransactionsResponse>, I>>(
    object: I,
  ): GetCompletedTransactionsResponse {
    const message = createBaseGetCompletedTransactionsResponse();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? TransactionInfo.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseGetBalanceRequest(): GetBalanceRequest {
  return {};
}

export const GetBalanceRequest: MessageFns<GetBalanceRequest> = {
  encode(_: GetBalanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBalanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetBalanceRequest {
    return {};
  },

  toJSON(_: GetBalanceRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBalanceRequest>, I>>(base?: I): GetBalanceRequest {
    return GetBalanceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBalanceRequest>, I>>(_: I): GetBalanceRequest {
    const message = createBaseGetBalanceRequest();
    return message;
  },
};

function createBaseGetStateRequest(): GetStateRequest {
  return {};
}

export const GetStateRequest: MessageFns<GetStateRequest> = {
  encode(_: GetStateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetStateRequest {
    return {};
  },

  toJSON(_: GetStateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStateRequest>, I>>(base?: I): GetStateRequest {
    return GetStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStateRequest>, I>>(_: I): GetStateRequest {
    const message = createBaseGetStateRequest();
    return message;
  },
};

function createBaseGetBalanceResponse(): GetBalanceResponse {
  return {
    availableBalance: Long.UZERO,
    pendingIncomingBalance: Long.UZERO,
    pendingOutgoingBalance: Long.UZERO,
    timelockedBalance: Long.UZERO,
  };
}

export const GetBalanceResponse: MessageFns<GetBalanceResponse> = {
  encode(message: GetBalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.availableBalance.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.availableBalance.toString());
    }
    if (!message.pendingIncomingBalance.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.pendingIncomingBalance.toString());
    }
    if (!message.pendingOutgoingBalance.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.pendingOutgoingBalance.toString());
    }
    if (!message.timelockedBalance.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.timelockedBalance.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBalanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.availableBalance = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pendingIncomingBalance = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pendingOutgoingBalance = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timelockedBalance = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBalanceResponse {
    return {
      availableBalance: isSet(object.availableBalance) ? Long.fromValue(object.availableBalance) : Long.UZERO,
      pendingIncomingBalance: isSet(object.pendingIncomingBalance)
        ? Long.fromValue(object.pendingIncomingBalance)
        : Long.UZERO,
      pendingOutgoingBalance: isSet(object.pendingOutgoingBalance)
        ? Long.fromValue(object.pendingOutgoingBalance)
        : Long.UZERO,
      timelockedBalance: isSet(object.timelockedBalance) ? Long.fromValue(object.timelockedBalance) : Long.UZERO,
    };
  },

  toJSON(message: GetBalanceResponse): unknown {
    const obj: any = {};
    if (!message.availableBalance.equals(Long.UZERO)) {
      obj.availableBalance = (message.availableBalance || Long.UZERO).toString();
    }
    if (!message.pendingIncomingBalance.equals(Long.UZERO)) {
      obj.pendingIncomingBalance = (message.pendingIncomingBalance || Long.UZERO).toString();
    }
    if (!message.pendingOutgoingBalance.equals(Long.UZERO)) {
      obj.pendingOutgoingBalance = (message.pendingOutgoingBalance || Long.UZERO).toString();
    }
    if (!message.timelockedBalance.equals(Long.UZERO)) {
      obj.timelockedBalance = (message.timelockedBalance || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBalanceResponse>, I>>(base?: I): GetBalanceResponse {
    return GetBalanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBalanceResponse>, I>>(object: I): GetBalanceResponse {
    const message = createBaseGetBalanceResponse();
    message.availableBalance = (object.availableBalance !== undefined && object.availableBalance !== null)
      ? Long.fromValue(object.availableBalance)
      : Long.UZERO;
    message.pendingIncomingBalance =
      (object.pendingIncomingBalance !== undefined && object.pendingIncomingBalance !== null)
        ? Long.fromValue(object.pendingIncomingBalance)
        : Long.UZERO;
    message.pendingOutgoingBalance =
      (object.pendingOutgoingBalance !== undefined && object.pendingOutgoingBalance !== null)
        ? Long.fromValue(object.pendingOutgoingBalance)
        : Long.UZERO;
    message.timelockedBalance = (object.timelockedBalance !== undefined && object.timelockedBalance !== null)
      ? Long.fromValue(object.timelockedBalance)
      : Long.UZERO;
    return message;
  },
};

function createBaseGetStateResponse(): GetStateResponse {
  return { scannedHeight: Long.UZERO, balance: undefined, network: undefined };
}

export const GetStateResponse: MessageFns<GetStateResponse> = {
  encode(message: GetStateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.scannedHeight.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.scannedHeight.toString());
    }
    if (message.balance !== undefined) {
      GetBalanceResponse.encode(message.balance, writer.uint32(18).fork()).join();
    }
    if (message.network !== undefined) {
      NetworkStatusResponse.encode(message.network, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.scannedHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.balance = GetBalanceResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.network = NetworkStatusResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStateResponse {
    return {
      scannedHeight: isSet(object.scannedHeight) ? Long.fromValue(object.scannedHeight) : Long.UZERO,
      balance: isSet(object.balance) ? GetBalanceResponse.fromJSON(object.balance) : undefined,
      network: isSet(object.network) ? NetworkStatusResponse.fromJSON(object.network) : undefined,
    };
  },

  toJSON(message: GetStateResponse): unknown {
    const obj: any = {};
    if (!message.scannedHeight.equals(Long.UZERO)) {
      obj.scannedHeight = (message.scannedHeight || Long.UZERO).toString();
    }
    if (message.balance !== undefined) {
      obj.balance = GetBalanceResponse.toJSON(message.balance);
    }
    if (message.network !== undefined) {
      obj.network = NetworkStatusResponse.toJSON(message.network);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStateResponse>, I>>(base?: I): GetStateResponse {
    return GetStateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStateResponse>, I>>(object: I): GetStateResponse {
    const message = createBaseGetStateResponse();
    message.scannedHeight = (object.scannedHeight !== undefined && object.scannedHeight !== null)
      ? Long.fromValue(object.scannedHeight)
      : Long.UZERO;
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? GetBalanceResponse.fromPartial(object.balance)
      : undefined;
    message.network = (object.network !== undefined && object.network !== null)
      ? NetworkStatusResponse.fromPartial(object.network)
      : undefined;
    return message;
  },
};

function createBaseGetUnspentAmountsResponse(): GetUnspentAmountsResponse {
  return { amount: [] };
}

export const GetUnspentAmountsResponse: MessageFns<GetUnspentAmountsResponse> = {
  encode(message: GetUnspentAmountsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.amount) {
      writer.uint64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUnspentAmountsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUnspentAmountsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.amount.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.amount.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUnspentAmountsResponse {
    return { amount: globalThis.Array.isArray(object?.amount) ? object.amount.map((e: any) => Long.fromValue(e)) : [] };
  },

  toJSON(message: GetUnspentAmountsResponse): unknown {
    const obj: any = {};
    if (message.amount?.length) {
      obj.amount = message.amount.map((e) => (e || Long.UZERO).toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUnspentAmountsResponse>, I>>(base?: I): GetUnspentAmountsResponse {
    return GetUnspentAmountsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUnspentAmountsResponse>, I>>(object: I): GetUnspentAmountsResponse {
    const message = createBaseGetUnspentAmountsResponse();
    message.amount = object.amount?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseCoinSplitRequest(): CoinSplitRequest {
  return {
    amountPerSplit: Long.UZERO,
    splitCount: Long.UZERO,
    feePerGram: Long.UZERO,
    lockHeight: Long.UZERO,
    paymentId: new Uint8Array(0),
  };
}

export const CoinSplitRequest: MessageFns<CoinSplitRequest> = {
  encode(message: CoinSplitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.amountPerSplit.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.amountPerSplit.toString());
    }
    if (!message.splitCount.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.splitCount.toString());
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.feePerGram.toString());
    }
    if (!message.lockHeight.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.lockHeight.toString());
    }
    if (message.paymentId.length !== 0) {
      writer.uint32(50).bytes(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoinSplitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoinSplitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.amountPerSplit = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.splitCount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lockHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.paymentId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoinSplitRequest {
    return {
      amountPerSplit: isSet(object.amountPerSplit) ? Long.fromValue(object.amountPerSplit) : Long.UZERO,
      splitCount: isSet(object.splitCount) ? Long.fromValue(object.splitCount) : Long.UZERO,
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
      lockHeight: isSet(object.lockHeight) ? Long.fromValue(object.lockHeight) : Long.UZERO,
      paymentId: isSet(object.paymentId) ? bytesFromBase64(object.paymentId) : new Uint8Array(0),
    };
  },

  toJSON(message: CoinSplitRequest): unknown {
    const obj: any = {};
    if (!message.amountPerSplit.equals(Long.UZERO)) {
      obj.amountPerSplit = (message.amountPerSplit || Long.UZERO).toString();
    }
    if (!message.splitCount.equals(Long.UZERO)) {
      obj.splitCount = (message.splitCount || Long.UZERO).toString();
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    if (!message.lockHeight.equals(Long.UZERO)) {
      obj.lockHeight = (message.lockHeight || Long.UZERO).toString();
    }
    if (message.paymentId.length !== 0) {
      obj.paymentId = base64FromBytes(message.paymentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CoinSplitRequest>, I>>(base?: I): CoinSplitRequest {
    return CoinSplitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CoinSplitRequest>, I>>(object: I): CoinSplitRequest {
    const message = createBaseCoinSplitRequest();
    message.amountPerSplit = (object.amountPerSplit !== undefined && object.amountPerSplit !== null)
      ? Long.fromValue(object.amountPerSplit)
      : Long.UZERO;
    message.splitCount = (object.splitCount !== undefined && object.splitCount !== null)
      ? Long.fromValue(object.splitCount)
      : Long.UZERO;
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    message.lockHeight = (object.lockHeight !== undefined && object.lockHeight !== null)
      ? Long.fromValue(object.lockHeight)
      : Long.UZERO;
    message.paymentId = object.paymentId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCoinSplitResponse(): CoinSplitResponse {
  return { txId: Long.UZERO };
}

export const CoinSplitResponse: MessageFns<CoinSplitResponse> = {
  encode(message: CoinSplitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.txId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.txId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoinSplitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoinSplitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoinSplitResponse {
    return { txId: isSet(object.txId) ? Long.fromValue(object.txId) : Long.UZERO };
  },

  toJSON(message: CoinSplitResponse): unknown {
    const obj: any = {};
    if (!message.txId.equals(Long.UZERO)) {
      obj.txId = (message.txId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CoinSplitResponse>, I>>(base?: I): CoinSplitResponse {
    return CoinSplitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CoinSplitResponse>, I>>(object: I): CoinSplitResponse {
    const message = createBaseCoinSplitResponse();
    message.txId = (object.txId !== undefined && object.txId !== null) ? Long.fromValue(object.txId) : Long.UZERO;
    return message;
  },
};

function createBaseImportUtxosRequest(): ImportUtxosRequest {
  return { outputs: [], paymentId: new Uint8Array(0) };
}

export const ImportUtxosRequest: MessageFns<ImportUtxosRequest> = {
  encode(message: ImportUtxosRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.outputs) {
      UnblindedOutput.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.paymentId.length !== 0) {
      writer.uint32(18).bytes(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportUtxosRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportUtxosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputs.push(UnblindedOutput.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportUtxosRequest {
    return {
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => UnblindedOutput.fromJSON(e))
        : [],
      paymentId: isSet(object.paymentId) ? bytesFromBase64(object.paymentId) : new Uint8Array(0),
    };
  },

  toJSON(message: ImportUtxosRequest): unknown {
    const obj: any = {};
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => UnblindedOutput.toJSON(e));
    }
    if (message.paymentId.length !== 0) {
      obj.paymentId = base64FromBytes(message.paymentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportUtxosRequest>, I>>(base?: I): ImportUtxosRequest {
    return ImportUtxosRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportUtxosRequest>, I>>(object: I): ImportUtxosRequest {
    const message = createBaseImportUtxosRequest();
    message.outputs = object.outputs?.map((e) => UnblindedOutput.fromPartial(e)) || [];
    message.paymentId = object.paymentId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseImportUtxosResponse(): ImportUtxosResponse {
  return { txIds: [] };
}

export const ImportUtxosResponse: MessageFns<ImportUtxosResponse> = {
  encode(message: ImportUtxosResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.txIds) {
      writer.uint64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportUtxosResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportUtxosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.txIds.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.txIds.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportUtxosResponse {
    return { txIds: globalThis.Array.isArray(object?.txIds) ? object.txIds.map((e: any) => Long.fromValue(e)) : [] };
  },

  toJSON(message: ImportUtxosResponse): unknown {
    const obj: any = {};
    if (message.txIds?.length) {
      obj.txIds = message.txIds.map((e) => (e || Long.UZERO).toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportUtxosResponse>, I>>(base?: I): ImportUtxosResponse {
    return ImportUtxosResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportUtxosResponse>, I>>(object: I): ImportUtxosResponse {
    const message = createBaseImportUtxosResponse();
    message.txIds = object.txIds?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseCreateTemplateRegistrationRequest(): CreateTemplateRegistrationRequest {
  return { templateRegistration: undefined, feePerGram: Long.UZERO };
}

export const CreateTemplateRegistrationRequest: MessageFns<CreateTemplateRegistrationRequest> = {
  encode(message: CreateTemplateRegistrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateRegistration !== undefined) {
      TemplateRegistration.encode(message.templateRegistration, writer.uint32(10).fork()).join();
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.feePerGram.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTemplateRegistrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTemplateRegistrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.templateRegistration = TemplateRegistration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTemplateRegistrationRequest {
    return {
      templateRegistration: isSet(object.templateRegistration)
        ? TemplateRegistration.fromJSON(object.templateRegistration)
        : undefined,
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
    };
  },

  toJSON(message: CreateTemplateRegistrationRequest): unknown {
    const obj: any = {};
    if (message.templateRegistration !== undefined) {
      obj.templateRegistration = TemplateRegistration.toJSON(message.templateRegistration);
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTemplateRegistrationRequest>, I>>(
    base?: I,
  ): CreateTemplateRegistrationRequest {
    return CreateTemplateRegistrationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTemplateRegistrationRequest>, I>>(
    object: I,
  ): CreateTemplateRegistrationRequest {
    const message = createBaseCreateTemplateRegistrationRequest();
    message.templateRegistration = (object.templateRegistration !== undefined && object.templateRegistration !== null)
      ? TemplateRegistration.fromPartial(object.templateRegistration)
      : undefined;
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    return message;
  },
};

function createBaseCreateTemplateRegistrationResponse(): CreateTemplateRegistrationResponse {
  return { txId: Long.UZERO, templateAddress: new Uint8Array(0) };
}

export const CreateTemplateRegistrationResponse: MessageFns<CreateTemplateRegistrationResponse> = {
  encode(message: CreateTemplateRegistrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.txId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.txId.toString());
    }
    if (message.templateAddress.length !== 0) {
      writer.uint32(18).bytes(message.templateAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTemplateRegistrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTemplateRegistrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.templateAddress = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTemplateRegistrationResponse {
    return {
      txId: isSet(object.txId) ? Long.fromValue(object.txId) : Long.UZERO,
      templateAddress: isSet(object.templateAddress) ? bytesFromBase64(object.templateAddress) : new Uint8Array(0),
    };
  },

  toJSON(message: CreateTemplateRegistrationResponse): unknown {
    const obj: any = {};
    if (!message.txId.equals(Long.UZERO)) {
      obj.txId = (message.txId || Long.UZERO).toString();
    }
    if (message.templateAddress.length !== 0) {
      obj.templateAddress = base64FromBytes(message.templateAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTemplateRegistrationResponse>, I>>(
    base?: I,
  ): CreateTemplateRegistrationResponse {
    return CreateTemplateRegistrationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTemplateRegistrationResponse>, I>>(
    object: I,
  ): CreateTemplateRegistrationResponse {
    const message = createBaseCreateTemplateRegistrationResponse();
    message.txId = (object.txId !== undefined && object.txId !== null) ? Long.fromValue(object.txId) : Long.UZERO;
    message.templateAddress = object.templateAddress ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCancelTransactionRequest(): CancelTransactionRequest {
  return { txId: Long.UZERO };
}

export const CancelTransactionRequest: MessageFns<CancelTransactionRequest> = {
  encode(message: CancelTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.txId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.txId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTransactionRequest {
    return { txId: isSet(object.txId) ? Long.fromValue(object.txId) : Long.UZERO };
  },

  toJSON(message: CancelTransactionRequest): unknown {
    const obj: any = {};
    if (!message.txId.equals(Long.UZERO)) {
      obj.txId = (message.txId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelTransactionRequest>, I>>(base?: I): CancelTransactionRequest {
    return CancelTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelTransactionRequest>, I>>(object: I): CancelTransactionRequest {
    const message = createBaseCancelTransactionRequest();
    message.txId = (object.txId !== undefined && object.txId !== null) ? Long.fromValue(object.txId) : Long.UZERO;
    return message;
  },
};

function createBaseCancelTransactionResponse(): CancelTransactionResponse {
  return { isSuccess: false, failureMessage: "" };
}

export const CancelTransactionResponse: MessageFns<CancelTransactionResponse> = {
  encode(message: CancelTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isSuccess !== false) {
      writer.uint32(8).bool(message.isSuccess);
    }
    if (message.failureMessage !== "") {
      writer.uint32(18).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTransactionResponse {
    return {
      isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: CancelTransactionResponse): unknown {
    const obj: any = {};
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelTransactionResponse>, I>>(base?: I): CancelTransactionResponse {
    return CancelTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelTransactionResponse>, I>>(object: I): CancelTransactionResponse {
    const message = createBaseCancelTransactionResponse();
    message.isSuccess = object.isSuccess ?? false;
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

function createBaseRevalidateRequest(): RevalidateRequest {
  return {};
}

export const RevalidateRequest: MessageFns<RevalidateRequest> = {
  encode(_: RevalidateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevalidateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevalidateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RevalidateRequest {
    return {};
  },

  toJSON(_: RevalidateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RevalidateRequest>, I>>(base?: I): RevalidateRequest {
    return RevalidateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevalidateRequest>, I>>(_: I): RevalidateRequest {
    const message = createBaseRevalidateRequest();
    return message;
  },
};

function createBaseRevalidateResponse(): RevalidateResponse {
  return {};
}

export const RevalidateResponse: MessageFns<RevalidateResponse> = {
  encode(_: RevalidateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevalidateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevalidateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RevalidateResponse {
    return {};
  },

  toJSON(_: RevalidateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RevalidateResponse>, I>>(base?: I): RevalidateResponse {
    return RevalidateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevalidateResponse>, I>>(_: I): RevalidateResponse {
    const message = createBaseRevalidateResponse();
    return message;
  },
};

function createBaseValidateRequest(): ValidateRequest {
  return {};
}

export const ValidateRequest: MessageFns<ValidateRequest> = {
  encode(_: ValidateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ValidateRequest {
    return {};
  },

  toJSON(_: ValidateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateRequest>, I>>(base?: I): ValidateRequest {
    return ValidateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateRequest>, I>>(_: I): ValidateRequest {
    const message = createBaseValidateRequest();
    return message;
  },
};

function createBaseValidateResponse(): ValidateResponse {
  return {};
}

export const ValidateResponse: MessageFns<ValidateResponse> = {
  encode(_: ValidateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ValidateResponse {
    return {};
  },

  toJSON(_: ValidateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateResponse>, I>>(base?: I): ValidateResponse {
    return ValidateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateResponse>, I>>(_: I): ValidateResponse {
    const message = createBaseValidateResponse();
    return message;
  },
};

function createBaseSetBaseNodeRequest(): SetBaseNodeRequest {
  return { publicKeyHex: "", netAddress: "" };
}

export const SetBaseNodeRequest: MessageFns<SetBaseNodeRequest> = {
  encode(message: SetBaseNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKeyHex !== "") {
      writer.uint32(10).string(message.publicKeyHex);
    }
    if (message.netAddress !== "") {
      writer.uint32(18).string(message.netAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetBaseNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetBaseNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKeyHex = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.netAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetBaseNodeRequest {
    return {
      publicKeyHex: isSet(object.publicKeyHex) ? globalThis.String(object.publicKeyHex) : "",
      netAddress: isSet(object.netAddress) ? globalThis.String(object.netAddress) : "",
    };
  },

  toJSON(message: SetBaseNodeRequest): unknown {
    const obj: any = {};
    if (message.publicKeyHex !== "") {
      obj.publicKeyHex = message.publicKeyHex;
    }
    if (message.netAddress !== "") {
      obj.netAddress = message.netAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetBaseNodeRequest>, I>>(base?: I): SetBaseNodeRequest {
    return SetBaseNodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetBaseNodeRequest>, I>>(object: I): SetBaseNodeRequest {
    const message = createBaseSetBaseNodeRequest();
    message.publicKeyHex = object.publicKeyHex ?? "";
    message.netAddress = object.netAddress ?? "";
    return message;
  },
};

function createBaseSetBaseNodeResponse(): SetBaseNodeResponse {
  return {};
}

export const SetBaseNodeResponse: MessageFns<SetBaseNodeResponse> = {
  encode(_: SetBaseNodeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetBaseNodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetBaseNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SetBaseNodeResponse {
    return {};
  },

  toJSON(_: SetBaseNodeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SetBaseNodeResponse>, I>>(base?: I): SetBaseNodeResponse {
    return SetBaseNodeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetBaseNodeResponse>, I>>(_: I): SetBaseNodeResponse {
    const message = createBaseSetBaseNodeResponse();
    return message;
  },
};

function createBaseGetConnectivityRequest(): GetConnectivityRequest {
  return {};
}

export const GetConnectivityRequest: MessageFns<GetConnectivityRequest> = {
  encode(_: GetConnectivityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectivityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectivityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetConnectivityRequest {
    return {};
  },

  toJSON(_: GetConnectivityRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConnectivityRequest>, I>>(base?: I): GetConnectivityRequest {
    return GetConnectivityRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConnectivityRequest>, I>>(_: I): GetConnectivityRequest {
    const message = createBaseGetConnectivityRequest();
    return message;
  },
};

function createBaseCheckConnectivityResponse(): CheckConnectivityResponse {
  return { status: 0 };
}

export const CheckConnectivityResponse: MessageFns<CheckConnectivityResponse> = {
  encode(message: CheckConnectivityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckConnectivityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckConnectivityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckConnectivityResponse {
    return { status: isSet(object.status) ? checkConnectivityResponse_OnlineStatusFromJSON(object.status) : 0 };
  },

  toJSON(message: CheckConnectivityResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = checkConnectivityResponse_OnlineStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckConnectivityResponse>, I>>(base?: I): CheckConnectivityResponse {
    return CheckConnectivityResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckConnectivityResponse>, I>>(object: I): CheckConnectivityResponse {
    const message = createBaseCheckConnectivityResponse();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseTransactionEventRequest(): TransactionEventRequest {
  return {};
}

export const TransactionEventRequest: MessageFns<TransactionEventRequest> = {
  encode(_: TransactionEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TransactionEventRequest {
    return {};
  },

  toJSON(_: TransactionEventRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionEventRequest>, I>>(base?: I): TransactionEventRequest {
    return TransactionEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionEventRequest>, I>>(_: I): TransactionEventRequest {
    const message = createBaseTransactionEventRequest();
    return message;
  },
};

function createBaseTransactionEvent(): TransactionEvent {
  return {
    event: "",
    txId: "",
    sourceAddress: new Uint8Array(0),
    destAddress: new Uint8Array(0),
    status: "",
    direction: "",
    amount: Long.UZERO,
    paymentId: new Uint8Array(0),
  };
}

export const TransactionEvent: MessageFns<TransactionEvent> = {
  encode(message: TransactionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== "") {
      writer.uint32(10).string(message.event);
    }
    if (message.txId !== "") {
      writer.uint32(18).string(message.txId);
    }
    if (message.sourceAddress.length !== 0) {
      writer.uint32(26).bytes(message.sourceAddress);
    }
    if (message.destAddress.length !== 0) {
      writer.uint32(34).bytes(message.destAddress);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.direction !== "") {
      writer.uint32(50).string(message.direction);
    }
    if (!message.amount.equals(Long.UZERO)) {
      writer.uint32(56).uint64(message.amount.toString());
    }
    if (message.paymentId.length !== 0) {
      writer.uint32(74).bytes(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destAddress = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.direction = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.amount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.paymentId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEvent {
    return {
      event: isSet(object.event) ? globalThis.String(object.event) : "",
      txId: isSet(object.txId) ? globalThis.String(object.txId) : "",
      sourceAddress: isSet(object.sourceAddress) ? bytesFromBase64(object.sourceAddress) : new Uint8Array(0),
      destAddress: isSet(object.destAddress) ? bytesFromBase64(object.destAddress) : new Uint8Array(0),
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      direction: isSet(object.direction) ? globalThis.String(object.direction) : "",
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.UZERO,
      paymentId: isSet(object.paymentId) ? bytesFromBase64(object.paymentId) : new Uint8Array(0),
    };
  },

  toJSON(message: TransactionEvent): unknown {
    const obj: any = {};
    if (message.event !== "") {
      obj.event = message.event;
    }
    if (message.txId !== "") {
      obj.txId = message.txId;
    }
    if (message.sourceAddress.length !== 0) {
      obj.sourceAddress = base64FromBytes(message.sourceAddress);
    }
    if (message.destAddress.length !== 0) {
      obj.destAddress = base64FromBytes(message.destAddress);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.direction !== "") {
      obj.direction = message.direction;
    }
    if (!message.amount.equals(Long.UZERO)) {
      obj.amount = (message.amount || Long.UZERO).toString();
    }
    if (message.paymentId.length !== 0) {
      obj.paymentId = base64FromBytes(message.paymentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionEvent>, I>>(base?: I): TransactionEvent {
    return TransactionEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionEvent>, I>>(object: I): TransactionEvent {
    const message = createBaseTransactionEvent();
    message.event = object.event ?? "";
    message.txId = object.txId ?? "";
    message.sourceAddress = object.sourceAddress ?? new Uint8Array(0);
    message.destAddress = object.destAddress ?? new Uint8Array(0);
    message.status = object.status ?? "";
    message.direction = object.direction ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.UZERO;
    message.paymentId = object.paymentId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransactionEventResponse(): TransactionEventResponse {
  return { transaction: undefined };
}

export const TransactionEventResponse: MessageFns<TransactionEventResponse> = {
  encode(message: TransactionEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      TransactionEvent.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = TransactionEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEventResponse {
    return { transaction: isSet(object.transaction) ? TransactionEvent.fromJSON(object.transaction) : undefined };
  },

  toJSON(message: TransactionEventResponse): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = TransactionEvent.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionEventResponse>, I>>(base?: I): TransactionEventResponse {
    return TransactionEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionEventResponse>, I>>(object: I): TransactionEventResponse {
    const message = createBaseTransactionEventResponse();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? TransactionEvent.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseRegisterValidatorNodeRequest(): RegisterValidatorNodeRequest {
  return {
    validatorNodePublicKey: new Uint8Array(0),
    validatorNodeSignature: undefined,
    feePerGram: Long.UZERO,
    paymentId: new Uint8Array(0),
  };
}

export const RegisterValidatorNodeRequest: MessageFns<RegisterValidatorNodeRequest> = {
  encode(message: RegisterValidatorNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorNodePublicKey.length !== 0) {
      writer.uint32(10).bytes(message.validatorNodePublicKey);
    }
    if (message.validatorNodeSignature !== undefined) {
      Signature.encode(message.validatorNodeSignature, writer.uint32(18).fork()).join();
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.feePerGram.toString());
    }
    if (message.paymentId.length !== 0) {
      writer.uint32(42).bytes(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterValidatorNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterValidatorNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorNodePublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validatorNodeSignature = Signature.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterValidatorNodeRequest {
    return {
      validatorNodePublicKey: isSet(object.validatorNodePublicKey)
        ? bytesFromBase64(object.validatorNodePublicKey)
        : new Uint8Array(0),
      validatorNodeSignature: isSet(object.validatorNodeSignature)
        ? Signature.fromJSON(object.validatorNodeSignature)
        : undefined,
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
      paymentId: isSet(object.paymentId) ? bytesFromBase64(object.paymentId) : new Uint8Array(0),
    };
  },

  toJSON(message: RegisterValidatorNodeRequest): unknown {
    const obj: any = {};
    if (message.validatorNodePublicKey.length !== 0) {
      obj.validatorNodePublicKey = base64FromBytes(message.validatorNodePublicKey);
    }
    if (message.validatorNodeSignature !== undefined) {
      obj.validatorNodeSignature = Signature.toJSON(message.validatorNodeSignature);
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    if (message.paymentId.length !== 0) {
      obj.paymentId = base64FromBytes(message.paymentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterValidatorNodeRequest>, I>>(base?: I): RegisterValidatorNodeRequest {
    return RegisterValidatorNodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterValidatorNodeRequest>, I>>(object: I): RegisterValidatorNodeRequest {
    const message = createBaseRegisterValidatorNodeRequest();
    message.validatorNodePublicKey = object.validatorNodePublicKey ?? new Uint8Array(0);
    message.validatorNodeSignature =
      (object.validatorNodeSignature !== undefined && object.validatorNodeSignature !== null)
        ? Signature.fromPartial(object.validatorNodeSignature)
        : undefined;
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    message.paymentId = object.paymentId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRegisterValidatorNodeResponse(): RegisterValidatorNodeResponse {
  return { transactionId: Long.UZERO, isSuccess: false, failureMessage: "" };
}

export const RegisterValidatorNodeResponse: MessageFns<RegisterValidatorNodeResponse> = {
  encode(message: RegisterValidatorNodeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.transactionId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.transactionId.toString());
    }
    if (message.isSuccess !== false) {
      writer.uint32(16).bool(message.isSuccess);
    }
    if (message.failureMessage !== "") {
      writer.uint32(26).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterValidatorNodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterValidatorNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterValidatorNodeResponse {
    return {
      transactionId: isSet(object.transactionId) ? Long.fromValue(object.transactionId) : Long.UZERO,
      isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: RegisterValidatorNodeResponse): unknown {
    const obj: any = {};
    if (!message.transactionId.equals(Long.UZERO)) {
      obj.transactionId = (message.transactionId || Long.UZERO).toString();
    }
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterValidatorNodeResponse>, I>>(base?: I): RegisterValidatorNodeResponse {
    return RegisterValidatorNodeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterValidatorNodeResponse>, I>>(
    object: I,
  ): RegisterValidatorNodeResponse {
    const message = createBaseRegisterValidatorNodeResponse();
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? Long.fromValue(object.transactionId)
      : Long.UZERO;
    message.isSuccess = object.isSuccess ?? false;
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

/** The gRPC interface for interacting with the wallet. */
export type WalletService = typeof WalletService;
export const WalletService = {
  /** This returns the current version */
  getVersion: {
    path: "/tari.rpc.Wallet/GetVersion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetVersionRequest) => Buffer.from(GetVersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetVersionRequest.decode(value),
    responseSerialize: (value: GetVersionResponse) => Buffer.from(GetVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetVersionResponse.decode(value),
  },
  /** This returns the current state of the wallet */
  getState: {
    path: "/tari.rpc.Wallet/GetState",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStateRequest) => Buffer.from(GetStateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetStateRequest.decode(value),
    responseSerialize: (value: GetStateResponse) => Buffer.from(GetStateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetStateResponse.decode(value),
  },
  /** This checks if the wallet is healthy and running */
  checkConnectivity: {
    path: "/tari.rpc.Wallet/CheckConnectivity",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetConnectivityRequest) => Buffer.from(GetConnectivityRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetConnectivityRequest.decode(value),
    responseSerialize: (value: CheckConnectivityResponse) =>
      Buffer.from(CheckConnectivityResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CheckConnectivityResponse.decode(value),
  },
  /** Check for new updates */
  checkForUpdates: {
    path: "/tari.rpc.Wallet/CheckForUpdates",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: SoftwareUpdate) => Buffer.from(SoftwareUpdate.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SoftwareUpdate.decode(value),
  },
  /** This returns the identity information */
  identify: {
    path: "/tari.rpc.Wallet/Identify",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetIdentityRequest) => Buffer.from(GetIdentityRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetIdentityRequest.decode(value),
    responseSerialize: (value: GetIdentityResponse) => Buffer.from(GetIdentityResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetIdentityResponse.decode(value),
  },
  /** This returns the tari address */
  getAddress: {
    path: "/tari.rpc.Wallet/GetAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetAddressResponse) => Buffer.from(GetAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAddressResponse.decode(value),
  },
  /** Returns the address in multiple formats (binary, base58, and emoji) */
  getCompleteAddress: {
    path: "/tari.rpc.Wallet/GetCompleteAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetCompleteAddressResponse) =>
      Buffer.from(GetCompleteAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetCompleteAddressResponse.decode(value),
  },
  /** Send Minotari to a number of recipients */
  transfer: {
    path: "/tari.rpc.Wallet/Transfer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TransferRequest) => Buffer.from(TransferRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TransferRequest.decode(value),
    responseSerialize: (value: TransferResponse) => Buffer.from(TransferResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransferResponse.decode(value),
  },
  /** Returns the transaction details for the given transaction IDs */
  getTransactionInfo: {
    path: "/tari.rpc.Wallet/GetTransactionInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTransactionInfoRequest) =>
      Buffer.from(GetTransactionInfoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTransactionInfoRequest.decode(value),
    responseSerialize: (value: GetTransactionInfoResponse) =>
      Buffer.from(GetTransactionInfoResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTransactionInfoResponse.decode(value),
  },
  /** Returns all transactions' details */
  getCompletedTransactions: {
    path: "/tari.rpc.Wallet/GetCompletedTransactions",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: GetCompletedTransactionsRequest) =>
      Buffer.from(GetCompletedTransactionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetCompletedTransactionsRequest.decode(value),
    responseSerialize: (value: GetCompletedTransactionsResponse) =>
      Buffer.from(GetCompletedTransactionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetCompletedTransactionsResponse.decode(value),
  },
  /** Returns the balance, but uses a debouncer in the background to prevent spamming the wallet */
  getBalance: {
    path: "/tari.rpc.Wallet/GetBalance",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBalanceRequest) => Buffer.from(GetBalanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetBalanceRequest.decode(value),
    responseSerialize: (value: GetBalanceResponse) => Buffer.from(GetBalanceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetBalanceResponse.decode(value),
  },
  /** Returns unspent amounts */
  getUnspentAmounts: {
    path: "/tari.rpc.Wallet/GetUnspentAmounts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetUnspentAmountsResponse) =>
      Buffer.from(GetUnspentAmountsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUnspentAmountsResponse.decode(value),
  },
  /** Request the wallet perform a coinsplit */
  coinSplit: {
    path: "/tari.rpc.Wallet/CoinSplit",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CoinSplitRequest) => Buffer.from(CoinSplitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CoinSplitRequest.decode(value),
    responseSerialize: (value: CoinSplitResponse) => Buffer.from(CoinSplitResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CoinSplitResponse.decode(value),
  },
  /** Import Utxo to wallet */
  importUtxos: {
    path: "/tari.rpc.Wallet/ImportUtxos",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ImportUtxosRequest) => Buffer.from(ImportUtxosRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ImportUtxosRequest.decode(value),
    responseSerialize: (value: ImportUtxosResponse) => Buffer.from(ImportUtxosResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ImportUtxosResponse.decode(value),
  },
  /** Get Base Node network connectivity status */
  getNetworkStatus: {
    path: "/tari.rpc.Wallet/GetNetworkStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: NetworkStatusResponse) => Buffer.from(NetworkStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NetworkStatusResponse.decode(value),
  },
  /** List currently connected peers */
  listConnectedPeers: {
    path: "/tari.rpc.Wallet/ListConnectedPeers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: ListConnectedPeersResponse) =>
      Buffer.from(ListConnectedPeersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListConnectedPeersResponse.decode(value),
  },
  /** Cancel pending transaction */
  cancelTransaction: {
    path: "/tari.rpc.Wallet/CancelTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelTransactionRequest) => Buffer.from(CancelTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CancelTransactionRequest.decode(value),
    responseSerialize: (value: CancelTransactionResponse) =>
      Buffer.from(CancelTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CancelTransactionResponse.decode(value),
  },
  /** Will trigger a complete revalidation of all wallet outputs. */
  revalidateAllTransactions: {
    path: "/tari.rpc.Wallet/RevalidateAllTransactions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RevalidateRequest) => Buffer.from(RevalidateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RevalidateRequest.decode(value),
    responseSerialize: (value: RevalidateResponse) => Buffer.from(RevalidateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RevalidateResponse.decode(value),
  },
  /** Will trigger a validation of all wallet outputs. */
  validateAllTransactions: {
    path: "/tari.rpc.Wallet/ValidateAllTransactions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateRequest) => Buffer.from(ValidateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ValidateRequest.decode(value),
    responseSerialize: (value: ValidateResponse) => Buffer.from(ValidateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ValidateResponse.decode(value),
  },
  /** This will send a XTR SHA Atomic swap transaction */
  sendShaAtomicSwapTransaction: {
    path: "/tari.rpc.Wallet/SendShaAtomicSwapTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendShaAtomicSwapRequest) => Buffer.from(SendShaAtomicSwapRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendShaAtomicSwapRequest.decode(value),
    responseSerialize: (value: SendShaAtomicSwapResponse) =>
      Buffer.from(SendShaAtomicSwapResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SendShaAtomicSwapResponse.decode(value),
  },
  /** This will create a burn transaction */
  createBurnTransaction: {
    path: "/tari.rpc.Wallet/CreateBurnTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateBurnTransactionRequest) =>
      Buffer.from(CreateBurnTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateBurnTransactionRequest.decode(value),
    responseSerialize: (value: CreateBurnTransactionResponse) =>
      Buffer.from(CreateBurnTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateBurnTransactionResponse.decode(value),
  },
  /** This will claim a XTR SHA Atomic swap transaction */
  claimShaAtomicSwapTransaction: {
    path: "/tari.rpc.Wallet/ClaimShaAtomicSwapTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ClaimShaAtomicSwapRequest) =>
      Buffer.from(ClaimShaAtomicSwapRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ClaimShaAtomicSwapRequest.decode(value),
    responseSerialize: (value: ClaimShaAtomicSwapResponse) =>
      Buffer.from(ClaimShaAtomicSwapResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ClaimShaAtomicSwapResponse.decode(value),
  },
  /** This will claim a HTLC refund transaction */
  claimHtlcRefundTransaction: {
    path: "/tari.rpc.Wallet/ClaimHtlcRefundTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ClaimHtlcRefundRequest) => Buffer.from(ClaimHtlcRefundRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ClaimHtlcRefundRequest.decode(value),
    responseSerialize: (value: ClaimHtlcRefundResponse) => Buffer.from(ClaimHtlcRefundResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ClaimHtlcRefundResponse.decode(value),
  },
  /** Creates a transaction with a template registration output */
  createTemplateRegistration: {
    path: "/tari.rpc.Wallet/CreateTemplateRegistration",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateTemplateRegistrationRequest) =>
      Buffer.from(CreateTemplateRegistrationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateTemplateRegistrationRequest.decode(value),
    responseSerialize: (value: CreateTemplateRegistrationResponse) =>
      Buffer.from(CreateTemplateRegistrationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateTemplateRegistrationResponse.decode(value),
  },
  setBaseNode: {
    path: "/tari.rpc.Wallet/SetBaseNode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetBaseNodeRequest) => Buffer.from(SetBaseNodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SetBaseNodeRequest.decode(value),
    responseSerialize: (value: SetBaseNodeResponse) => Buffer.from(SetBaseNodeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SetBaseNodeResponse.decode(value),
  },
  streamTransactionEvents: {
    path: "/tari.rpc.Wallet/StreamTransactionEvents",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: TransactionEventRequest) => Buffer.from(TransactionEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TransactionEventRequest.decode(value),
    responseSerialize: (value: TransactionEventResponse) =>
      Buffer.from(TransactionEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionEventResponse.decode(value),
  },
  registerValidatorNode: {
    path: "/tari.rpc.Wallet/RegisterValidatorNode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegisterValidatorNodeRequest) =>
      Buffer.from(RegisterValidatorNodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RegisterValidatorNodeRequest.decode(value),
    responseSerialize: (value: RegisterValidatorNodeResponse) =>
      Buffer.from(RegisterValidatorNodeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RegisterValidatorNodeResponse.decode(value),
  },
} as const;

export interface WalletServer extends UntypedServiceImplementation {
  /** This returns the current version */
  getVersion: handleUnaryCall<GetVersionRequest, GetVersionResponse>;
  /** This returns the current state of the wallet */
  getState: handleUnaryCall<GetStateRequest, GetStateResponse>;
  /** This checks if the wallet is healthy and running */
  checkConnectivity: handleUnaryCall<GetConnectivityRequest, CheckConnectivityResponse>;
  /** Check for new updates */
  checkForUpdates: handleUnaryCall<Empty, SoftwareUpdate>;
  /** This returns the identity information */
  identify: handleUnaryCall<GetIdentityRequest, GetIdentityResponse>;
  /** This returns the tari address */
  getAddress: handleUnaryCall<Empty, GetAddressResponse>;
  /** Returns the address in multiple formats (binary, base58, and emoji) */
  getCompleteAddress: handleUnaryCall<Empty, GetCompleteAddressResponse>;
  /** Send Minotari to a number of recipients */
  transfer: handleUnaryCall<TransferRequest, TransferResponse>;
  /** Returns the transaction details for the given transaction IDs */
  getTransactionInfo: handleUnaryCall<GetTransactionInfoRequest, GetTransactionInfoResponse>;
  /** Returns all transactions' details */
  getCompletedTransactions: handleServerStreamingCall<
    GetCompletedTransactionsRequest,
    GetCompletedTransactionsResponse
  >;
  /** Returns the balance, but uses a debouncer in the background to prevent spamming the wallet */
  getBalance: handleUnaryCall<GetBalanceRequest, GetBalanceResponse>;
  /** Returns unspent amounts */
  getUnspentAmounts: handleUnaryCall<Empty, GetUnspentAmountsResponse>;
  /** Request the wallet perform a coinsplit */
  coinSplit: handleUnaryCall<CoinSplitRequest, CoinSplitResponse>;
  /** Import Utxo to wallet */
  importUtxos: handleUnaryCall<ImportUtxosRequest, ImportUtxosResponse>;
  /** Get Base Node network connectivity status */
  getNetworkStatus: handleUnaryCall<Empty, NetworkStatusResponse>;
  /** List currently connected peers */
  listConnectedPeers: handleUnaryCall<Empty, ListConnectedPeersResponse>;
  /** Cancel pending transaction */
  cancelTransaction: handleUnaryCall<CancelTransactionRequest, CancelTransactionResponse>;
  /** Will trigger a complete revalidation of all wallet outputs. */
  revalidateAllTransactions: handleUnaryCall<RevalidateRequest, RevalidateResponse>;
  /** Will trigger a validation of all wallet outputs. */
  validateAllTransactions: handleUnaryCall<ValidateRequest, ValidateResponse>;
  /** This will send a XTR SHA Atomic swap transaction */
  sendShaAtomicSwapTransaction: handleUnaryCall<SendShaAtomicSwapRequest, SendShaAtomicSwapResponse>;
  /** This will create a burn transaction */
  createBurnTransaction: handleUnaryCall<CreateBurnTransactionRequest, CreateBurnTransactionResponse>;
  /** This will claim a XTR SHA Atomic swap transaction */
  claimShaAtomicSwapTransaction: handleUnaryCall<ClaimShaAtomicSwapRequest, ClaimShaAtomicSwapResponse>;
  /** This will claim a HTLC refund transaction */
  claimHtlcRefundTransaction: handleUnaryCall<ClaimHtlcRefundRequest, ClaimHtlcRefundResponse>;
  /** Creates a transaction with a template registration output */
  createTemplateRegistration: handleUnaryCall<CreateTemplateRegistrationRequest, CreateTemplateRegistrationResponse>;
  setBaseNode: handleUnaryCall<SetBaseNodeRequest, SetBaseNodeResponse>;
  streamTransactionEvents: handleServerStreamingCall<TransactionEventRequest, TransactionEventResponse>;
  registerValidatorNode: handleUnaryCall<RegisterValidatorNodeRequest, RegisterValidatorNodeResponse>;
}

export interface WalletClient extends Client {
  /** This returns the current version */
  getVersion(
    request: GetVersionRequest,
    callback: (error: ServiceError | null, response: GetVersionResponse) => void,
  ): ClientUnaryCall;
  getVersion(
    request: GetVersionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetVersionResponse) => void,
  ): ClientUnaryCall;
  getVersion(
    request: GetVersionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetVersionResponse) => void,
  ): ClientUnaryCall;
  /** This returns the current state of the wallet */
  getState(
    request: GetStateRequest,
    callback: (error: ServiceError | null, response: GetStateResponse) => void,
  ): ClientUnaryCall;
  getState(
    request: GetStateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetStateResponse) => void,
  ): ClientUnaryCall;
  getState(
    request: GetStateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetStateResponse) => void,
  ): ClientUnaryCall;
  /** This checks if the wallet is healthy and running */
  checkConnectivity(
    request: GetConnectivityRequest,
    callback: (error: ServiceError | null, response: CheckConnectivityResponse) => void,
  ): ClientUnaryCall;
  checkConnectivity(
    request: GetConnectivityRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CheckConnectivityResponse) => void,
  ): ClientUnaryCall;
  checkConnectivity(
    request: GetConnectivityRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CheckConnectivityResponse) => void,
  ): ClientUnaryCall;
  /** Check for new updates */
  checkForUpdates(
    request: Empty,
    callback: (error: ServiceError | null, response: SoftwareUpdate) => void,
  ): ClientUnaryCall;
  checkForUpdates(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SoftwareUpdate) => void,
  ): ClientUnaryCall;
  checkForUpdates(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SoftwareUpdate) => void,
  ): ClientUnaryCall;
  /** This returns the identity information */
  identify(
    request: GetIdentityRequest,
    callback: (error: ServiceError | null, response: GetIdentityResponse) => void,
  ): ClientUnaryCall;
  identify(
    request: GetIdentityRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetIdentityResponse) => void,
  ): ClientUnaryCall;
  identify(
    request: GetIdentityRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetIdentityResponse) => void,
  ): ClientUnaryCall;
  /** This returns the tari address */
  getAddress(
    request: Empty,
    callback: (error: ServiceError | null, response: GetAddressResponse) => void,
  ): ClientUnaryCall;
  getAddress(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAddressResponse) => void,
  ): ClientUnaryCall;
  getAddress(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAddressResponse) => void,
  ): ClientUnaryCall;
  /** Returns the address in multiple formats (binary, base58, and emoji) */
  getCompleteAddress(
    request: Empty,
    callback: (error: ServiceError | null, response: GetCompleteAddressResponse) => void,
  ): ClientUnaryCall;
  getCompleteAddress(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetCompleteAddressResponse) => void,
  ): ClientUnaryCall;
  getCompleteAddress(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetCompleteAddressResponse) => void,
  ): ClientUnaryCall;
  /** Send Minotari to a number of recipients */
  transfer(
    request: TransferRequest,
    callback: (error: ServiceError | null, response: TransferResponse) => void,
  ): ClientUnaryCall;
  transfer(
    request: TransferRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransferResponse) => void,
  ): ClientUnaryCall;
  transfer(
    request: TransferRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransferResponse) => void,
  ): ClientUnaryCall;
  /** Returns the transaction details for the given transaction IDs */
  getTransactionInfo(
    request: GetTransactionInfoRequest,
    callback: (error: ServiceError | null, response: GetTransactionInfoResponse) => void,
  ): ClientUnaryCall;
  getTransactionInfo(
    request: GetTransactionInfoRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTransactionInfoResponse) => void,
  ): ClientUnaryCall;
  getTransactionInfo(
    request: GetTransactionInfoRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTransactionInfoResponse) => void,
  ): ClientUnaryCall;
  /** Returns all transactions' details */
  getCompletedTransactions(
    request: GetCompletedTransactionsRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetCompletedTransactionsResponse>;
  getCompletedTransactions(
    request: GetCompletedTransactionsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetCompletedTransactionsResponse>;
  /** Returns the balance, but uses a debouncer in the background to prevent spamming the wallet */
  getBalance(
    request: GetBalanceRequest,
    callback: (error: ServiceError | null, response: GetBalanceResponse) => void,
  ): ClientUnaryCall;
  getBalance(
    request: GetBalanceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBalanceResponse) => void,
  ): ClientUnaryCall;
  getBalance(
    request: GetBalanceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBalanceResponse) => void,
  ): ClientUnaryCall;
  /** Returns unspent amounts */
  getUnspentAmounts(
    request: Empty,
    callback: (error: ServiceError | null, response: GetUnspentAmountsResponse) => void,
  ): ClientUnaryCall;
  getUnspentAmounts(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetUnspentAmountsResponse) => void,
  ): ClientUnaryCall;
  getUnspentAmounts(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetUnspentAmountsResponse) => void,
  ): ClientUnaryCall;
  /** Request the wallet perform a coinsplit */
  coinSplit(
    request: CoinSplitRequest,
    callback: (error: ServiceError | null, response: CoinSplitResponse) => void,
  ): ClientUnaryCall;
  coinSplit(
    request: CoinSplitRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CoinSplitResponse) => void,
  ): ClientUnaryCall;
  coinSplit(
    request: CoinSplitRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CoinSplitResponse) => void,
  ): ClientUnaryCall;
  /** Import Utxo to wallet */
  importUtxos(
    request: ImportUtxosRequest,
    callback: (error: ServiceError | null, response: ImportUtxosResponse) => void,
  ): ClientUnaryCall;
  importUtxos(
    request: ImportUtxosRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ImportUtxosResponse) => void,
  ): ClientUnaryCall;
  importUtxos(
    request: ImportUtxosRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ImportUtxosResponse) => void,
  ): ClientUnaryCall;
  /** Get Base Node network connectivity status */
  getNetworkStatus(
    request: Empty,
    callback: (error: ServiceError | null, response: NetworkStatusResponse) => void,
  ): ClientUnaryCall;
  getNetworkStatus(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NetworkStatusResponse) => void,
  ): ClientUnaryCall;
  getNetworkStatus(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NetworkStatusResponse) => void,
  ): ClientUnaryCall;
  /** List currently connected peers */
  listConnectedPeers(
    request: Empty,
    callback: (error: ServiceError | null, response: ListConnectedPeersResponse) => void,
  ): ClientUnaryCall;
  listConnectedPeers(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListConnectedPeersResponse) => void,
  ): ClientUnaryCall;
  listConnectedPeers(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListConnectedPeersResponse) => void,
  ): ClientUnaryCall;
  /** Cancel pending transaction */
  cancelTransaction(
    request: CancelTransactionRequest,
    callback: (error: ServiceError | null, response: CancelTransactionResponse) => void,
  ): ClientUnaryCall;
  cancelTransaction(
    request: CancelTransactionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CancelTransactionResponse) => void,
  ): ClientUnaryCall;
  cancelTransaction(
    request: CancelTransactionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CancelTransactionResponse) => void,
  ): ClientUnaryCall;
  /** Will trigger a complete revalidation of all wallet outputs. */
  revalidateAllTransactions(
    request: RevalidateRequest,
    callback: (error: ServiceError | null, response: RevalidateResponse) => void,
  ): ClientUnaryCall;
  revalidateAllTransactions(
    request: RevalidateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RevalidateResponse) => void,
  ): ClientUnaryCall;
  revalidateAllTransactions(
    request: RevalidateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RevalidateResponse) => void,
  ): ClientUnaryCall;
  /** Will trigger a validation of all wallet outputs. */
  validateAllTransactions(
    request: ValidateRequest,
    callback: (error: ServiceError | null, response: ValidateResponse) => void,
  ): ClientUnaryCall;
  validateAllTransactions(
    request: ValidateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ValidateResponse) => void,
  ): ClientUnaryCall;
  validateAllTransactions(
    request: ValidateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ValidateResponse) => void,
  ): ClientUnaryCall;
  /** This will send a XTR SHA Atomic swap transaction */
  sendShaAtomicSwapTransaction(
    request: SendShaAtomicSwapRequest,
    callback: (error: ServiceError | null, response: SendShaAtomicSwapResponse) => void,
  ): ClientUnaryCall;
  sendShaAtomicSwapTransaction(
    request: SendShaAtomicSwapRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SendShaAtomicSwapResponse) => void,
  ): ClientUnaryCall;
  sendShaAtomicSwapTransaction(
    request: SendShaAtomicSwapRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SendShaAtomicSwapResponse) => void,
  ): ClientUnaryCall;
  /** This will create a burn transaction */
  createBurnTransaction(
    request: CreateBurnTransactionRequest,
    callback: (error: ServiceError | null, response: CreateBurnTransactionResponse) => void,
  ): ClientUnaryCall;
  createBurnTransaction(
    request: CreateBurnTransactionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateBurnTransactionResponse) => void,
  ): ClientUnaryCall;
  createBurnTransaction(
    request: CreateBurnTransactionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateBurnTransactionResponse) => void,
  ): ClientUnaryCall;
  /** This will claim a XTR SHA Atomic swap transaction */
  claimShaAtomicSwapTransaction(
    request: ClaimShaAtomicSwapRequest,
    callback: (error: ServiceError | null, response: ClaimShaAtomicSwapResponse) => void,
  ): ClientUnaryCall;
  claimShaAtomicSwapTransaction(
    request: ClaimShaAtomicSwapRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ClaimShaAtomicSwapResponse) => void,
  ): ClientUnaryCall;
  claimShaAtomicSwapTransaction(
    request: ClaimShaAtomicSwapRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ClaimShaAtomicSwapResponse) => void,
  ): ClientUnaryCall;
  /** This will claim a HTLC refund transaction */
  claimHtlcRefundTransaction(
    request: ClaimHtlcRefundRequest,
    callback: (error: ServiceError | null, response: ClaimHtlcRefundResponse) => void,
  ): ClientUnaryCall;
  claimHtlcRefundTransaction(
    request: ClaimHtlcRefundRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ClaimHtlcRefundResponse) => void,
  ): ClientUnaryCall;
  claimHtlcRefundTransaction(
    request: ClaimHtlcRefundRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ClaimHtlcRefundResponse) => void,
  ): ClientUnaryCall;
  /** Creates a transaction with a template registration output */
  createTemplateRegistration(
    request: CreateTemplateRegistrationRequest,
    callback: (error: ServiceError | null, response: CreateTemplateRegistrationResponse) => void,
  ): ClientUnaryCall;
  createTemplateRegistration(
    request: CreateTemplateRegistrationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateTemplateRegistrationResponse) => void,
  ): ClientUnaryCall;
  createTemplateRegistration(
    request: CreateTemplateRegistrationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateTemplateRegistrationResponse) => void,
  ): ClientUnaryCall;
  setBaseNode(
    request: SetBaseNodeRequest,
    callback: (error: ServiceError | null, response: SetBaseNodeResponse) => void,
  ): ClientUnaryCall;
  setBaseNode(
    request: SetBaseNodeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SetBaseNodeResponse) => void,
  ): ClientUnaryCall;
  setBaseNode(
    request: SetBaseNodeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SetBaseNodeResponse) => void,
  ): ClientUnaryCall;
  streamTransactionEvents(
    request: TransactionEventRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<TransactionEventResponse>;
  streamTransactionEvents(
    request: TransactionEventRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<TransactionEventResponse>;
  registerValidatorNode(
    request: RegisterValidatorNodeRequest,
    callback: (error: ServiceError | null, response: RegisterValidatorNodeResponse) => void,
  ): ClientUnaryCall;
  registerValidatorNode(
    request: RegisterValidatorNodeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RegisterValidatorNodeResponse) => void,
  ): ClientUnaryCall;
  registerValidatorNode(
    request: RegisterValidatorNodeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RegisterValidatorNodeResponse) => void,
  ): ClientUnaryCall;
}

export const WalletClient = makeGenericClientConstructor(WalletService, "tari.rpc.Wallet") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): WalletClient;
  service: typeof WalletService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
