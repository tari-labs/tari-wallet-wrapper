// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: wallet.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import {
  GetIdentityRequest,
  GetIdentityResponse,
  ListConnectedPeersResponse,
  NetworkStatusResponse,
  SoftwareUpdate,
} from "./network";
import { BuildInfo, EvictionProof, TemplateType } from "./sidechain_types";
import { UnblindedOutput } from "./transaction";
import { BlockHeight, CommitmentSignature, Empty, Signature } from "./types";

export const protobufPackage = "tari.rpc";

/**
 * Copyright 2020. The Tari Project
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 * disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

export enum TransactionDirection {
  TRANSACTION_DIRECTION_UNKNOWN = 0,
  TRANSACTION_DIRECTION_INBOUND = 1,
  TRANSACTION_DIRECTION_OUTBOUND = 2,
  UNRECOGNIZED = -1,
}

export function transactionDirectionFromJSON(object: any): TransactionDirection {
  switch (object) {
    case 0:
    case "TRANSACTION_DIRECTION_UNKNOWN":
      return TransactionDirection.TRANSACTION_DIRECTION_UNKNOWN;
    case 1:
    case "TRANSACTION_DIRECTION_INBOUND":
      return TransactionDirection.TRANSACTION_DIRECTION_INBOUND;
    case 2:
    case "TRANSACTION_DIRECTION_OUTBOUND":
      return TransactionDirection.TRANSACTION_DIRECTION_OUTBOUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionDirection.UNRECOGNIZED;
  }
}

export function transactionDirectionToJSON(object: TransactionDirection): string {
  switch (object) {
    case TransactionDirection.TRANSACTION_DIRECTION_UNKNOWN:
      return "TRANSACTION_DIRECTION_UNKNOWN";
    case TransactionDirection.TRANSACTION_DIRECTION_INBOUND:
      return "TRANSACTION_DIRECTION_INBOUND";
    case TransactionDirection.TRANSACTION_DIRECTION_OUTBOUND:
      return "TRANSACTION_DIRECTION_OUTBOUND";
    case TransactionDirection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransactionStatus {
  /** TRANSACTION_STATUS_COMPLETED - This transaction has been completed between the parties but has not been broadcast to the base layer network. */
  TRANSACTION_STATUS_COMPLETED = 0,
  /** TRANSACTION_STATUS_BROADCAST - This transaction has been broadcast to the base layer network and is currently in one or more base node mempools. */
  TRANSACTION_STATUS_BROADCAST = 1,
  /** TRANSACTION_STATUS_MINED_UNCONFIRMED - This transaction has been mined and included in a block. */
  TRANSACTION_STATUS_MINED_UNCONFIRMED = 2,
  /** TRANSACTION_STATUS_IMPORTED - This transaction was generated as part of importing a spendable UTXO */
  TRANSACTION_STATUS_IMPORTED = 3,
  /** TRANSACTION_STATUS_PENDING - This transaction is still being negotiated by the parties */
  TRANSACTION_STATUS_PENDING = 4,
  /** TRANSACTION_STATUS_COINBASE - This is a created Coinbase Transaction */
  TRANSACTION_STATUS_COINBASE = 5,
  /** TRANSACTION_STATUS_MINED_CONFIRMED - This transaction is mined and confirmed at the current base node's height */
  TRANSACTION_STATUS_MINED_CONFIRMED = 6,
  /** TRANSACTION_STATUS_REJECTED - The transaction was rejected by the mempool */
  TRANSACTION_STATUS_REJECTED = 7,
  /** TRANSACTION_STATUS_ONE_SIDED_UNCONFIRMED - This is faux transaction mainly for one-sided transaction outputs or wallet recovery outputs have been found */
  TRANSACTION_STATUS_ONE_SIDED_UNCONFIRMED = 8,
  /** TRANSACTION_STATUS_ONE_SIDED_CONFIRMED - All Imported and FauxUnconfirmed transactions will end up with this status when the outputs have been confirmed */
  TRANSACTION_STATUS_ONE_SIDED_CONFIRMED = 9,
  /** TRANSACTION_STATUS_QUEUED - This transaction is still being queued for sending */
  TRANSACTION_STATUS_QUEUED = 10,
  /** TRANSACTION_STATUS_NOT_FOUND - The transaction was not found by the wallet its in transaction database */
  TRANSACTION_STATUS_NOT_FOUND = 11,
  /** TRANSACTION_STATUS_COINBASE_UNCONFIRMED - This is Coinbase transaction that is detected from chain */
  TRANSACTION_STATUS_COINBASE_UNCONFIRMED = 12,
  /** TRANSACTION_STATUS_COINBASE_CONFIRMED - This is Coinbase transaction that is detected from chain */
  TRANSACTION_STATUS_COINBASE_CONFIRMED = 13,
  /** TRANSACTION_STATUS_COINBASE_NOT_IN_BLOCK_CHAIN - This is Coinbase transaction that is not currently detected as mined */
  TRANSACTION_STATUS_COINBASE_NOT_IN_BLOCK_CHAIN = 14,
  UNRECOGNIZED = -1,
}

export function transactionStatusFromJSON(object: any): TransactionStatus {
  switch (object) {
    case 0:
    case "TRANSACTION_STATUS_COMPLETED":
      return TransactionStatus.TRANSACTION_STATUS_COMPLETED;
    case 1:
    case "TRANSACTION_STATUS_BROADCAST":
      return TransactionStatus.TRANSACTION_STATUS_BROADCAST;
    case 2:
    case "TRANSACTION_STATUS_MINED_UNCONFIRMED":
      return TransactionStatus.TRANSACTION_STATUS_MINED_UNCONFIRMED;
    case 3:
    case "TRANSACTION_STATUS_IMPORTED":
      return TransactionStatus.TRANSACTION_STATUS_IMPORTED;
    case 4:
    case "TRANSACTION_STATUS_PENDING":
      return TransactionStatus.TRANSACTION_STATUS_PENDING;
    case 5:
    case "TRANSACTION_STATUS_COINBASE":
      return TransactionStatus.TRANSACTION_STATUS_COINBASE;
    case 6:
    case "TRANSACTION_STATUS_MINED_CONFIRMED":
      return TransactionStatus.TRANSACTION_STATUS_MINED_CONFIRMED;
    case 7:
    case "TRANSACTION_STATUS_REJECTED":
      return TransactionStatus.TRANSACTION_STATUS_REJECTED;
    case 8:
    case "TRANSACTION_STATUS_ONE_SIDED_UNCONFIRMED":
      return TransactionStatus.TRANSACTION_STATUS_ONE_SIDED_UNCONFIRMED;
    case 9:
    case "TRANSACTION_STATUS_ONE_SIDED_CONFIRMED":
      return TransactionStatus.TRANSACTION_STATUS_ONE_SIDED_CONFIRMED;
    case 10:
    case "TRANSACTION_STATUS_QUEUED":
      return TransactionStatus.TRANSACTION_STATUS_QUEUED;
    case 11:
    case "TRANSACTION_STATUS_NOT_FOUND":
      return TransactionStatus.TRANSACTION_STATUS_NOT_FOUND;
    case 12:
    case "TRANSACTION_STATUS_COINBASE_UNCONFIRMED":
      return TransactionStatus.TRANSACTION_STATUS_COINBASE_UNCONFIRMED;
    case 13:
    case "TRANSACTION_STATUS_COINBASE_CONFIRMED":
      return TransactionStatus.TRANSACTION_STATUS_COINBASE_CONFIRMED;
    case 14:
    case "TRANSACTION_STATUS_COINBASE_NOT_IN_BLOCK_CHAIN":
      return TransactionStatus.TRANSACTION_STATUS_COINBASE_NOT_IN_BLOCK_CHAIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionStatus.UNRECOGNIZED;
  }
}

export function transactionStatusToJSON(object: TransactionStatus): string {
  switch (object) {
    case TransactionStatus.TRANSACTION_STATUS_COMPLETED:
      return "TRANSACTION_STATUS_COMPLETED";
    case TransactionStatus.TRANSACTION_STATUS_BROADCAST:
      return "TRANSACTION_STATUS_BROADCAST";
    case TransactionStatus.TRANSACTION_STATUS_MINED_UNCONFIRMED:
      return "TRANSACTION_STATUS_MINED_UNCONFIRMED";
    case TransactionStatus.TRANSACTION_STATUS_IMPORTED:
      return "TRANSACTION_STATUS_IMPORTED";
    case TransactionStatus.TRANSACTION_STATUS_PENDING:
      return "TRANSACTION_STATUS_PENDING";
    case TransactionStatus.TRANSACTION_STATUS_COINBASE:
      return "TRANSACTION_STATUS_COINBASE";
    case TransactionStatus.TRANSACTION_STATUS_MINED_CONFIRMED:
      return "TRANSACTION_STATUS_MINED_CONFIRMED";
    case TransactionStatus.TRANSACTION_STATUS_REJECTED:
      return "TRANSACTION_STATUS_REJECTED";
    case TransactionStatus.TRANSACTION_STATUS_ONE_SIDED_UNCONFIRMED:
      return "TRANSACTION_STATUS_ONE_SIDED_UNCONFIRMED";
    case TransactionStatus.TRANSACTION_STATUS_ONE_SIDED_CONFIRMED:
      return "TRANSACTION_STATUS_ONE_SIDED_CONFIRMED";
    case TransactionStatus.TRANSACTION_STATUS_QUEUED:
      return "TRANSACTION_STATUS_QUEUED";
    case TransactionStatus.TRANSACTION_STATUS_NOT_FOUND:
      return "TRANSACTION_STATUS_NOT_FOUND";
    case TransactionStatus.TRANSACTION_STATUS_COINBASE_UNCONFIRMED:
      return "TRANSACTION_STATUS_COINBASE_UNCONFIRMED";
    case TransactionStatus.TRANSACTION_STATUS_COINBASE_CONFIRMED:
      return "TRANSACTION_STATUS_COINBASE_CONFIRMED";
    case TransactionStatus.TRANSACTION_STATUS_COINBASE_NOT_IN_BLOCK_CHAIN:
      return "TRANSACTION_STATUS_COINBASE_NOT_IN_BLOCK_CHAIN";
    case TransactionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enum for payment direction */
export enum PaymentDirection {
  /** PAYMENT_DIRECTION_UNKNOWN - Unknown or unspecified direction */
  PAYMENT_DIRECTION_UNKNOWN = 0,
  /** PAYMENT_DIRECTION_INBOUND - Payment received by this wallet */
  PAYMENT_DIRECTION_INBOUND = 1,
  /** PAYMENT_DIRECTION_OUTBOUND - Payment sent from this wallet */
  PAYMENT_DIRECTION_OUTBOUND = 2,
  UNRECOGNIZED = -1,
}

export function paymentDirectionFromJSON(object: any): PaymentDirection {
  switch (object) {
    case 0:
    case "PAYMENT_DIRECTION_UNKNOWN":
      return PaymentDirection.PAYMENT_DIRECTION_UNKNOWN;
    case 1:
    case "PAYMENT_DIRECTION_INBOUND":
      return PaymentDirection.PAYMENT_DIRECTION_INBOUND;
    case 2:
    case "PAYMENT_DIRECTION_OUTBOUND":
      return PaymentDirection.PAYMENT_DIRECTION_OUTBOUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentDirection.UNRECOGNIZED;
  }
}

export function paymentDirectionToJSON(object: PaymentDirection): string {
  switch (object) {
    case PaymentDirection.PAYMENT_DIRECTION_UNKNOWN:
      return "PAYMENT_DIRECTION_UNKNOWN";
    case PaymentDirection.PAYMENT_DIRECTION_INBOUND:
      return "PAYMENT_DIRECTION_INBOUND";
    case PaymentDirection.PAYMENT_DIRECTION_OUTBOUND:
      return "PAYMENT_DIRECTION_OUTBOUND";
    case PaymentDirection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GetVersionRequest {
}

export interface GetVersionResponse {
  version: string;
}

export interface GetAddressResponse {
  interactiveAddress: Uint8Array;
  oneSidedAddress: Uint8Array;
}

export interface GetPaymentIdAddressRequest {
  paymentId: Uint8Array;
}

/** Response message containing all formats of wallet addresses. */
export interface GetCompleteAddressResponse {
  /** Binary form of the interactive address. */
  interactiveAddress: Uint8Array;
  /** Binary form of the one-sided address. */
  oneSidedAddress: Uint8Array;
  /** Base58-encoded version of the interactive address. */
  interactiveAddressBase58: string;
  /** Base58-encoded version of the one-sided address. */
  oneSidedAddressBase58: string;
  /** Emoji-encoded version of the interactive address. */
  interactiveAddressEmoji: string;
  /** Emoji-encoded version of the one-sided address. */
  oneSidedAddressEmoji: string;
}

/** A request to preapre a one sided transaction for offline signing */
export interface PrepareOneSidedTransactionForSigningRequest {
  recipient: PaymentRecipient | undefined;
}

export interface PrepareOneSidedTransactionForSigningResponse {
  isSuccess: boolean;
  result: string;
  failureMessage: string;
}

/** A request to broadcast a signed one sided transaction */
export interface BroadcastSignedOneSidedTransactionRequest {
  request: string;
}

export interface BroadcastSignedOneSidedTransactionResponse {
  isSuccess: boolean;
  transactionId: Long;
  failureMessage: string;
}

/** A request to send funds to one or more recipients. */
export interface TransferRequest {
  recipients: PaymentRecipient[];
}

export interface SendShaAtomicSwapRequest {
  recipient: PaymentRecipient | undefined;
}

export interface CreateBurnTransactionRequest {
  amount: Long;
  feePerGram: Long;
  claimPublicKey: Uint8Array;
  paymentId: Uint8Array;
  sidechainDeploymentKey: Uint8Array;
}

/** A recipient for a transfer, including address, amount, fee, and optional payment ID. */
export interface PaymentRecipient {
  /** Base58 Tari address of the recipient. */
  address: string;
  /** Amount to send in microTari (1 T = 1_000_000 µT). */
  amount: Long;
  /** Fee rate per gram. */
  feePerGram: Long;
  /** The type of payment to perform. */
  paymentType: PaymentRecipient_PaymentType;
  /** raw payment id */
  rawPaymentId: Uint8Array;
  /** Optional user encrypted payment ID for reference (max 256 bytes). */
  userPaymentId: UserPaymentId | undefined;
}

export enum PaymentRecipient_PaymentType {
  /**
   * STANDARD_MIMBLEWIMBLE - Default Mimblewimble-style transaction.
   *
   * @deprecated
   */
  STANDARD_MIMBLEWIMBLE = 0,
  /**
   * ONE_SIDED - One-sided transaction (receiver not required to participate).
   *
   * @deprecated
   */
  ONE_SIDED = 1,
  /** ONE_SIDED_TO_STEALTH_ADDRESS - One-sided stealth address (adds privacy by hiding destination). */
  ONE_SIDED_TO_STEALTH_ADDRESS = 2,
  UNRECOGNIZED = -1,
}

export function paymentRecipient_PaymentTypeFromJSON(object: any): PaymentRecipient_PaymentType {
  switch (object) {
    case 0:
    case "STANDARD_MIMBLEWIMBLE":
      return PaymentRecipient_PaymentType.STANDARD_MIMBLEWIMBLE;
    case 1:
    case "ONE_SIDED":
      return PaymentRecipient_PaymentType.ONE_SIDED;
    case 2:
    case "ONE_SIDED_TO_STEALTH_ADDRESS":
      return PaymentRecipient_PaymentType.ONE_SIDED_TO_STEALTH_ADDRESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentRecipient_PaymentType.UNRECOGNIZED;
  }
}

export function paymentRecipient_PaymentTypeToJSON(object: PaymentRecipient_PaymentType): string {
  switch (object) {
    case PaymentRecipient_PaymentType.STANDARD_MIMBLEWIMBLE:
      return "STANDARD_MIMBLEWIMBLE";
    case PaymentRecipient_PaymentType.ONE_SIDED:
      return "ONE_SIDED";
    case PaymentRecipient_PaymentType.ONE_SIDED_TO_STEALTH_ADDRESS:
      return "ONE_SIDED_TO_STEALTH_ADDRESS";
    case PaymentRecipient_PaymentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TransferResponse {
  results: TransferResult[];
}

export interface SendShaAtomicSwapResponse {
  transactionId: Long;
  preImage: string;
  outputHash: string;
  isSuccess: boolean;
  failureMessage: string;
}

export interface CreateBurnTransactionResponse {
  transactionId: Long;
  isSuccess: boolean;
  failureMessage: string;
  commitment: Uint8Array;
  ownershipProof: CommitmentSignature | undefined;
  rangeProof: Uint8Array;
  reciprocalClaimPublicKey: Uint8Array;
}

export interface TransferResult {
  address: string;
  transactionId: Long;
  isSuccess: boolean;
  failureMessage: string;
  transactionInfo: TransactionInfo | undefined;
}

export interface ClaimShaAtomicSwapRequest {
  output: string;
  preImage: string;
  feePerGram: Long;
}

export interface ClaimShaAtomicSwapResponse {
  results: TransferResult | undefined;
}

export interface ClaimHtlcRefundRequest {
  outputHash: string;
  feePerGram: Long;
}

export interface ClaimHtlcRefundResponse {
  results: TransferResult | undefined;
}

export interface GetTransactionInfoRequest {
  transactionIds: Long[];
}

export interface GetTransactionInfoResponse {
  transactions: TransactionInfo[];
}

export interface TransactionInfo {
  txId: Long;
  sourceAddress: Uint8Array;
  destAddress: Uint8Array;
  status: TransactionStatus;
  direction: TransactionDirection;
  amount: Long;
  fee: Long;
  isCancelled: boolean;
  excessSig: Uint8Array;
  timestamp: Long;
  rawPaymentId: Uint8Array;
  minedInBlockHeight: Long;
  userPaymentId: Uint8Array;
  inputCommitments: Uint8Array[];
  outputCommitments: Uint8Array[];
  paymentReferencesSent: Uint8Array[];
  paymentReferencesReceived: Uint8Array[];
  paymentReferencesChange: Uint8Array[];
}

export interface GetCompletedTransactionsRequest {
  paymentId: UserPaymentId | undefined;
  blockHash: BlockHashHex | undefined;
  blockHeight: BlockHeight | undefined;
}

export interface BlockHashHex {
  hash: string;
}

export interface GetCompletedTransactionsResponse {
  transaction: TransactionInfo | undefined;
}

/** Request message for GetBalance RPC. */
export interface GetBalanceRequest {
  /**
   * Optional: A user-defined payment ID to filter balance data.
   * Must provide only one of the following fields: u256, utf8_string, or user_bytes.
   */
  paymentId: UserPaymentId | undefined;
}

export interface UserPaymentId {
  u256: Uint8Array;
  utf8String: string;
  userBytes: Uint8Array;
}

export interface GetStateRequest {
}

export interface GetBalanceResponse {
  availableBalance: Long;
  pendingIncomingBalance: Long;
  pendingOutgoingBalance: Long;
  timelockedBalance: Long;
}

/** Response message for GetState */
export interface GetStateResponse {
  /** The blockchain height (in blocks) that the wallet has scanned up to */
  scannedHeight: Long;
  /** Current wallet balance information (available, pending), based on the GetBalanceResponse */
  balance:
    | GetBalanceResponse
    | undefined;
  /** Status of the wallet's connection to the base node, based on the NetworkStatusResponse */
  network:
    | NetworkStatusResponse
    | undefined;
  /** Has the wallet since starting, completed a validation of all outputs after scanning */
  hasDoneInitialValidation: boolean;
}

/** Response message for GetUnspentAmounts RPC. */
export interface GetUnspentAmountsResponse {
  /** Total value of all unspent outputs, in the smallest unit (e.g., microTari). */
  amount: Long[];
}

/** Request message for the CoinSplit RPC. */
export interface CoinSplitRequest {
  /** The value of each output to create. */
  amountPerSplit: Long;
  /** The number of outputs to create in total. */
  splitCount: Long;
  /** Fee rate per weight unit (gram). */
  feePerGram: Long;
  /** Block height when the transaction becomes valid. */
  lockHeight: Long;
  /** Optional identifier for referencing the transaction. */
  paymentId: Uint8Array;
}

/** Response message containing the transaction ID of the coin split. */
export interface CoinSplitResponse {
  /** The unique ID of the transaction created. */
  txId: Long;
}

/** Request message for importing UTXOs into the wallet. */
export interface ImportUtxosRequest {
  /** List of unblinded outputs to be imported as UTXOs. */
  outputs: UnblindedOutput[];
  /** Optional payment ID to tag the imported outputs. */
  paymentId: Uint8Array;
}

/** Response message containing transaction IDs for the imported outputs. */
export interface ImportUtxosResponse {
  /** Transaction IDs corresponding to the imported UTXOs. */
  txIds: Long[];
}

export interface CreateTemplateRegistrationRequest {
  feePerGram: Long;
  templateName: string;
  templateVersion: number;
  templateType: TemplateType | undefined;
  buildInfo: BuildInfo | undefined;
  binarySha: Uint8Array;
  binaryUrl: string;
  sidechainDeploymentKey: Uint8Array;
}

export interface CreateTemplateRegistrationResponse {
  txId: Long;
  templateAddress: Uint8Array;
}

/** Request message for the CancelTransaction RPC. */
export interface CancelTransactionRequest {
  /** The transaction ID to be cancelled. */
  txId: Long;
}

/** Response message for the CancelTransaction RPC. */
export interface CancelTransactionResponse {
  /** Indicates whether the cancellation was successful. */
  isSuccess: boolean;
  /** The failure message if the cancellation was not successful. */
  failureMessage: string;
}

export interface RevalidateRequest {
}

export interface RevalidateResponse {
}

export interface ValidateRequest {
}

export interface ValidateResponse {
}

export interface SetBaseNodeResponse {
}

/** Empty request for CheckConnectivity */
export interface GetConnectivityRequest {
}

/** Response indicating the wallet's connectivity status */
export interface CheckConnectivityResponse {
  /** The current connectivity state of the wallet */
  status: CheckConnectivityResponse_OnlineStatus;
}

/** Describes the wallet's network connection state */
export enum CheckConnectivityResponse_OnlineStatus {
  /** Connecting - The wallet is attempting to connect to peers */
  Connecting = 0,
  /** Online - The wallet is successfully connected to peers */
  Online = 1,
  /** Offline - The wallet is not connected to any peers */
  Offline = 2,
  UNRECOGNIZED = -1,
}

export function checkConnectivityResponse_OnlineStatusFromJSON(object: any): CheckConnectivityResponse_OnlineStatus {
  switch (object) {
    case 0:
    case "Connecting":
      return CheckConnectivityResponse_OnlineStatus.Connecting;
    case 1:
    case "Online":
      return CheckConnectivityResponse_OnlineStatus.Online;
    case 2:
    case "Offline":
      return CheckConnectivityResponse_OnlineStatus.Offline;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CheckConnectivityResponse_OnlineStatus.UNRECOGNIZED;
  }
}

export function checkConnectivityResponse_OnlineStatusToJSON(object: CheckConnectivityResponse_OnlineStatus): string {
  switch (object) {
    case CheckConnectivityResponse_OnlineStatus.Connecting:
      return "Connecting";
    case CheckConnectivityResponse_OnlineStatus.Online:
      return "Online";
    case CheckConnectivityResponse_OnlineStatus.Offline:
      return "Offline";
    case CheckConnectivityResponse_OnlineStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TransactionEventRequest {
}

export interface TransactionEvent {
  event: string;
  txId: string;
  sourceAddress: Uint8Array;
  destAddress: Uint8Array;
  status: string;
  direction: string;
  amount: Long;
  rawPaymentId: Uint8Array;
  userPaymentId: Uint8Array;
}

export interface TransactionEventResponse {
  transaction: TransactionEvent | undefined;
}

export interface RegisterValidatorNodeRequest {
  validatorNodePublicKey: Uint8Array;
  validatorNodeSignature: Signature | undefined;
  validatorNodeClaimPublicKey: Uint8Array;
  maxEpoch: Long;
  feePerGram: Long;
  paymentId: Uint8Array;
  sidechainDeploymentKey: Uint8Array;
}

export interface RegisterValidatorNodeResponse {
  transactionId: Long;
  isSuccess: boolean;
  failureMessage: string;
}

export interface SubmitValidatorEvictionProofRequest {
  proof: EvictionProof | undefined;
  feePerGram: Long;
  message: string;
  sidechainDeploymentKey: Uint8Array;
}

export interface SubmitValidatorEvictionProofResponse {
  txId: Long;
}

export interface SubmitValidatorNodeExitRequest {
  validatorNodePublicKey: Uint8Array;
  validatorNodeSignature: Signature | undefined;
  maxEpoch: Long;
  feePerGram: Long;
  message: Uint8Array;
  sidechainDeploymentKey: Uint8Array;
}

export interface SubmitValidatorNodeExitResponse {
  transactionId: Long;
  isSuccess: boolean;
  failureMessage: string;
}

export interface ImportTransactionsRequest {
  txs: string;
}

export interface ImportTransactionsResponse {
  txIds: Long[];
}

export interface GetAllCompletedTransactionsRequest {
  offset: Long;
  /** limited to 50 if passed higher number than it will be reduced to 50 */
  limit: Long;
  statusBitflag: Long;
}

/** DEPRECATED: Use GetAllCompletedTransactionsStream for better performance and memory efficiency */
export interface GetAllCompletedTransactionsResponse {
  transactions: TransactionInfo[];
}

/** Request message for getting transactions at a specific block height */
export interface GetBlockHeightTransactionsRequest {
  /** The block height to fetch transactions for */
  blockHeight: Long;
}

export interface GetBlockHeightTransactionsResponse {
  /** List of transactions mined at the specified block height */
  transactions: TransactionInfo[];
}

/** Request message for GetTransactionPayRefs RPC. */
export interface GetTransactionPayRefsRequest {
  /** The transaction ID to retrieve PayRefs for. */
  transactionId: Long;
}

/** Response message for GetTransactionPayRefs RPC. */
export interface GetTransactionPayRefsResponse {
  /** List of PayRefs (32-byte payment references) for the transaction. */
  paymentReferences: Uint8Array[];
}

/** Response message for GetTransactionsWithPayRefs RPC. */
export interface GetTransactionsWithPayRefsResponse {
  /** The transaction information. */
  transaction:
    | TransactionInfo
    | undefined;
  /** List of PayRefs associated with this transaction. */
  paymentReferences: Uint8Array[];
  /** Number of unique recipients for this transaction. */
  recipientCount: Long;
}

/** Request message for getting payment details by payment reference */
export interface GetPaymentByReferenceRequest {
  /** The 32-byte payment reference hash to look up */
  paymentReference: Uint8Array;
}

/** Response message containing transaction information for a payment reference */
export interface GetPaymentByReferenceResponse {
  /**
   * The transaction information if PayRef is found (optional).
   * Returns full transaction details
   */
  transaction: TransactionInfo | undefined;
}

export interface GetFeeEstimateRequest {
  /** The amount to send in microTari (1 T = 1_000_000 µT). */
  amount: Long;
  /** fee per gram to use for the estimate */
  feePerGram: Long;
  /** number of outputs to create in the transaction */
  outputCount: Long;
}

export interface GetFeeEstimateResponse {
  /** Estimated fee for the transaction in microTari */
  estimatedFee: Long;
}

export interface GetFeePerGramStatsRequest {
  /** Optional: The number of recent blocks to consider for fee statistics. */
  blockCount: Long;
}

export interface GetFeePerGramStatsResponse {
  feePerGramStats: FeePerGramStat[];
}

export interface ReplaceByFeeRequest {
  /** The transaction id of the transaction to replace */
  transactionId: Long;
  /** The amount to increase the fee by in microTari. Must be greater than zero. */
  feeIncrease: Long;
}

export interface ReplaceByFeeResponse {
  /** Transaction id of the new transaction */
  transactionId: Long;
}

export interface UserPayForFeeRequest {
  recipients: TxOutputsToSpendTransfer[];
}

export interface TxOutputsToSpendTransfer {
  /** Id of the transaction to spend outputs from. */
  txId: Long;
  /** Fee to pay for the transaction in microTari. */
  fee: Long;
  /** Base58 Tari address of the recipient. */
  destination: string;
}

export interface UserPayForFeeResponse {
  results: TransferResult[];
}

export interface FeePerGramStat {
  /** The average fee per gram over the specified number of blocks. */
  averageFeePerGram: Long;
  /** The minimum fee per gram observed in the recent blocks. */
  minFeePerGram: Long;
  /** The maximum fee per gram observed in the recent blocks. */
  maxFeePerGram: Long;
}

/** Request message for SignMessage RPC */
export interface SignMessageRequest {
  /** The message to be signed (arbitrary bytes) */
  message: Uint8Array;
}

/** Response message for SignMessage RPC */
export interface SignMessageResponse {
  /** The Schnorr signature as hex-encoded string */
  signature: string;
  /** The public nonce component as hex-encoded string */
  publicNonce: string;
}

function createBaseGetVersionRequest(): GetVersionRequest {
  return {};
}

export const GetVersionRequest: MessageFns<GetVersionRequest> = {
  encode(_: GetVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetVersionRequest {
    return {};
  },

  toJSON(_: GetVersionRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVersionRequest>, I>>(base?: I): GetVersionRequest {
    return GetVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVersionRequest>, I>>(_: I): GetVersionRequest {
    const message = createBaseGetVersionRequest();
    return message;
  },
};

function createBaseGetVersionResponse(): GetVersionResponse {
  return { version: "" };
}

export const GetVersionResponse: MessageFns<GetVersionResponse> = {
  encode(message: GetVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVersionResponse {
    return { version: isSet(object.version) ? globalThis.String(object.version) : "" };
  },

  toJSON(message: GetVersionResponse): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVersionResponse>, I>>(base?: I): GetVersionResponse {
    return GetVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVersionResponse>, I>>(object: I): GetVersionResponse {
    const message = createBaseGetVersionResponse();
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseGetAddressResponse(): GetAddressResponse {
  return { interactiveAddress: new Uint8Array(0), oneSidedAddress: new Uint8Array(0) };
}

export const GetAddressResponse: MessageFns<GetAddressResponse> = {
  encode(message: GetAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.interactiveAddress.length !== 0) {
      writer.uint32(10).bytes(message.interactiveAddress);
    }
    if (message.oneSidedAddress.length !== 0) {
      writer.uint32(18).bytes(message.oneSidedAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.interactiveAddress = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oneSidedAddress = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressResponse {
    return {
      interactiveAddress: isSet(object.interactiveAddress)
        ? bytesFromBase64(object.interactiveAddress)
        : new Uint8Array(0),
      oneSidedAddress: isSet(object.oneSidedAddress) ? bytesFromBase64(object.oneSidedAddress) : new Uint8Array(0),
    };
  },

  toJSON(message: GetAddressResponse): unknown {
    const obj: any = {};
    if (message.interactiveAddress.length !== 0) {
      obj.interactiveAddress = base64FromBytes(message.interactiveAddress);
    }
    if (message.oneSidedAddress.length !== 0) {
      obj.oneSidedAddress = base64FromBytes(message.oneSidedAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAddressResponse>, I>>(base?: I): GetAddressResponse {
    return GetAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAddressResponse>, I>>(object: I): GetAddressResponse {
    const message = createBaseGetAddressResponse();
    message.interactiveAddress = object.interactiveAddress ?? new Uint8Array(0);
    message.oneSidedAddress = object.oneSidedAddress ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetPaymentIdAddressRequest(): GetPaymentIdAddressRequest {
  return { paymentId: new Uint8Array(0) };
}

export const GetPaymentIdAddressRequest: MessageFns<GetPaymentIdAddressRequest> = {
  encode(message: GetPaymentIdAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId.length !== 0) {
      writer.uint32(10).bytes(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPaymentIdAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentIdAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPaymentIdAddressRequest {
    return { paymentId: isSet(object.paymentId) ? bytesFromBase64(object.paymentId) : new Uint8Array(0) };
  },

  toJSON(message: GetPaymentIdAddressRequest): unknown {
    const obj: any = {};
    if (message.paymentId.length !== 0) {
      obj.paymentId = base64FromBytes(message.paymentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPaymentIdAddressRequest>, I>>(base?: I): GetPaymentIdAddressRequest {
    return GetPaymentIdAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPaymentIdAddressRequest>, I>>(object: I): GetPaymentIdAddressRequest {
    const message = createBaseGetPaymentIdAddressRequest();
    message.paymentId = object.paymentId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetCompleteAddressResponse(): GetCompleteAddressResponse {
  return {
    interactiveAddress: new Uint8Array(0),
    oneSidedAddress: new Uint8Array(0),
    interactiveAddressBase58: "",
    oneSidedAddressBase58: "",
    interactiveAddressEmoji: "",
    oneSidedAddressEmoji: "",
  };
}

export const GetCompleteAddressResponse: MessageFns<GetCompleteAddressResponse> = {
  encode(message: GetCompleteAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.interactiveAddress.length !== 0) {
      writer.uint32(10).bytes(message.interactiveAddress);
    }
    if (message.oneSidedAddress.length !== 0) {
      writer.uint32(18).bytes(message.oneSidedAddress);
    }
    if (message.interactiveAddressBase58 !== "") {
      writer.uint32(26).string(message.interactiveAddressBase58);
    }
    if (message.oneSidedAddressBase58 !== "") {
      writer.uint32(34).string(message.oneSidedAddressBase58);
    }
    if (message.interactiveAddressEmoji !== "") {
      writer.uint32(42).string(message.interactiveAddressEmoji);
    }
    if (message.oneSidedAddressEmoji !== "") {
      writer.uint32(50).string(message.oneSidedAddressEmoji);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCompleteAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCompleteAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.interactiveAddress = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oneSidedAddress = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.interactiveAddressBase58 = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.oneSidedAddressBase58 = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.interactiveAddressEmoji = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.oneSidedAddressEmoji = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCompleteAddressResponse {
    return {
      interactiveAddress: isSet(object.interactiveAddress)
        ? bytesFromBase64(object.interactiveAddress)
        : new Uint8Array(0),
      oneSidedAddress: isSet(object.oneSidedAddress) ? bytesFromBase64(object.oneSidedAddress) : new Uint8Array(0),
      interactiveAddressBase58: isSet(object.interactiveAddressBase58)
        ? globalThis.String(object.interactiveAddressBase58)
        : "",
      oneSidedAddressBase58: isSet(object.oneSidedAddressBase58) ? globalThis.String(object.oneSidedAddressBase58) : "",
      interactiveAddressEmoji: isSet(object.interactiveAddressEmoji)
        ? globalThis.String(object.interactiveAddressEmoji)
        : "",
      oneSidedAddressEmoji: isSet(object.oneSidedAddressEmoji) ? globalThis.String(object.oneSidedAddressEmoji) : "",
    };
  },

  toJSON(message: GetCompleteAddressResponse): unknown {
    const obj: any = {};
    if (message.interactiveAddress.length !== 0) {
      obj.interactiveAddress = base64FromBytes(message.interactiveAddress);
    }
    if (message.oneSidedAddress.length !== 0) {
      obj.oneSidedAddress = base64FromBytes(message.oneSidedAddress);
    }
    if (message.interactiveAddressBase58 !== "") {
      obj.interactiveAddressBase58 = message.interactiveAddressBase58;
    }
    if (message.oneSidedAddressBase58 !== "") {
      obj.oneSidedAddressBase58 = message.oneSidedAddressBase58;
    }
    if (message.interactiveAddressEmoji !== "") {
      obj.interactiveAddressEmoji = message.interactiveAddressEmoji;
    }
    if (message.oneSidedAddressEmoji !== "") {
      obj.oneSidedAddressEmoji = message.oneSidedAddressEmoji;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCompleteAddressResponse>, I>>(base?: I): GetCompleteAddressResponse {
    return GetCompleteAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCompleteAddressResponse>, I>>(object: I): GetCompleteAddressResponse {
    const message = createBaseGetCompleteAddressResponse();
    message.interactiveAddress = object.interactiveAddress ?? new Uint8Array(0);
    message.oneSidedAddress = object.oneSidedAddress ?? new Uint8Array(0);
    message.interactiveAddressBase58 = object.interactiveAddressBase58 ?? "";
    message.oneSidedAddressBase58 = object.oneSidedAddressBase58 ?? "";
    message.interactiveAddressEmoji = object.interactiveAddressEmoji ?? "";
    message.oneSidedAddressEmoji = object.oneSidedAddressEmoji ?? "";
    return message;
  },
};

function createBasePrepareOneSidedTransactionForSigningRequest(): PrepareOneSidedTransactionForSigningRequest {
  return { recipient: undefined };
}

export const PrepareOneSidedTransactionForSigningRequest: MessageFns<PrepareOneSidedTransactionForSigningRequest> = {
  encode(
    message: PrepareOneSidedTransactionForSigningRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.recipient !== undefined) {
      PaymentRecipient.encode(message.recipient, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrepareOneSidedTransactionForSigningRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareOneSidedTransactionForSigningRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recipient = PaymentRecipient.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrepareOneSidedTransactionForSigningRequest {
    return { recipient: isSet(object.recipient) ? PaymentRecipient.fromJSON(object.recipient) : undefined };
  },

  toJSON(message: PrepareOneSidedTransactionForSigningRequest): unknown {
    const obj: any = {};
    if (message.recipient !== undefined) {
      obj.recipient = PaymentRecipient.toJSON(message.recipient);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrepareOneSidedTransactionForSigningRequest>, I>>(
    base?: I,
  ): PrepareOneSidedTransactionForSigningRequest {
    return PrepareOneSidedTransactionForSigningRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrepareOneSidedTransactionForSigningRequest>, I>>(
    object: I,
  ): PrepareOneSidedTransactionForSigningRequest {
    const message = createBasePrepareOneSidedTransactionForSigningRequest();
    message.recipient = (object.recipient !== undefined && object.recipient !== null)
      ? PaymentRecipient.fromPartial(object.recipient)
      : undefined;
    return message;
  },
};

function createBasePrepareOneSidedTransactionForSigningResponse(): PrepareOneSidedTransactionForSigningResponse {
  return { isSuccess: false, result: "", failureMessage: "" };
}

export const PrepareOneSidedTransactionForSigningResponse: MessageFns<PrepareOneSidedTransactionForSigningResponse> = {
  encode(
    message: PrepareOneSidedTransactionForSigningResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.isSuccess !== false) {
      writer.uint32(8).bool(message.isSuccess);
    }
    if (message.result !== "") {
      writer.uint32(18).string(message.result);
    }
    if (message.failureMessage !== "") {
      writer.uint32(26).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrepareOneSidedTransactionForSigningResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareOneSidedTransactionForSigningResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrepareOneSidedTransactionForSigningResponse {
    return {
      isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false,
      result: isSet(object.result) ? globalThis.String(object.result) : "",
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: PrepareOneSidedTransactionForSigningResponse): unknown {
    const obj: any = {};
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrepareOneSidedTransactionForSigningResponse>, I>>(
    base?: I,
  ): PrepareOneSidedTransactionForSigningResponse {
    return PrepareOneSidedTransactionForSigningResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrepareOneSidedTransactionForSigningResponse>, I>>(
    object: I,
  ): PrepareOneSidedTransactionForSigningResponse {
    const message = createBasePrepareOneSidedTransactionForSigningResponse();
    message.isSuccess = object.isSuccess ?? false;
    message.result = object.result ?? "";
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

function createBaseBroadcastSignedOneSidedTransactionRequest(): BroadcastSignedOneSidedTransactionRequest {
  return { request: "" };
}

export const BroadcastSignedOneSidedTransactionRequest: MessageFns<BroadcastSignedOneSidedTransactionRequest> = {
  encode(message: BroadcastSignedOneSidedTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== "") {
      writer.uint32(10).string(message.request);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BroadcastSignedOneSidedTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBroadcastSignedOneSidedTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BroadcastSignedOneSidedTransactionRequest {
    return { request: isSet(object.request) ? globalThis.String(object.request) : "" };
  },

  toJSON(message: BroadcastSignedOneSidedTransactionRequest): unknown {
    const obj: any = {};
    if (message.request !== "") {
      obj.request = message.request;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BroadcastSignedOneSidedTransactionRequest>, I>>(
    base?: I,
  ): BroadcastSignedOneSidedTransactionRequest {
    return BroadcastSignedOneSidedTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BroadcastSignedOneSidedTransactionRequest>, I>>(
    object: I,
  ): BroadcastSignedOneSidedTransactionRequest {
    const message = createBaseBroadcastSignedOneSidedTransactionRequest();
    message.request = object.request ?? "";
    return message;
  },
};

function createBaseBroadcastSignedOneSidedTransactionResponse(): BroadcastSignedOneSidedTransactionResponse {
  return { isSuccess: false, transactionId: Long.UZERO, failureMessage: "" };
}

export const BroadcastSignedOneSidedTransactionResponse: MessageFns<BroadcastSignedOneSidedTransactionResponse> = {
  encode(message: BroadcastSignedOneSidedTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isSuccess !== false) {
      writer.uint32(8).bool(message.isSuccess);
    }
    if (!message.transactionId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.transactionId.toString());
    }
    if (message.failureMessage !== "") {
      writer.uint32(26).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BroadcastSignedOneSidedTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBroadcastSignedOneSidedTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.transactionId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BroadcastSignedOneSidedTransactionResponse {
    return {
      isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false,
      transactionId: isSet(object.transactionId) ? Long.fromValue(object.transactionId) : Long.UZERO,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: BroadcastSignedOneSidedTransactionResponse): unknown {
    const obj: any = {};
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    if (!message.transactionId.equals(Long.UZERO)) {
      obj.transactionId = (message.transactionId || Long.UZERO).toString();
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BroadcastSignedOneSidedTransactionResponse>, I>>(
    base?: I,
  ): BroadcastSignedOneSidedTransactionResponse {
    return BroadcastSignedOneSidedTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BroadcastSignedOneSidedTransactionResponse>, I>>(
    object: I,
  ): BroadcastSignedOneSidedTransactionResponse {
    const message = createBaseBroadcastSignedOneSidedTransactionResponse();
    message.isSuccess = object.isSuccess ?? false;
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? Long.fromValue(object.transactionId)
      : Long.UZERO;
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

function createBaseTransferRequest(): TransferRequest {
  return { recipients: [] };
}

export const TransferRequest: MessageFns<TransferRequest> = {
  encode(message: TransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.recipients) {
      PaymentRecipient.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recipients.push(PaymentRecipient.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferRequest {
    return {
      recipients: globalThis.Array.isArray(object?.recipients)
        ? object.recipients.map((e: any) => PaymentRecipient.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransferRequest): unknown {
    const obj: any = {};
    if (message.recipients?.length) {
      obj.recipients = message.recipients.map((e) => PaymentRecipient.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferRequest>, I>>(base?: I): TransferRequest {
    return TransferRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferRequest>, I>>(object: I): TransferRequest {
    const message = createBaseTransferRequest();
    message.recipients = object.recipients?.map((e) => PaymentRecipient.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSendShaAtomicSwapRequest(): SendShaAtomicSwapRequest {
  return { recipient: undefined };
}

export const SendShaAtomicSwapRequest: MessageFns<SendShaAtomicSwapRequest> = {
  encode(message: SendShaAtomicSwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recipient !== undefined) {
      PaymentRecipient.encode(message.recipient, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendShaAtomicSwapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendShaAtomicSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recipient = PaymentRecipient.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendShaAtomicSwapRequest {
    return { recipient: isSet(object.recipient) ? PaymentRecipient.fromJSON(object.recipient) : undefined };
  },

  toJSON(message: SendShaAtomicSwapRequest): unknown {
    const obj: any = {};
    if (message.recipient !== undefined) {
      obj.recipient = PaymentRecipient.toJSON(message.recipient);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendShaAtomicSwapRequest>, I>>(base?: I): SendShaAtomicSwapRequest {
    return SendShaAtomicSwapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendShaAtomicSwapRequest>, I>>(object: I): SendShaAtomicSwapRequest {
    const message = createBaseSendShaAtomicSwapRequest();
    message.recipient = (object.recipient !== undefined && object.recipient !== null)
      ? PaymentRecipient.fromPartial(object.recipient)
      : undefined;
    return message;
  },
};

function createBaseCreateBurnTransactionRequest(): CreateBurnTransactionRequest {
  return {
    amount: Long.UZERO,
    feePerGram: Long.UZERO,
    claimPublicKey: new Uint8Array(0),
    paymentId: new Uint8Array(0),
    sidechainDeploymentKey: new Uint8Array(0),
  };
}

export const CreateBurnTransactionRequest: MessageFns<CreateBurnTransactionRequest> = {
  encode(message: CreateBurnTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.amount.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.amount.toString());
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.feePerGram.toString());
    }
    if (message.claimPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.claimPublicKey);
    }
    if (message.paymentId.length !== 0) {
      writer.uint32(42).bytes(message.paymentId);
    }
    if (message.sidechainDeploymentKey.length !== 0) {
      writer.uint32(50).bytes(message.sidechainDeploymentKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBurnTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBurnTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.amount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.claimPublicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentId = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sidechainDeploymentKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBurnTransactionRequest {
    return {
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.UZERO,
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
      claimPublicKey: isSet(object.claimPublicKey) ? bytesFromBase64(object.claimPublicKey) : new Uint8Array(0),
      paymentId: isSet(object.paymentId) ? bytesFromBase64(object.paymentId) : new Uint8Array(0),
      sidechainDeploymentKey: isSet(object.sidechainDeploymentKey)
        ? bytesFromBase64(object.sidechainDeploymentKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CreateBurnTransactionRequest): unknown {
    const obj: any = {};
    if (!message.amount.equals(Long.UZERO)) {
      obj.amount = (message.amount || Long.UZERO).toString();
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    if (message.claimPublicKey.length !== 0) {
      obj.claimPublicKey = base64FromBytes(message.claimPublicKey);
    }
    if (message.paymentId.length !== 0) {
      obj.paymentId = base64FromBytes(message.paymentId);
    }
    if (message.sidechainDeploymentKey.length !== 0) {
      obj.sidechainDeploymentKey = base64FromBytes(message.sidechainDeploymentKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBurnTransactionRequest>, I>>(base?: I): CreateBurnTransactionRequest {
    return CreateBurnTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBurnTransactionRequest>, I>>(object: I): CreateBurnTransactionRequest {
    const message = createBaseCreateBurnTransactionRequest();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.UZERO;
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    message.claimPublicKey = object.claimPublicKey ?? new Uint8Array(0);
    message.paymentId = object.paymentId ?? new Uint8Array(0);
    message.sidechainDeploymentKey = object.sidechainDeploymentKey ?? new Uint8Array(0);
    return message;
  },
};

function createBasePaymentRecipient(): PaymentRecipient {
  return {
    address: "",
    amount: Long.UZERO,
    feePerGram: Long.UZERO,
    paymentType: 0,
    rawPaymentId: new Uint8Array(0),
    userPaymentId: undefined,
  };
}

export const PaymentRecipient: MessageFns<PaymentRecipient> = {
  encode(message: PaymentRecipient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (!message.amount.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.amount.toString());
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.feePerGram.toString());
    }
    if (message.paymentType !== 0) {
      writer.uint32(40).int32(message.paymentType);
    }
    if (message.rawPaymentId.length !== 0) {
      writer.uint32(50).bytes(message.rawPaymentId);
    }
    if (message.userPaymentId !== undefined) {
      UserPaymentId.encode(message.userPaymentId, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentRecipient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentRecipient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.paymentType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rawPaymentId = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.userPaymentId = UserPaymentId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentRecipient {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.UZERO,
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
      paymentType: isSet(object.paymentType) ? paymentRecipient_PaymentTypeFromJSON(object.paymentType) : 0,
      rawPaymentId: isSet(object.rawPaymentId) ? bytesFromBase64(object.rawPaymentId) : new Uint8Array(0),
      userPaymentId: isSet(object.userPaymentId) ? UserPaymentId.fromJSON(object.userPaymentId) : undefined,
    };
  },

  toJSON(message: PaymentRecipient): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (!message.amount.equals(Long.UZERO)) {
      obj.amount = (message.amount || Long.UZERO).toString();
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    if (message.paymentType !== 0) {
      obj.paymentType = paymentRecipient_PaymentTypeToJSON(message.paymentType);
    }
    if (message.rawPaymentId.length !== 0) {
      obj.rawPaymentId = base64FromBytes(message.rawPaymentId);
    }
    if (message.userPaymentId !== undefined) {
      obj.userPaymentId = UserPaymentId.toJSON(message.userPaymentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentRecipient>, I>>(base?: I): PaymentRecipient {
    return PaymentRecipient.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentRecipient>, I>>(object: I): PaymentRecipient {
    const message = createBasePaymentRecipient();
    message.address = object.address ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.UZERO;
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    message.paymentType = object.paymentType ?? 0;
    message.rawPaymentId = object.rawPaymentId ?? new Uint8Array(0);
    message.userPaymentId = (object.userPaymentId !== undefined && object.userPaymentId !== null)
      ? UserPaymentId.fromPartial(object.userPaymentId)
      : undefined;
    return message;
  },
};

function createBaseTransferResponse(): TransferResponse {
  return { results: [] };
}

export const TransferResponse: MessageFns<TransferResponse> = {
  encode(message: TransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      TransferResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(TransferResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => TransferResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransferResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => TransferResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferResponse>, I>>(base?: I): TransferResponse {
    return TransferResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferResponse>, I>>(object: I): TransferResponse {
    const message = createBaseTransferResponse();
    message.results = object.results?.map((e) => TransferResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSendShaAtomicSwapResponse(): SendShaAtomicSwapResponse {
  return { transactionId: Long.UZERO, preImage: "", outputHash: "", isSuccess: false, failureMessage: "" };
}

export const SendShaAtomicSwapResponse: MessageFns<SendShaAtomicSwapResponse> = {
  encode(message: SendShaAtomicSwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.transactionId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.transactionId.toString());
    }
    if (message.preImage !== "") {
      writer.uint32(18).string(message.preImage);
    }
    if (message.outputHash !== "") {
      writer.uint32(26).string(message.outputHash);
    }
    if (message.isSuccess !== false) {
      writer.uint32(32).bool(message.isSuccess);
    }
    if (message.failureMessage !== "") {
      writer.uint32(42).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendShaAtomicSwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendShaAtomicSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preImage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outputHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendShaAtomicSwapResponse {
    return {
      transactionId: isSet(object.transactionId) ? Long.fromValue(object.transactionId) : Long.UZERO,
      preImage: isSet(object.preImage) ? globalThis.String(object.preImage) : "",
      outputHash: isSet(object.outputHash) ? globalThis.String(object.outputHash) : "",
      isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: SendShaAtomicSwapResponse): unknown {
    const obj: any = {};
    if (!message.transactionId.equals(Long.UZERO)) {
      obj.transactionId = (message.transactionId || Long.UZERO).toString();
    }
    if (message.preImage !== "") {
      obj.preImage = message.preImage;
    }
    if (message.outputHash !== "") {
      obj.outputHash = message.outputHash;
    }
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendShaAtomicSwapResponse>, I>>(base?: I): SendShaAtomicSwapResponse {
    return SendShaAtomicSwapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendShaAtomicSwapResponse>, I>>(object: I): SendShaAtomicSwapResponse {
    const message = createBaseSendShaAtomicSwapResponse();
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? Long.fromValue(object.transactionId)
      : Long.UZERO;
    message.preImage = object.preImage ?? "";
    message.outputHash = object.outputHash ?? "";
    message.isSuccess = object.isSuccess ?? false;
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

function createBaseCreateBurnTransactionResponse(): CreateBurnTransactionResponse {
  return {
    transactionId: Long.UZERO,
    isSuccess: false,
    failureMessage: "",
    commitment: new Uint8Array(0),
    ownershipProof: undefined,
    rangeProof: new Uint8Array(0),
    reciprocalClaimPublicKey: new Uint8Array(0),
  };
}

export const CreateBurnTransactionResponse: MessageFns<CreateBurnTransactionResponse> = {
  encode(message: CreateBurnTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.transactionId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.transactionId.toString());
    }
    if (message.isSuccess !== false) {
      writer.uint32(16).bool(message.isSuccess);
    }
    if (message.failureMessage !== "") {
      writer.uint32(26).string(message.failureMessage);
    }
    if (message.commitment.length !== 0) {
      writer.uint32(34).bytes(message.commitment);
    }
    if (message.ownershipProof !== undefined) {
      CommitmentSignature.encode(message.ownershipProof, writer.uint32(42).fork()).join();
    }
    if (message.rangeProof.length !== 0) {
      writer.uint32(50).bytes(message.rangeProof);
    }
    if (message.reciprocalClaimPublicKey.length !== 0) {
      writer.uint32(58).bytes(message.reciprocalClaimPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBurnTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBurnTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commitment = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ownershipProof = CommitmentSignature.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rangeProof = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.reciprocalClaimPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBurnTransactionResponse {
    return {
      transactionId: isSet(object.transactionId) ? Long.fromValue(object.transactionId) : Long.UZERO,
      isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
      commitment: isSet(object.commitment) ? bytesFromBase64(object.commitment) : new Uint8Array(0),
      ownershipProof: isSet(object.ownershipProof) ? CommitmentSignature.fromJSON(object.ownershipProof) : undefined,
      rangeProof: isSet(object.rangeProof) ? bytesFromBase64(object.rangeProof) : new Uint8Array(0),
      reciprocalClaimPublicKey: isSet(object.reciprocalClaimPublicKey)
        ? bytesFromBase64(object.reciprocalClaimPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CreateBurnTransactionResponse): unknown {
    const obj: any = {};
    if (!message.transactionId.equals(Long.UZERO)) {
      obj.transactionId = (message.transactionId || Long.UZERO).toString();
    }
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    if (message.commitment.length !== 0) {
      obj.commitment = base64FromBytes(message.commitment);
    }
    if (message.ownershipProof !== undefined) {
      obj.ownershipProof = CommitmentSignature.toJSON(message.ownershipProof);
    }
    if (message.rangeProof.length !== 0) {
      obj.rangeProof = base64FromBytes(message.rangeProof);
    }
    if (message.reciprocalClaimPublicKey.length !== 0) {
      obj.reciprocalClaimPublicKey = base64FromBytes(message.reciprocalClaimPublicKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBurnTransactionResponse>, I>>(base?: I): CreateBurnTransactionResponse {
    return CreateBurnTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBurnTransactionResponse>, I>>(
    object: I,
  ): CreateBurnTransactionResponse {
    const message = createBaseCreateBurnTransactionResponse();
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? Long.fromValue(object.transactionId)
      : Long.UZERO;
    message.isSuccess = object.isSuccess ?? false;
    message.failureMessage = object.failureMessage ?? "";
    message.commitment = object.commitment ?? new Uint8Array(0);
    message.ownershipProof = (object.ownershipProof !== undefined && object.ownershipProof !== null)
      ? CommitmentSignature.fromPartial(object.ownershipProof)
      : undefined;
    message.rangeProof = object.rangeProof ?? new Uint8Array(0);
    message.reciprocalClaimPublicKey = object.reciprocalClaimPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransferResult(): TransferResult {
  return { address: "", transactionId: Long.UZERO, isSuccess: false, failureMessage: "", transactionInfo: undefined };
}

export const TransferResult: MessageFns<TransferResult> = {
  encode(message: TransferResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (!message.transactionId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.transactionId.toString());
    }
    if (message.isSuccess !== false) {
      writer.uint32(24).bool(message.isSuccess);
    }
    if (message.failureMessage !== "") {
      writer.uint32(34).string(message.failureMessage);
    }
    if (message.transactionInfo !== undefined) {
      TransactionInfo.encode(message.transactionInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.transactionId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.transactionInfo = TransactionInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferResult {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      transactionId: isSet(object.transactionId) ? Long.fromValue(object.transactionId) : Long.UZERO,
      isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
      transactionInfo: isSet(object.transactionInfo) ? TransactionInfo.fromJSON(object.transactionInfo) : undefined,
    };
  },

  toJSON(message: TransferResult): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (!message.transactionId.equals(Long.UZERO)) {
      obj.transactionId = (message.transactionId || Long.UZERO).toString();
    }
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    if (message.transactionInfo !== undefined) {
      obj.transactionInfo = TransactionInfo.toJSON(message.transactionInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferResult>, I>>(base?: I): TransferResult {
    return TransferResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferResult>, I>>(object: I): TransferResult {
    const message = createBaseTransferResult();
    message.address = object.address ?? "";
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? Long.fromValue(object.transactionId)
      : Long.UZERO;
    message.isSuccess = object.isSuccess ?? false;
    message.failureMessage = object.failureMessage ?? "";
    message.transactionInfo = (object.transactionInfo !== undefined && object.transactionInfo !== null)
      ? TransactionInfo.fromPartial(object.transactionInfo)
      : undefined;
    return message;
  },
};

function createBaseClaimShaAtomicSwapRequest(): ClaimShaAtomicSwapRequest {
  return { output: "", preImage: "", feePerGram: Long.UZERO };
}

export const ClaimShaAtomicSwapRequest: MessageFns<ClaimShaAtomicSwapRequest> = {
  encode(message: ClaimShaAtomicSwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.output !== "") {
      writer.uint32(10).string(message.output);
    }
    if (message.preImage !== "") {
      writer.uint32(18).string(message.preImage);
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.feePerGram.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimShaAtomicSwapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimShaAtomicSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.output = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preImage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimShaAtomicSwapRequest {
    return {
      output: isSet(object.output) ? globalThis.String(object.output) : "",
      preImage: isSet(object.preImage) ? globalThis.String(object.preImage) : "",
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
    };
  },

  toJSON(message: ClaimShaAtomicSwapRequest): unknown {
    const obj: any = {};
    if (message.output !== "") {
      obj.output = message.output;
    }
    if (message.preImage !== "") {
      obj.preImage = message.preImage;
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimShaAtomicSwapRequest>, I>>(base?: I): ClaimShaAtomicSwapRequest {
    return ClaimShaAtomicSwapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimShaAtomicSwapRequest>, I>>(object: I): ClaimShaAtomicSwapRequest {
    const message = createBaseClaimShaAtomicSwapRequest();
    message.output = object.output ?? "";
    message.preImage = object.preImage ?? "";
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    return message;
  },
};

function createBaseClaimShaAtomicSwapResponse(): ClaimShaAtomicSwapResponse {
  return { results: undefined };
}

export const ClaimShaAtomicSwapResponse: MessageFns<ClaimShaAtomicSwapResponse> = {
  encode(message: ClaimShaAtomicSwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.results !== undefined) {
      TransferResult.encode(message.results, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimShaAtomicSwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimShaAtomicSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results = TransferResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimShaAtomicSwapResponse {
    return { results: isSet(object.results) ? TransferResult.fromJSON(object.results) : undefined };
  },

  toJSON(message: ClaimShaAtomicSwapResponse): unknown {
    const obj: any = {};
    if (message.results !== undefined) {
      obj.results = TransferResult.toJSON(message.results);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimShaAtomicSwapResponse>, I>>(base?: I): ClaimShaAtomicSwapResponse {
    return ClaimShaAtomicSwapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimShaAtomicSwapResponse>, I>>(object: I): ClaimShaAtomicSwapResponse {
    const message = createBaseClaimShaAtomicSwapResponse();
    message.results = (object.results !== undefined && object.results !== null)
      ? TransferResult.fromPartial(object.results)
      : undefined;
    return message;
  },
};

function createBaseClaimHtlcRefundRequest(): ClaimHtlcRefundRequest {
  return { outputHash: "", feePerGram: Long.UZERO };
}

export const ClaimHtlcRefundRequest: MessageFns<ClaimHtlcRefundRequest> = {
  encode(message: ClaimHtlcRefundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputHash !== "") {
      writer.uint32(10).string(message.outputHash);
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.feePerGram.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimHtlcRefundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimHtlcRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimHtlcRefundRequest {
    return {
      outputHash: isSet(object.outputHash) ? globalThis.String(object.outputHash) : "",
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
    };
  },

  toJSON(message: ClaimHtlcRefundRequest): unknown {
    const obj: any = {};
    if (message.outputHash !== "") {
      obj.outputHash = message.outputHash;
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimHtlcRefundRequest>, I>>(base?: I): ClaimHtlcRefundRequest {
    return ClaimHtlcRefundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimHtlcRefundRequest>, I>>(object: I): ClaimHtlcRefundRequest {
    const message = createBaseClaimHtlcRefundRequest();
    message.outputHash = object.outputHash ?? "";
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    return message;
  },
};

function createBaseClaimHtlcRefundResponse(): ClaimHtlcRefundResponse {
  return { results: undefined };
}

export const ClaimHtlcRefundResponse: MessageFns<ClaimHtlcRefundResponse> = {
  encode(message: ClaimHtlcRefundResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.results !== undefined) {
      TransferResult.encode(message.results, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimHtlcRefundResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimHtlcRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results = TransferResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimHtlcRefundResponse {
    return { results: isSet(object.results) ? TransferResult.fromJSON(object.results) : undefined };
  },

  toJSON(message: ClaimHtlcRefundResponse): unknown {
    const obj: any = {};
    if (message.results !== undefined) {
      obj.results = TransferResult.toJSON(message.results);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimHtlcRefundResponse>, I>>(base?: I): ClaimHtlcRefundResponse {
    return ClaimHtlcRefundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimHtlcRefundResponse>, I>>(object: I): ClaimHtlcRefundResponse {
    const message = createBaseClaimHtlcRefundResponse();
    message.results = (object.results !== undefined && object.results !== null)
      ? TransferResult.fromPartial(object.results)
      : undefined;
    return message;
  },
};

function createBaseGetTransactionInfoRequest(): GetTransactionInfoRequest {
  return { transactionIds: [] };
}

export const GetTransactionInfoRequest: MessageFns<GetTransactionInfoRequest> = {
  encode(message: GetTransactionInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.transactionIds) {
      writer.uint64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.transactionIds.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.transactionIds.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionInfoRequest {
    return {
      transactionIds: globalThis.Array.isArray(object?.transactionIds)
        ? object.transactionIds.map((e: any) => Long.fromValue(e))
        : [],
    };
  },

  toJSON(message: GetTransactionInfoRequest): unknown {
    const obj: any = {};
    if (message.transactionIds?.length) {
      obj.transactionIds = message.transactionIds.map((e) => (e || Long.UZERO).toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionInfoRequest>, I>>(base?: I): GetTransactionInfoRequest {
    return GetTransactionInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionInfoRequest>, I>>(object: I): GetTransactionInfoRequest {
    const message = createBaseGetTransactionInfoRequest();
    message.transactionIds = object.transactionIds?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseGetTransactionInfoResponse(): GetTransactionInfoResponse {
  return { transactions: [] };
}

export const GetTransactionInfoResponse: MessageFns<GetTransactionInfoResponse> = {
  encode(message: GetTransactionInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactions) {
      TransactionInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactions.push(TransactionInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionInfoResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TransactionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetTransactionInfoResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TransactionInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionInfoResponse>, I>>(base?: I): GetTransactionInfoResponse {
    return GetTransactionInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionInfoResponse>, I>>(object: I): GetTransactionInfoResponse {
    const message = createBaseGetTransactionInfoResponse();
    message.transactions = object.transactions?.map((e) => TransactionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionInfo(): TransactionInfo {
  return {
    txId: Long.UZERO,
    sourceAddress: new Uint8Array(0),
    destAddress: new Uint8Array(0),
    status: 0,
    direction: 0,
    amount: Long.UZERO,
    fee: Long.UZERO,
    isCancelled: false,
    excessSig: new Uint8Array(0),
    timestamp: Long.UZERO,
    rawPaymentId: new Uint8Array(0),
    minedInBlockHeight: Long.UZERO,
    userPaymentId: new Uint8Array(0),
    inputCommitments: [],
    outputCommitments: [],
    paymentReferencesSent: [],
    paymentReferencesReceived: [],
    paymentReferencesChange: [],
  };
}

export const TransactionInfo: MessageFns<TransactionInfo> = {
  encode(message: TransactionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.txId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.txId.toString());
    }
    if (message.sourceAddress.length !== 0) {
      writer.uint32(18).bytes(message.sourceAddress);
    }
    if (message.destAddress.length !== 0) {
      writer.uint32(26).bytes(message.destAddress);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.direction !== 0) {
      writer.uint32(40).int32(message.direction);
    }
    if (!message.amount.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.amount.toString());
    }
    if (!message.fee.equals(Long.UZERO)) {
      writer.uint32(56).uint64(message.fee.toString());
    }
    if (message.isCancelled !== false) {
      writer.uint32(64).bool(message.isCancelled);
    }
    if (message.excessSig.length !== 0) {
      writer.uint32(74).bytes(message.excessSig);
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      writer.uint32(80).uint64(message.timestamp.toString());
    }
    if (message.rawPaymentId.length !== 0) {
      writer.uint32(98).bytes(message.rawPaymentId);
    }
    if (!message.minedInBlockHeight.equals(Long.UZERO)) {
      writer.uint32(104).uint64(message.minedInBlockHeight.toString());
    }
    if (message.userPaymentId.length !== 0) {
      writer.uint32(114).bytes(message.userPaymentId);
    }
    for (const v of message.inputCommitments) {
      writer.uint32(122).bytes(v!);
    }
    for (const v of message.outputCommitments) {
      writer.uint32(130).bytes(v!);
    }
    for (const v of message.paymentReferencesSent) {
      writer.uint32(138).bytes(v!);
    }
    for (const v of message.paymentReferencesReceived) {
      writer.uint32(146).bytes(v!);
    }
    for (const v of message.paymentReferencesChange) {
      writer.uint32(154).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceAddress = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.amount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.fee = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isCancelled = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.excessSig = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.timestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.rawPaymentId = reader.bytes();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.minedInBlockHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.userPaymentId = reader.bytes();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.inputCommitments.push(reader.bytes());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.outputCommitments.push(reader.bytes());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.paymentReferencesSent.push(reader.bytes());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.paymentReferencesReceived.push(reader.bytes());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.paymentReferencesChange.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo {
    return {
      txId: isSet(object.txId) ? Long.fromValue(object.txId) : Long.UZERO,
      sourceAddress: isSet(object.sourceAddress) ? bytesFromBase64(object.sourceAddress) : new Uint8Array(0),
      destAddress: isSet(object.destAddress) ? bytesFromBase64(object.destAddress) : new Uint8Array(0),
      status: isSet(object.status) ? transactionStatusFromJSON(object.status) : 0,
      direction: isSet(object.direction) ? transactionDirectionFromJSON(object.direction) : 0,
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.UZERO,
      fee: isSet(object.fee) ? Long.fromValue(object.fee) : Long.UZERO,
      isCancelled: isSet(object.isCancelled) ? globalThis.Boolean(object.isCancelled) : false,
      excessSig: isSet(object.excessSig) ? bytesFromBase64(object.excessSig) : new Uint8Array(0),
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.UZERO,
      rawPaymentId: isSet(object.rawPaymentId) ? bytesFromBase64(object.rawPaymentId) : new Uint8Array(0),
      minedInBlockHeight: isSet(object.minedInBlockHeight) ? Long.fromValue(object.minedInBlockHeight) : Long.UZERO,
      userPaymentId: isSet(object.userPaymentId) ? bytesFromBase64(object.userPaymentId) : new Uint8Array(0),
      inputCommitments: globalThis.Array.isArray(object?.inputCommitments)
        ? object.inputCommitments.map((e: any) => bytesFromBase64(e))
        : [],
      outputCommitments: globalThis.Array.isArray(object?.outputCommitments)
        ? object.outputCommitments.map((e: any) => bytesFromBase64(e))
        : [],
      paymentReferencesSent: globalThis.Array.isArray(object?.paymentReferencesSent)
        ? object.paymentReferencesSent.map((e: any) => bytesFromBase64(e))
        : [],
      paymentReferencesReceived: globalThis.Array.isArray(object?.paymentReferencesReceived)
        ? object.paymentReferencesReceived.map((e: any) => bytesFromBase64(e))
        : [],
      paymentReferencesChange: globalThis.Array.isArray(object?.paymentReferencesChange)
        ? object.paymentReferencesChange.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: TransactionInfo): unknown {
    const obj: any = {};
    if (!message.txId.equals(Long.UZERO)) {
      obj.txId = (message.txId || Long.UZERO).toString();
    }
    if (message.sourceAddress.length !== 0) {
      obj.sourceAddress = base64FromBytes(message.sourceAddress);
    }
    if (message.destAddress.length !== 0) {
      obj.destAddress = base64FromBytes(message.destAddress);
    }
    if (message.status !== 0) {
      obj.status = transactionStatusToJSON(message.status);
    }
    if (message.direction !== 0) {
      obj.direction = transactionDirectionToJSON(message.direction);
    }
    if (!message.amount.equals(Long.UZERO)) {
      obj.amount = (message.amount || Long.UZERO).toString();
    }
    if (!message.fee.equals(Long.UZERO)) {
      obj.fee = (message.fee || Long.UZERO).toString();
    }
    if (message.isCancelled !== false) {
      obj.isCancelled = message.isCancelled;
    }
    if (message.excessSig.length !== 0) {
      obj.excessSig = base64FromBytes(message.excessSig);
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      obj.timestamp = (message.timestamp || Long.UZERO).toString();
    }
    if (message.rawPaymentId.length !== 0) {
      obj.rawPaymentId = base64FromBytes(message.rawPaymentId);
    }
    if (!message.minedInBlockHeight.equals(Long.UZERO)) {
      obj.minedInBlockHeight = (message.minedInBlockHeight || Long.UZERO).toString();
    }
    if (message.userPaymentId.length !== 0) {
      obj.userPaymentId = base64FromBytes(message.userPaymentId);
    }
    if (message.inputCommitments?.length) {
      obj.inputCommitments = message.inputCommitments.map((e) => base64FromBytes(e));
    }
    if (message.outputCommitments?.length) {
      obj.outputCommitments = message.outputCommitments.map((e) => base64FromBytes(e));
    }
    if (message.paymentReferencesSent?.length) {
      obj.paymentReferencesSent = message.paymentReferencesSent.map((e) => base64FromBytes(e));
    }
    if (message.paymentReferencesReceived?.length) {
      obj.paymentReferencesReceived = message.paymentReferencesReceived.map((e) => base64FromBytes(e));
    }
    if (message.paymentReferencesChange?.length) {
      obj.paymentReferencesChange = message.paymentReferencesChange.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionInfo>, I>>(base?: I): TransactionInfo {
    return TransactionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionInfo>, I>>(object: I): TransactionInfo {
    const message = createBaseTransactionInfo();
    message.txId = (object.txId !== undefined && object.txId !== null) ? Long.fromValue(object.txId) : Long.UZERO;
    message.sourceAddress = object.sourceAddress ?? new Uint8Array(0);
    message.destAddress = object.destAddress ?? new Uint8Array(0);
    message.status = object.status ?? 0;
    message.direction = object.direction ?? 0;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.UZERO;
    message.fee = (object.fee !== undefined && object.fee !== null) ? Long.fromValue(object.fee) : Long.UZERO;
    message.isCancelled = object.isCancelled ?? false;
    message.excessSig = object.excessSig ?? new Uint8Array(0);
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.UZERO;
    message.rawPaymentId = object.rawPaymentId ?? new Uint8Array(0);
    message.minedInBlockHeight = (object.minedInBlockHeight !== undefined && object.minedInBlockHeight !== null)
      ? Long.fromValue(object.minedInBlockHeight)
      : Long.UZERO;
    message.userPaymentId = object.userPaymentId ?? new Uint8Array(0);
    message.inputCommitments = object.inputCommitments?.map((e) => e) || [];
    message.outputCommitments = object.outputCommitments?.map((e) => e) || [];
    message.paymentReferencesSent = object.paymentReferencesSent?.map((e) => e) || [];
    message.paymentReferencesReceived = object.paymentReferencesReceived?.map((e) => e) || [];
    message.paymentReferencesChange = object.paymentReferencesChange?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetCompletedTransactionsRequest(): GetCompletedTransactionsRequest {
  return { paymentId: undefined, blockHash: undefined, blockHeight: undefined };
}

export const GetCompletedTransactionsRequest: MessageFns<GetCompletedTransactionsRequest> = {
  encode(message: GetCompletedTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== undefined) {
      UserPaymentId.encode(message.paymentId, writer.uint32(10).fork()).join();
    }
    if (message.blockHash !== undefined) {
      BlockHashHex.encode(message.blockHash, writer.uint32(18).fork()).join();
    }
    if (message.blockHeight !== undefined) {
      BlockHeight.encode(message.blockHeight, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCompletedTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCompletedTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = UserPaymentId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockHash = BlockHashHex.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blockHeight = BlockHeight.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCompletedTransactionsRequest {
    return {
      paymentId: isSet(object.paymentId) ? UserPaymentId.fromJSON(object.paymentId) : undefined,
      blockHash: isSet(object.blockHash) ? BlockHashHex.fromJSON(object.blockHash) : undefined,
      blockHeight: isSet(object.blockHeight) ? BlockHeight.fromJSON(object.blockHeight) : undefined,
    };
  },

  toJSON(message: GetCompletedTransactionsRequest): unknown {
    const obj: any = {};
    if (message.paymentId !== undefined) {
      obj.paymentId = UserPaymentId.toJSON(message.paymentId);
    }
    if (message.blockHash !== undefined) {
      obj.blockHash = BlockHashHex.toJSON(message.blockHash);
    }
    if (message.blockHeight !== undefined) {
      obj.blockHeight = BlockHeight.toJSON(message.blockHeight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCompletedTransactionsRequest>, I>>(base?: I): GetCompletedTransactionsRequest {
    return GetCompletedTransactionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCompletedTransactionsRequest>, I>>(
    object: I,
  ): GetCompletedTransactionsRequest {
    const message = createBaseGetCompletedTransactionsRequest();
    message.paymentId = (object.paymentId !== undefined && object.paymentId !== null)
      ? UserPaymentId.fromPartial(object.paymentId)
      : undefined;
    message.blockHash = (object.blockHash !== undefined && object.blockHash !== null)
      ? BlockHashHex.fromPartial(object.blockHash)
      : undefined;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? BlockHeight.fromPartial(object.blockHeight)
      : undefined;
    return message;
  },
};

function createBaseBlockHashHex(): BlockHashHex {
  return { hash: "" };
}

export const BlockHashHex: MessageFns<BlockHashHex> = {
  encode(message: BlockHashHex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHashHex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHashHex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHashHex {
    return { hash: isSet(object.hash) ? globalThis.String(object.hash) : "" };
  },

  toJSON(message: BlockHashHex): unknown {
    const obj: any = {};
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockHashHex>, I>>(base?: I): BlockHashHex {
    return BlockHashHex.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockHashHex>, I>>(object: I): BlockHashHex {
    const message = createBaseBlockHashHex();
    message.hash = object.hash ?? "";
    return message;
  },
};

function createBaseGetCompletedTransactionsResponse(): GetCompletedTransactionsResponse {
  return { transaction: undefined };
}

export const GetCompletedTransactionsResponse: MessageFns<GetCompletedTransactionsResponse> = {
  encode(message: GetCompletedTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      TransactionInfo.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCompletedTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCompletedTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = TransactionInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCompletedTransactionsResponse {
    return { transaction: isSet(object.transaction) ? TransactionInfo.fromJSON(object.transaction) : undefined };
  },

  toJSON(message: GetCompletedTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = TransactionInfo.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCompletedTransactionsResponse>, I>>(
    base?: I,
  ): GetCompletedTransactionsResponse {
    return GetCompletedTransactionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCompletedTransactionsResponse>, I>>(
    object: I,
  ): GetCompletedTransactionsResponse {
    const message = createBaseGetCompletedTransactionsResponse();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? TransactionInfo.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseGetBalanceRequest(): GetBalanceRequest {
  return { paymentId: undefined };
}

export const GetBalanceRequest: MessageFns<GetBalanceRequest> = {
  encode(message: GetBalanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== undefined) {
      UserPaymentId.encode(message.paymentId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBalanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = UserPaymentId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBalanceRequest {
    return { paymentId: isSet(object.paymentId) ? UserPaymentId.fromJSON(object.paymentId) : undefined };
  },

  toJSON(message: GetBalanceRequest): unknown {
    const obj: any = {};
    if (message.paymentId !== undefined) {
      obj.paymentId = UserPaymentId.toJSON(message.paymentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBalanceRequest>, I>>(base?: I): GetBalanceRequest {
    return GetBalanceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBalanceRequest>, I>>(object: I): GetBalanceRequest {
    const message = createBaseGetBalanceRequest();
    message.paymentId = (object.paymentId !== undefined && object.paymentId !== null)
      ? UserPaymentId.fromPartial(object.paymentId)
      : undefined;
    return message;
  },
};

function createBaseUserPaymentId(): UserPaymentId {
  return { u256: new Uint8Array(0), utf8String: "", userBytes: new Uint8Array(0) };
}

export const UserPaymentId: MessageFns<UserPaymentId> = {
  encode(message: UserPaymentId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.u256.length !== 0) {
      writer.uint32(10).bytes(message.u256);
    }
    if (message.utf8String !== "") {
      writer.uint32(18).string(message.utf8String);
    }
    if (message.userBytes.length !== 0) {
      writer.uint32(26).bytes(message.userBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserPaymentId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserPaymentId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.u256 = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utf8String = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserPaymentId {
    return {
      u256: isSet(object.u256) ? bytesFromBase64(object.u256) : new Uint8Array(0),
      utf8String: isSet(object.utf8String) ? globalThis.String(object.utf8String) : "",
      userBytes: isSet(object.userBytes) ? bytesFromBase64(object.userBytes) : new Uint8Array(0),
    };
  },

  toJSON(message: UserPaymentId): unknown {
    const obj: any = {};
    if (message.u256.length !== 0) {
      obj.u256 = base64FromBytes(message.u256);
    }
    if (message.utf8String !== "") {
      obj.utf8String = message.utf8String;
    }
    if (message.userBytes.length !== 0) {
      obj.userBytes = base64FromBytes(message.userBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserPaymentId>, I>>(base?: I): UserPaymentId {
    return UserPaymentId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserPaymentId>, I>>(object: I): UserPaymentId {
    const message = createBaseUserPaymentId();
    message.u256 = object.u256 ?? new Uint8Array(0);
    message.utf8String = object.utf8String ?? "";
    message.userBytes = object.userBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetStateRequest(): GetStateRequest {
  return {};
}

export const GetStateRequest: MessageFns<GetStateRequest> = {
  encode(_: GetStateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetStateRequest {
    return {};
  },

  toJSON(_: GetStateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStateRequest>, I>>(base?: I): GetStateRequest {
    return GetStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStateRequest>, I>>(_: I): GetStateRequest {
    const message = createBaseGetStateRequest();
    return message;
  },
};

function createBaseGetBalanceResponse(): GetBalanceResponse {
  return {
    availableBalance: Long.UZERO,
    pendingIncomingBalance: Long.UZERO,
    pendingOutgoingBalance: Long.UZERO,
    timelockedBalance: Long.UZERO,
  };
}

export const GetBalanceResponse: MessageFns<GetBalanceResponse> = {
  encode(message: GetBalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.availableBalance.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.availableBalance.toString());
    }
    if (!message.pendingIncomingBalance.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.pendingIncomingBalance.toString());
    }
    if (!message.pendingOutgoingBalance.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.pendingOutgoingBalance.toString());
    }
    if (!message.timelockedBalance.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.timelockedBalance.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBalanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.availableBalance = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pendingIncomingBalance = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pendingOutgoingBalance = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timelockedBalance = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBalanceResponse {
    return {
      availableBalance: isSet(object.availableBalance) ? Long.fromValue(object.availableBalance) : Long.UZERO,
      pendingIncomingBalance: isSet(object.pendingIncomingBalance)
        ? Long.fromValue(object.pendingIncomingBalance)
        : Long.UZERO,
      pendingOutgoingBalance: isSet(object.pendingOutgoingBalance)
        ? Long.fromValue(object.pendingOutgoingBalance)
        : Long.UZERO,
      timelockedBalance: isSet(object.timelockedBalance) ? Long.fromValue(object.timelockedBalance) : Long.UZERO,
    };
  },

  toJSON(message: GetBalanceResponse): unknown {
    const obj: any = {};
    if (!message.availableBalance.equals(Long.UZERO)) {
      obj.availableBalance = (message.availableBalance || Long.UZERO).toString();
    }
    if (!message.pendingIncomingBalance.equals(Long.UZERO)) {
      obj.pendingIncomingBalance = (message.pendingIncomingBalance || Long.UZERO).toString();
    }
    if (!message.pendingOutgoingBalance.equals(Long.UZERO)) {
      obj.pendingOutgoingBalance = (message.pendingOutgoingBalance || Long.UZERO).toString();
    }
    if (!message.timelockedBalance.equals(Long.UZERO)) {
      obj.timelockedBalance = (message.timelockedBalance || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBalanceResponse>, I>>(base?: I): GetBalanceResponse {
    return GetBalanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBalanceResponse>, I>>(object: I): GetBalanceResponse {
    const message = createBaseGetBalanceResponse();
    message.availableBalance = (object.availableBalance !== undefined && object.availableBalance !== null)
      ? Long.fromValue(object.availableBalance)
      : Long.UZERO;
    message.pendingIncomingBalance =
      (object.pendingIncomingBalance !== undefined && object.pendingIncomingBalance !== null)
        ? Long.fromValue(object.pendingIncomingBalance)
        : Long.UZERO;
    message.pendingOutgoingBalance =
      (object.pendingOutgoingBalance !== undefined && object.pendingOutgoingBalance !== null)
        ? Long.fromValue(object.pendingOutgoingBalance)
        : Long.UZERO;
    message.timelockedBalance = (object.timelockedBalance !== undefined && object.timelockedBalance !== null)
      ? Long.fromValue(object.timelockedBalance)
      : Long.UZERO;
    return message;
  },
};

function createBaseGetStateResponse(): GetStateResponse {
  return { scannedHeight: Long.UZERO, balance: undefined, network: undefined, hasDoneInitialValidation: false };
}

export const GetStateResponse: MessageFns<GetStateResponse> = {
  encode(message: GetStateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.scannedHeight.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.scannedHeight.toString());
    }
    if (message.balance !== undefined) {
      GetBalanceResponse.encode(message.balance, writer.uint32(18).fork()).join();
    }
    if (message.network !== undefined) {
      NetworkStatusResponse.encode(message.network, writer.uint32(26).fork()).join();
    }
    if (message.hasDoneInitialValidation !== false) {
      writer.uint32(32).bool(message.hasDoneInitialValidation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.scannedHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.balance = GetBalanceResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.network = NetworkStatusResponse.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.hasDoneInitialValidation = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStateResponse {
    return {
      scannedHeight: isSet(object.scannedHeight) ? Long.fromValue(object.scannedHeight) : Long.UZERO,
      balance: isSet(object.balance) ? GetBalanceResponse.fromJSON(object.balance) : undefined,
      network: isSet(object.network) ? NetworkStatusResponse.fromJSON(object.network) : undefined,
      hasDoneInitialValidation: isSet(object.hasDoneInitialValidation)
        ? globalThis.Boolean(object.hasDoneInitialValidation)
        : false,
    };
  },

  toJSON(message: GetStateResponse): unknown {
    const obj: any = {};
    if (!message.scannedHeight.equals(Long.UZERO)) {
      obj.scannedHeight = (message.scannedHeight || Long.UZERO).toString();
    }
    if (message.balance !== undefined) {
      obj.balance = GetBalanceResponse.toJSON(message.balance);
    }
    if (message.network !== undefined) {
      obj.network = NetworkStatusResponse.toJSON(message.network);
    }
    if (message.hasDoneInitialValidation !== false) {
      obj.hasDoneInitialValidation = message.hasDoneInitialValidation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStateResponse>, I>>(base?: I): GetStateResponse {
    return GetStateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStateResponse>, I>>(object: I): GetStateResponse {
    const message = createBaseGetStateResponse();
    message.scannedHeight = (object.scannedHeight !== undefined && object.scannedHeight !== null)
      ? Long.fromValue(object.scannedHeight)
      : Long.UZERO;
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? GetBalanceResponse.fromPartial(object.balance)
      : undefined;
    message.network = (object.network !== undefined && object.network !== null)
      ? NetworkStatusResponse.fromPartial(object.network)
      : undefined;
    message.hasDoneInitialValidation = object.hasDoneInitialValidation ?? false;
    return message;
  },
};

function createBaseGetUnspentAmountsResponse(): GetUnspentAmountsResponse {
  return { amount: [] };
}

export const GetUnspentAmountsResponse: MessageFns<GetUnspentAmountsResponse> = {
  encode(message: GetUnspentAmountsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.amount) {
      writer.uint64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUnspentAmountsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUnspentAmountsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.amount.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.amount.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUnspentAmountsResponse {
    return { amount: globalThis.Array.isArray(object?.amount) ? object.amount.map((e: any) => Long.fromValue(e)) : [] };
  },

  toJSON(message: GetUnspentAmountsResponse): unknown {
    const obj: any = {};
    if (message.amount?.length) {
      obj.amount = message.amount.map((e) => (e || Long.UZERO).toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUnspentAmountsResponse>, I>>(base?: I): GetUnspentAmountsResponse {
    return GetUnspentAmountsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUnspentAmountsResponse>, I>>(object: I): GetUnspentAmountsResponse {
    const message = createBaseGetUnspentAmountsResponse();
    message.amount = object.amount?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseCoinSplitRequest(): CoinSplitRequest {
  return {
    amountPerSplit: Long.UZERO,
    splitCount: Long.UZERO,
    feePerGram: Long.UZERO,
    lockHeight: Long.UZERO,
    paymentId: new Uint8Array(0),
  };
}

export const CoinSplitRequest: MessageFns<CoinSplitRequest> = {
  encode(message: CoinSplitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.amountPerSplit.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.amountPerSplit.toString());
    }
    if (!message.splitCount.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.splitCount.toString());
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.feePerGram.toString());
    }
    if (!message.lockHeight.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.lockHeight.toString());
    }
    if (message.paymentId.length !== 0) {
      writer.uint32(50).bytes(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoinSplitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoinSplitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.amountPerSplit = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.splitCount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lockHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.paymentId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoinSplitRequest {
    return {
      amountPerSplit: isSet(object.amountPerSplit) ? Long.fromValue(object.amountPerSplit) : Long.UZERO,
      splitCount: isSet(object.splitCount) ? Long.fromValue(object.splitCount) : Long.UZERO,
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
      lockHeight: isSet(object.lockHeight) ? Long.fromValue(object.lockHeight) : Long.UZERO,
      paymentId: isSet(object.paymentId) ? bytesFromBase64(object.paymentId) : new Uint8Array(0),
    };
  },

  toJSON(message: CoinSplitRequest): unknown {
    const obj: any = {};
    if (!message.amountPerSplit.equals(Long.UZERO)) {
      obj.amountPerSplit = (message.amountPerSplit || Long.UZERO).toString();
    }
    if (!message.splitCount.equals(Long.UZERO)) {
      obj.splitCount = (message.splitCount || Long.UZERO).toString();
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    if (!message.lockHeight.equals(Long.UZERO)) {
      obj.lockHeight = (message.lockHeight || Long.UZERO).toString();
    }
    if (message.paymentId.length !== 0) {
      obj.paymentId = base64FromBytes(message.paymentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CoinSplitRequest>, I>>(base?: I): CoinSplitRequest {
    return CoinSplitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CoinSplitRequest>, I>>(object: I): CoinSplitRequest {
    const message = createBaseCoinSplitRequest();
    message.amountPerSplit = (object.amountPerSplit !== undefined && object.amountPerSplit !== null)
      ? Long.fromValue(object.amountPerSplit)
      : Long.UZERO;
    message.splitCount = (object.splitCount !== undefined && object.splitCount !== null)
      ? Long.fromValue(object.splitCount)
      : Long.UZERO;
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    message.lockHeight = (object.lockHeight !== undefined && object.lockHeight !== null)
      ? Long.fromValue(object.lockHeight)
      : Long.UZERO;
    message.paymentId = object.paymentId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCoinSplitResponse(): CoinSplitResponse {
  return { txId: Long.UZERO };
}

export const CoinSplitResponse: MessageFns<CoinSplitResponse> = {
  encode(message: CoinSplitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.txId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.txId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoinSplitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoinSplitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoinSplitResponse {
    return { txId: isSet(object.txId) ? Long.fromValue(object.txId) : Long.UZERO };
  },

  toJSON(message: CoinSplitResponse): unknown {
    const obj: any = {};
    if (!message.txId.equals(Long.UZERO)) {
      obj.txId = (message.txId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CoinSplitResponse>, I>>(base?: I): CoinSplitResponse {
    return CoinSplitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CoinSplitResponse>, I>>(object: I): CoinSplitResponse {
    const message = createBaseCoinSplitResponse();
    message.txId = (object.txId !== undefined && object.txId !== null) ? Long.fromValue(object.txId) : Long.UZERO;
    return message;
  },
};

function createBaseImportUtxosRequest(): ImportUtxosRequest {
  return { outputs: [], paymentId: new Uint8Array(0) };
}

export const ImportUtxosRequest: MessageFns<ImportUtxosRequest> = {
  encode(message: ImportUtxosRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.outputs) {
      UnblindedOutput.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.paymentId.length !== 0) {
      writer.uint32(18).bytes(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportUtxosRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportUtxosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputs.push(UnblindedOutput.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportUtxosRequest {
    return {
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => UnblindedOutput.fromJSON(e))
        : [],
      paymentId: isSet(object.paymentId) ? bytesFromBase64(object.paymentId) : new Uint8Array(0),
    };
  },

  toJSON(message: ImportUtxosRequest): unknown {
    const obj: any = {};
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => UnblindedOutput.toJSON(e));
    }
    if (message.paymentId.length !== 0) {
      obj.paymentId = base64FromBytes(message.paymentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportUtxosRequest>, I>>(base?: I): ImportUtxosRequest {
    return ImportUtxosRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportUtxosRequest>, I>>(object: I): ImportUtxosRequest {
    const message = createBaseImportUtxosRequest();
    message.outputs = object.outputs?.map((e) => UnblindedOutput.fromPartial(e)) || [];
    message.paymentId = object.paymentId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseImportUtxosResponse(): ImportUtxosResponse {
  return { txIds: [] };
}

export const ImportUtxosResponse: MessageFns<ImportUtxosResponse> = {
  encode(message: ImportUtxosResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.txIds) {
      writer.uint64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportUtxosResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportUtxosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.txIds.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.txIds.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportUtxosResponse {
    return { txIds: globalThis.Array.isArray(object?.txIds) ? object.txIds.map((e: any) => Long.fromValue(e)) : [] };
  },

  toJSON(message: ImportUtxosResponse): unknown {
    const obj: any = {};
    if (message.txIds?.length) {
      obj.txIds = message.txIds.map((e) => (e || Long.UZERO).toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportUtxosResponse>, I>>(base?: I): ImportUtxosResponse {
    return ImportUtxosResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportUtxosResponse>, I>>(object: I): ImportUtxosResponse {
    const message = createBaseImportUtxosResponse();
    message.txIds = object.txIds?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseCreateTemplateRegistrationRequest(): CreateTemplateRegistrationRequest {
  return {
    feePerGram: Long.UZERO,
    templateName: "",
    templateVersion: 0,
    templateType: undefined,
    buildInfo: undefined,
    binarySha: new Uint8Array(0),
    binaryUrl: "",
    sidechainDeploymentKey: new Uint8Array(0),
  };
}

export const CreateTemplateRegistrationRequest: MessageFns<CreateTemplateRegistrationRequest> = {
  encode(message: CreateTemplateRegistrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.feePerGram.toString());
    }
    if (message.templateName !== "") {
      writer.uint32(18).string(message.templateName);
    }
    if (message.templateVersion !== 0) {
      writer.uint32(24).uint32(message.templateVersion);
    }
    if (message.templateType !== undefined) {
      TemplateType.encode(message.templateType, writer.uint32(34).fork()).join();
    }
    if (message.buildInfo !== undefined) {
      BuildInfo.encode(message.buildInfo, writer.uint32(42).fork()).join();
    }
    if (message.binarySha.length !== 0) {
      writer.uint32(50).bytes(message.binarySha);
    }
    if (message.binaryUrl !== "") {
      writer.uint32(58).string(message.binaryUrl);
    }
    if (message.sidechainDeploymentKey.length !== 0) {
      writer.uint32(66).bytes(message.sidechainDeploymentKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTemplateRegistrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTemplateRegistrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.templateName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.templateVersion = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.templateType = TemplateType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.buildInfo = BuildInfo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.binarySha = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.binaryUrl = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sidechainDeploymentKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTemplateRegistrationRequest {
    return {
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
      templateName: isSet(object.templateName) ? globalThis.String(object.templateName) : "",
      templateVersion: isSet(object.templateVersion) ? globalThis.Number(object.templateVersion) : 0,
      templateType: isSet(object.templateType) ? TemplateType.fromJSON(object.templateType) : undefined,
      buildInfo: isSet(object.buildInfo) ? BuildInfo.fromJSON(object.buildInfo) : undefined,
      binarySha: isSet(object.binarySha) ? bytesFromBase64(object.binarySha) : new Uint8Array(0),
      binaryUrl: isSet(object.binaryUrl) ? globalThis.String(object.binaryUrl) : "",
      sidechainDeploymentKey: isSet(object.sidechainDeploymentKey)
        ? bytesFromBase64(object.sidechainDeploymentKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CreateTemplateRegistrationRequest): unknown {
    const obj: any = {};
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    if (message.templateName !== "") {
      obj.templateName = message.templateName;
    }
    if (message.templateVersion !== 0) {
      obj.templateVersion = Math.round(message.templateVersion);
    }
    if (message.templateType !== undefined) {
      obj.templateType = TemplateType.toJSON(message.templateType);
    }
    if (message.buildInfo !== undefined) {
      obj.buildInfo = BuildInfo.toJSON(message.buildInfo);
    }
    if (message.binarySha.length !== 0) {
      obj.binarySha = base64FromBytes(message.binarySha);
    }
    if (message.binaryUrl !== "") {
      obj.binaryUrl = message.binaryUrl;
    }
    if (message.sidechainDeploymentKey.length !== 0) {
      obj.sidechainDeploymentKey = base64FromBytes(message.sidechainDeploymentKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTemplateRegistrationRequest>, I>>(
    base?: I,
  ): CreateTemplateRegistrationRequest {
    return CreateTemplateRegistrationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTemplateRegistrationRequest>, I>>(
    object: I,
  ): CreateTemplateRegistrationRequest {
    const message = createBaseCreateTemplateRegistrationRequest();
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    message.templateName = object.templateName ?? "";
    message.templateVersion = object.templateVersion ?? 0;
    message.templateType = (object.templateType !== undefined && object.templateType !== null)
      ? TemplateType.fromPartial(object.templateType)
      : undefined;
    message.buildInfo = (object.buildInfo !== undefined && object.buildInfo !== null)
      ? BuildInfo.fromPartial(object.buildInfo)
      : undefined;
    message.binarySha = object.binarySha ?? new Uint8Array(0);
    message.binaryUrl = object.binaryUrl ?? "";
    message.sidechainDeploymentKey = object.sidechainDeploymentKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCreateTemplateRegistrationResponse(): CreateTemplateRegistrationResponse {
  return { txId: Long.UZERO, templateAddress: new Uint8Array(0) };
}

export const CreateTemplateRegistrationResponse: MessageFns<CreateTemplateRegistrationResponse> = {
  encode(message: CreateTemplateRegistrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.txId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.txId.toString());
    }
    if (message.templateAddress.length !== 0) {
      writer.uint32(18).bytes(message.templateAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTemplateRegistrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTemplateRegistrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.templateAddress = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTemplateRegistrationResponse {
    return {
      txId: isSet(object.txId) ? Long.fromValue(object.txId) : Long.UZERO,
      templateAddress: isSet(object.templateAddress) ? bytesFromBase64(object.templateAddress) : new Uint8Array(0),
    };
  },

  toJSON(message: CreateTemplateRegistrationResponse): unknown {
    const obj: any = {};
    if (!message.txId.equals(Long.UZERO)) {
      obj.txId = (message.txId || Long.UZERO).toString();
    }
    if (message.templateAddress.length !== 0) {
      obj.templateAddress = base64FromBytes(message.templateAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTemplateRegistrationResponse>, I>>(
    base?: I,
  ): CreateTemplateRegistrationResponse {
    return CreateTemplateRegistrationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTemplateRegistrationResponse>, I>>(
    object: I,
  ): CreateTemplateRegistrationResponse {
    const message = createBaseCreateTemplateRegistrationResponse();
    message.txId = (object.txId !== undefined && object.txId !== null) ? Long.fromValue(object.txId) : Long.UZERO;
    message.templateAddress = object.templateAddress ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCancelTransactionRequest(): CancelTransactionRequest {
  return { txId: Long.UZERO };
}

export const CancelTransactionRequest: MessageFns<CancelTransactionRequest> = {
  encode(message: CancelTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.txId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.txId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTransactionRequest {
    return { txId: isSet(object.txId) ? Long.fromValue(object.txId) : Long.UZERO };
  },

  toJSON(message: CancelTransactionRequest): unknown {
    const obj: any = {};
    if (!message.txId.equals(Long.UZERO)) {
      obj.txId = (message.txId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelTransactionRequest>, I>>(base?: I): CancelTransactionRequest {
    return CancelTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelTransactionRequest>, I>>(object: I): CancelTransactionRequest {
    const message = createBaseCancelTransactionRequest();
    message.txId = (object.txId !== undefined && object.txId !== null) ? Long.fromValue(object.txId) : Long.UZERO;
    return message;
  },
};

function createBaseCancelTransactionResponse(): CancelTransactionResponse {
  return { isSuccess: false, failureMessage: "" };
}

export const CancelTransactionResponse: MessageFns<CancelTransactionResponse> = {
  encode(message: CancelTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isSuccess !== false) {
      writer.uint32(8).bool(message.isSuccess);
    }
    if (message.failureMessage !== "") {
      writer.uint32(18).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTransactionResponse {
    return {
      isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: CancelTransactionResponse): unknown {
    const obj: any = {};
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelTransactionResponse>, I>>(base?: I): CancelTransactionResponse {
    return CancelTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelTransactionResponse>, I>>(object: I): CancelTransactionResponse {
    const message = createBaseCancelTransactionResponse();
    message.isSuccess = object.isSuccess ?? false;
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

function createBaseRevalidateRequest(): RevalidateRequest {
  return {};
}

export const RevalidateRequest: MessageFns<RevalidateRequest> = {
  encode(_: RevalidateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevalidateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevalidateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RevalidateRequest {
    return {};
  },

  toJSON(_: RevalidateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RevalidateRequest>, I>>(base?: I): RevalidateRequest {
    return RevalidateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevalidateRequest>, I>>(_: I): RevalidateRequest {
    const message = createBaseRevalidateRequest();
    return message;
  },
};

function createBaseRevalidateResponse(): RevalidateResponse {
  return {};
}

export const RevalidateResponse: MessageFns<RevalidateResponse> = {
  encode(_: RevalidateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevalidateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevalidateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RevalidateResponse {
    return {};
  },

  toJSON(_: RevalidateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RevalidateResponse>, I>>(base?: I): RevalidateResponse {
    return RevalidateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevalidateResponse>, I>>(_: I): RevalidateResponse {
    const message = createBaseRevalidateResponse();
    return message;
  },
};

function createBaseValidateRequest(): ValidateRequest {
  return {};
}

export const ValidateRequest: MessageFns<ValidateRequest> = {
  encode(_: ValidateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ValidateRequest {
    return {};
  },

  toJSON(_: ValidateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateRequest>, I>>(base?: I): ValidateRequest {
    return ValidateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateRequest>, I>>(_: I): ValidateRequest {
    const message = createBaseValidateRequest();
    return message;
  },
};

function createBaseValidateResponse(): ValidateResponse {
  return {};
}

export const ValidateResponse: MessageFns<ValidateResponse> = {
  encode(_: ValidateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ValidateResponse {
    return {};
  },

  toJSON(_: ValidateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateResponse>, I>>(base?: I): ValidateResponse {
    return ValidateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateResponse>, I>>(_: I): ValidateResponse {
    const message = createBaseValidateResponse();
    return message;
  },
};

function createBaseSetBaseNodeResponse(): SetBaseNodeResponse {
  return {};
}

export const SetBaseNodeResponse: MessageFns<SetBaseNodeResponse> = {
  encode(_: SetBaseNodeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetBaseNodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetBaseNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SetBaseNodeResponse {
    return {};
  },

  toJSON(_: SetBaseNodeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SetBaseNodeResponse>, I>>(base?: I): SetBaseNodeResponse {
    return SetBaseNodeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetBaseNodeResponse>, I>>(_: I): SetBaseNodeResponse {
    const message = createBaseSetBaseNodeResponse();
    return message;
  },
};

function createBaseGetConnectivityRequest(): GetConnectivityRequest {
  return {};
}

export const GetConnectivityRequest: MessageFns<GetConnectivityRequest> = {
  encode(_: GetConnectivityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectivityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectivityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetConnectivityRequest {
    return {};
  },

  toJSON(_: GetConnectivityRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConnectivityRequest>, I>>(base?: I): GetConnectivityRequest {
    return GetConnectivityRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConnectivityRequest>, I>>(_: I): GetConnectivityRequest {
    const message = createBaseGetConnectivityRequest();
    return message;
  },
};

function createBaseCheckConnectivityResponse(): CheckConnectivityResponse {
  return { status: 0 };
}

export const CheckConnectivityResponse: MessageFns<CheckConnectivityResponse> = {
  encode(message: CheckConnectivityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckConnectivityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckConnectivityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckConnectivityResponse {
    return { status: isSet(object.status) ? checkConnectivityResponse_OnlineStatusFromJSON(object.status) : 0 };
  },

  toJSON(message: CheckConnectivityResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = checkConnectivityResponse_OnlineStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckConnectivityResponse>, I>>(base?: I): CheckConnectivityResponse {
    return CheckConnectivityResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckConnectivityResponse>, I>>(object: I): CheckConnectivityResponse {
    const message = createBaseCheckConnectivityResponse();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseTransactionEventRequest(): TransactionEventRequest {
  return {};
}

export const TransactionEventRequest: MessageFns<TransactionEventRequest> = {
  encode(_: TransactionEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TransactionEventRequest {
    return {};
  },

  toJSON(_: TransactionEventRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionEventRequest>, I>>(base?: I): TransactionEventRequest {
    return TransactionEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionEventRequest>, I>>(_: I): TransactionEventRequest {
    const message = createBaseTransactionEventRequest();
    return message;
  },
};

function createBaseTransactionEvent(): TransactionEvent {
  return {
    event: "",
    txId: "",
    sourceAddress: new Uint8Array(0),
    destAddress: new Uint8Array(0),
    status: "",
    direction: "",
    amount: Long.UZERO,
    rawPaymentId: new Uint8Array(0),
    userPaymentId: new Uint8Array(0),
  };
}

export const TransactionEvent: MessageFns<TransactionEvent> = {
  encode(message: TransactionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== "") {
      writer.uint32(10).string(message.event);
    }
    if (message.txId !== "") {
      writer.uint32(18).string(message.txId);
    }
    if (message.sourceAddress.length !== 0) {
      writer.uint32(26).bytes(message.sourceAddress);
    }
    if (message.destAddress.length !== 0) {
      writer.uint32(34).bytes(message.destAddress);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.direction !== "") {
      writer.uint32(50).string(message.direction);
    }
    if (!message.amount.equals(Long.UZERO)) {
      writer.uint32(56).uint64(message.amount.toString());
    }
    if (message.rawPaymentId.length !== 0) {
      writer.uint32(74).bytes(message.rawPaymentId);
    }
    if (message.userPaymentId.length !== 0) {
      writer.uint32(82).bytes(message.userPaymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destAddress = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.direction = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.amount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rawPaymentId = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.userPaymentId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEvent {
    return {
      event: isSet(object.event) ? globalThis.String(object.event) : "",
      txId: isSet(object.txId) ? globalThis.String(object.txId) : "",
      sourceAddress: isSet(object.sourceAddress) ? bytesFromBase64(object.sourceAddress) : new Uint8Array(0),
      destAddress: isSet(object.destAddress) ? bytesFromBase64(object.destAddress) : new Uint8Array(0),
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      direction: isSet(object.direction) ? globalThis.String(object.direction) : "",
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.UZERO,
      rawPaymentId: isSet(object.rawPaymentId) ? bytesFromBase64(object.rawPaymentId) : new Uint8Array(0),
      userPaymentId: isSet(object.userPaymentId) ? bytesFromBase64(object.userPaymentId) : new Uint8Array(0),
    };
  },

  toJSON(message: TransactionEvent): unknown {
    const obj: any = {};
    if (message.event !== "") {
      obj.event = message.event;
    }
    if (message.txId !== "") {
      obj.txId = message.txId;
    }
    if (message.sourceAddress.length !== 0) {
      obj.sourceAddress = base64FromBytes(message.sourceAddress);
    }
    if (message.destAddress.length !== 0) {
      obj.destAddress = base64FromBytes(message.destAddress);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.direction !== "") {
      obj.direction = message.direction;
    }
    if (!message.amount.equals(Long.UZERO)) {
      obj.amount = (message.amount || Long.UZERO).toString();
    }
    if (message.rawPaymentId.length !== 0) {
      obj.rawPaymentId = base64FromBytes(message.rawPaymentId);
    }
    if (message.userPaymentId.length !== 0) {
      obj.userPaymentId = base64FromBytes(message.userPaymentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionEvent>, I>>(base?: I): TransactionEvent {
    return TransactionEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionEvent>, I>>(object: I): TransactionEvent {
    const message = createBaseTransactionEvent();
    message.event = object.event ?? "";
    message.txId = object.txId ?? "";
    message.sourceAddress = object.sourceAddress ?? new Uint8Array(0);
    message.destAddress = object.destAddress ?? new Uint8Array(0);
    message.status = object.status ?? "";
    message.direction = object.direction ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.UZERO;
    message.rawPaymentId = object.rawPaymentId ?? new Uint8Array(0);
    message.userPaymentId = object.userPaymentId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransactionEventResponse(): TransactionEventResponse {
  return { transaction: undefined };
}

export const TransactionEventResponse: MessageFns<TransactionEventResponse> = {
  encode(message: TransactionEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      TransactionEvent.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = TransactionEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEventResponse {
    return { transaction: isSet(object.transaction) ? TransactionEvent.fromJSON(object.transaction) : undefined };
  },

  toJSON(message: TransactionEventResponse): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = TransactionEvent.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionEventResponse>, I>>(base?: I): TransactionEventResponse {
    return TransactionEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionEventResponse>, I>>(object: I): TransactionEventResponse {
    const message = createBaseTransactionEventResponse();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? TransactionEvent.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseRegisterValidatorNodeRequest(): RegisterValidatorNodeRequest {
  return {
    validatorNodePublicKey: new Uint8Array(0),
    validatorNodeSignature: undefined,
    validatorNodeClaimPublicKey: new Uint8Array(0),
    maxEpoch: Long.UZERO,
    feePerGram: Long.UZERO,
    paymentId: new Uint8Array(0),
    sidechainDeploymentKey: new Uint8Array(0),
  };
}

export const RegisterValidatorNodeRequest: MessageFns<RegisterValidatorNodeRequest> = {
  encode(message: RegisterValidatorNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorNodePublicKey.length !== 0) {
      writer.uint32(10).bytes(message.validatorNodePublicKey);
    }
    if (message.validatorNodeSignature !== undefined) {
      Signature.encode(message.validatorNodeSignature, writer.uint32(18).fork()).join();
    }
    if (message.validatorNodeClaimPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.validatorNodeClaimPublicKey);
    }
    if (!message.maxEpoch.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.maxEpoch.toString());
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.feePerGram.toString());
    }
    if (message.paymentId.length !== 0) {
      writer.uint32(50).bytes(message.paymentId);
    }
    if (message.sidechainDeploymentKey.length !== 0) {
      writer.uint32(58).bytes(message.sidechainDeploymentKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterValidatorNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterValidatorNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorNodePublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validatorNodeSignature = Signature.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.validatorNodeClaimPublicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxEpoch = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.paymentId = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sidechainDeploymentKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterValidatorNodeRequest {
    return {
      validatorNodePublicKey: isSet(object.validatorNodePublicKey)
        ? bytesFromBase64(object.validatorNodePublicKey)
        : new Uint8Array(0),
      validatorNodeSignature: isSet(object.validatorNodeSignature)
        ? Signature.fromJSON(object.validatorNodeSignature)
        : undefined,
      validatorNodeClaimPublicKey: isSet(object.validatorNodeClaimPublicKey)
        ? bytesFromBase64(object.validatorNodeClaimPublicKey)
        : new Uint8Array(0),
      maxEpoch: isSet(object.maxEpoch) ? Long.fromValue(object.maxEpoch) : Long.UZERO,
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
      paymentId: isSet(object.paymentId) ? bytesFromBase64(object.paymentId) : new Uint8Array(0),
      sidechainDeploymentKey: isSet(object.sidechainDeploymentKey)
        ? bytesFromBase64(object.sidechainDeploymentKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: RegisterValidatorNodeRequest): unknown {
    const obj: any = {};
    if (message.validatorNodePublicKey.length !== 0) {
      obj.validatorNodePublicKey = base64FromBytes(message.validatorNodePublicKey);
    }
    if (message.validatorNodeSignature !== undefined) {
      obj.validatorNodeSignature = Signature.toJSON(message.validatorNodeSignature);
    }
    if (message.validatorNodeClaimPublicKey.length !== 0) {
      obj.validatorNodeClaimPublicKey = base64FromBytes(message.validatorNodeClaimPublicKey);
    }
    if (!message.maxEpoch.equals(Long.UZERO)) {
      obj.maxEpoch = (message.maxEpoch || Long.UZERO).toString();
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    if (message.paymentId.length !== 0) {
      obj.paymentId = base64FromBytes(message.paymentId);
    }
    if (message.sidechainDeploymentKey.length !== 0) {
      obj.sidechainDeploymentKey = base64FromBytes(message.sidechainDeploymentKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterValidatorNodeRequest>, I>>(base?: I): RegisterValidatorNodeRequest {
    return RegisterValidatorNodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterValidatorNodeRequest>, I>>(object: I): RegisterValidatorNodeRequest {
    const message = createBaseRegisterValidatorNodeRequest();
    message.validatorNodePublicKey = object.validatorNodePublicKey ?? new Uint8Array(0);
    message.validatorNodeSignature =
      (object.validatorNodeSignature !== undefined && object.validatorNodeSignature !== null)
        ? Signature.fromPartial(object.validatorNodeSignature)
        : undefined;
    message.validatorNodeClaimPublicKey = object.validatorNodeClaimPublicKey ?? new Uint8Array(0);
    message.maxEpoch = (object.maxEpoch !== undefined && object.maxEpoch !== null)
      ? Long.fromValue(object.maxEpoch)
      : Long.UZERO;
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    message.paymentId = object.paymentId ?? new Uint8Array(0);
    message.sidechainDeploymentKey = object.sidechainDeploymentKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRegisterValidatorNodeResponse(): RegisterValidatorNodeResponse {
  return { transactionId: Long.UZERO, isSuccess: false, failureMessage: "" };
}

export const RegisterValidatorNodeResponse: MessageFns<RegisterValidatorNodeResponse> = {
  encode(message: RegisterValidatorNodeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.transactionId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.transactionId.toString());
    }
    if (message.isSuccess !== false) {
      writer.uint32(16).bool(message.isSuccess);
    }
    if (message.failureMessage !== "") {
      writer.uint32(26).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterValidatorNodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterValidatorNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterValidatorNodeResponse {
    return {
      transactionId: isSet(object.transactionId) ? Long.fromValue(object.transactionId) : Long.UZERO,
      isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: RegisterValidatorNodeResponse): unknown {
    const obj: any = {};
    if (!message.transactionId.equals(Long.UZERO)) {
      obj.transactionId = (message.transactionId || Long.UZERO).toString();
    }
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterValidatorNodeResponse>, I>>(base?: I): RegisterValidatorNodeResponse {
    return RegisterValidatorNodeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterValidatorNodeResponse>, I>>(
    object: I,
  ): RegisterValidatorNodeResponse {
    const message = createBaseRegisterValidatorNodeResponse();
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? Long.fromValue(object.transactionId)
      : Long.UZERO;
    message.isSuccess = object.isSuccess ?? false;
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

function createBaseSubmitValidatorEvictionProofRequest(): SubmitValidatorEvictionProofRequest {
  return { proof: undefined, feePerGram: Long.UZERO, message: "", sidechainDeploymentKey: new Uint8Array(0) };
}

export const SubmitValidatorEvictionProofRequest: MessageFns<SubmitValidatorEvictionProofRequest> = {
  encode(message: SubmitValidatorEvictionProofRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proof !== undefined) {
      EvictionProof.encode(message.proof, writer.uint32(10).fork()).join();
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.feePerGram.toString());
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.sidechainDeploymentKey.length !== 0) {
      writer.uint32(34).bytes(message.sidechainDeploymentKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitValidatorEvictionProofRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitValidatorEvictionProofRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proof = EvictionProof.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sidechainDeploymentKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitValidatorEvictionProofRequest {
    return {
      proof: isSet(object.proof) ? EvictionProof.fromJSON(object.proof) : undefined,
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      sidechainDeploymentKey: isSet(object.sidechainDeploymentKey)
        ? bytesFromBase64(object.sidechainDeploymentKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SubmitValidatorEvictionProofRequest): unknown {
    const obj: any = {};
    if (message.proof !== undefined) {
      obj.proof = EvictionProof.toJSON(message.proof);
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.sidechainDeploymentKey.length !== 0) {
      obj.sidechainDeploymentKey = base64FromBytes(message.sidechainDeploymentKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitValidatorEvictionProofRequest>, I>>(
    base?: I,
  ): SubmitValidatorEvictionProofRequest {
    return SubmitValidatorEvictionProofRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitValidatorEvictionProofRequest>, I>>(
    object: I,
  ): SubmitValidatorEvictionProofRequest {
    const message = createBaseSubmitValidatorEvictionProofRequest();
    message.proof = (object.proof !== undefined && object.proof !== null)
      ? EvictionProof.fromPartial(object.proof)
      : undefined;
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    message.message = object.message ?? "";
    message.sidechainDeploymentKey = object.sidechainDeploymentKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubmitValidatorEvictionProofResponse(): SubmitValidatorEvictionProofResponse {
  return { txId: Long.UZERO };
}

export const SubmitValidatorEvictionProofResponse: MessageFns<SubmitValidatorEvictionProofResponse> = {
  encode(message: SubmitValidatorEvictionProofResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.txId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.txId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitValidatorEvictionProofResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitValidatorEvictionProofResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitValidatorEvictionProofResponse {
    return { txId: isSet(object.txId) ? Long.fromValue(object.txId) : Long.UZERO };
  },

  toJSON(message: SubmitValidatorEvictionProofResponse): unknown {
    const obj: any = {};
    if (!message.txId.equals(Long.UZERO)) {
      obj.txId = (message.txId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitValidatorEvictionProofResponse>, I>>(
    base?: I,
  ): SubmitValidatorEvictionProofResponse {
    return SubmitValidatorEvictionProofResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitValidatorEvictionProofResponse>, I>>(
    object: I,
  ): SubmitValidatorEvictionProofResponse {
    const message = createBaseSubmitValidatorEvictionProofResponse();
    message.txId = (object.txId !== undefined && object.txId !== null) ? Long.fromValue(object.txId) : Long.UZERO;
    return message;
  },
};

function createBaseSubmitValidatorNodeExitRequest(): SubmitValidatorNodeExitRequest {
  return {
    validatorNodePublicKey: new Uint8Array(0),
    validatorNodeSignature: undefined,
    maxEpoch: Long.UZERO,
    feePerGram: Long.UZERO,
    message: new Uint8Array(0),
    sidechainDeploymentKey: new Uint8Array(0),
  };
}

export const SubmitValidatorNodeExitRequest: MessageFns<SubmitValidatorNodeExitRequest> = {
  encode(message: SubmitValidatorNodeExitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorNodePublicKey.length !== 0) {
      writer.uint32(10).bytes(message.validatorNodePublicKey);
    }
    if (message.validatorNodeSignature !== undefined) {
      Signature.encode(message.validatorNodeSignature, writer.uint32(18).fork()).join();
    }
    if (!message.maxEpoch.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.maxEpoch.toString());
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.feePerGram.toString());
    }
    if (message.message.length !== 0) {
      writer.uint32(42).bytes(message.message);
    }
    if (message.sidechainDeploymentKey.length !== 0) {
      writer.uint32(50).bytes(message.sidechainDeploymentKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitValidatorNodeExitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitValidatorNodeExitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorNodePublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validatorNodeSignature = Signature.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxEpoch = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sidechainDeploymentKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitValidatorNodeExitRequest {
    return {
      validatorNodePublicKey: isSet(object.validatorNodePublicKey)
        ? bytesFromBase64(object.validatorNodePublicKey)
        : new Uint8Array(0),
      validatorNodeSignature: isSet(object.validatorNodeSignature)
        ? Signature.fromJSON(object.validatorNodeSignature)
        : undefined,
      maxEpoch: isSet(object.maxEpoch) ? Long.fromValue(object.maxEpoch) : Long.UZERO,
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
      message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
      sidechainDeploymentKey: isSet(object.sidechainDeploymentKey)
        ? bytesFromBase64(object.sidechainDeploymentKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SubmitValidatorNodeExitRequest): unknown {
    const obj: any = {};
    if (message.validatorNodePublicKey.length !== 0) {
      obj.validatorNodePublicKey = base64FromBytes(message.validatorNodePublicKey);
    }
    if (message.validatorNodeSignature !== undefined) {
      obj.validatorNodeSignature = Signature.toJSON(message.validatorNodeSignature);
    }
    if (!message.maxEpoch.equals(Long.UZERO)) {
      obj.maxEpoch = (message.maxEpoch || Long.UZERO).toString();
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    if (message.sidechainDeploymentKey.length !== 0) {
      obj.sidechainDeploymentKey = base64FromBytes(message.sidechainDeploymentKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitValidatorNodeExitRequest>, I>>(base?: I): SubmitValidatorNodeExitRequest {
    return SubmitValidatorNodeExitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitValidatorNodeExitRequest>, I>>(
    object: I,
  ): SubmitValidatorNodeExitRequest {
    const message = createBaseSubmitValidatorNodeExitRequest();
    message.validatorNodePublicKey = object.validatorNodePublicKey ?? new Uint8Array(0);
    message.validatorNodeSignature =
      (object.validatorNodeSignature !== undefined && object.validatorNodeSignature !== null)
        ? Signature.fromPartial(object.validatorNodeSignature)
        : undefined;
    message.maxEpoch = (object.maxEpoch !== undefined && object.maxEpoch !== null)
      ? Long.fromValue(object.maxEpoch)
      : Long.UZERO;
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    message.message = object.message ?? new Uint8Array(0);
    message.sidechainDeploymentKey = object.sidechainDeploymentKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubmitValidatorNodeExitResponse(): SubmitValidatorNodeExitResponse {
  return { transactionId: Long.UZERO, isSuccess: false, failureMessage: "" };
}

export const SubmitValidatorNodeExitResponse: MessageFns<SubmitValidatorNodeExitResponse> = {
  encode(message: SubmitValidatorNodeExitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.transactionId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.transactionId.toString());
    }
    if (message.isSuccess !== false) {
      writer.uint32(16).bool(message.isSuccess);
    }
    if (message.failureMessage !== "") {
      writer.uint32(26).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitValidatorNodeExitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitValidatorNodeExitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitValidatorNodeExitResponse {
    return {
      transactionId: isSet(object.transactionId) ? Long.fromValue(object.transactionId) : Long.UZERO,
      isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: SubmitValidatorNodeExitResponse): unknown {
    const obj: any = {};
    if (!message.transactionId.equals(Long.UZERO)) {
      obj.transactionId = (message.transactionId || Long.UZERO).toString();
    }
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitValidatorNodeExitResponse>, I>>(base?: I): SubmitValidatorNodeExitResponse {
    return SubmitValidatorNodeExitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitValidatorNodeExitResponse>, I>>(
    object: I,
  ): SubmitValidatorNodeExitResponse {
    const message = createBaseSubmitValidatorNodeExitResponse();
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? Long.fromValue(object.transactionId)
      : Long.UZERO;
    message.isSuccess = object.isSuccess ?? false;
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

function createBaseImportTransactionsRequest(): ImportTransactionsRequest {
  return { txs: "" };
}

export const ImportTransactionsRequest: MessageFns<ImportTransactionsRequest> = {
  encode(message: ImportTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txs !== "") {
      writer.uint32(10).string(message.txs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txs = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportTransactionsRequest {
    return { txs: isSet(object.txs) ? globalThis.String(object.txs) : "" };
  },

  toJSON(message: ImportTransactionsRequest): unknown {
    const obj: any = {};
    if (message.txs !== "") {
      obj.txs = message.txs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportTransactionsRequest>, I>>(base?: I): ImportTransactionsRequest {
    return ImportTransactionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportTransactionsRequest>, I>>(object: I): ImportTransactionsRequest {
    const message = createBaseImportTransactionsRequest();
    message.txs = object.txs ?? "";
    return message;
  },
};

function createBaseImportTransactionsResponse(): ImportTransactionsResponse {
  return { txIds: [] };
}

export const ImportTransactionsResponse: MessageFns<ImportTransactionsResponse> = {
  encode(message: ImportTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.txIds) {
      writer.uint64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.txIds.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.txIds.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportTransactionsResponse {
    return { txIds: globalThis.Array.isArray(object?.txIds) ? object.txIds.map((e: any) => Long.fromValue(e)) : [] };
  },

  toJSON(message: ImportTransactionsResponse): unknown {
    const obj: any = {};
    if (message.txIds?.length) {
      obj.txIds = message.txIds.map((e) => (e || Long.UZERO).toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportTransactionsResponse>, I>>(base?: I): ImportTransactionsResponse {
    return ImportTransactionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportTransactionsResponse>, I>>(object: I): ImportTransactionsResponse {
    const message = createBaseImportTransactionsResponse();
    message.txIds = object.txIds?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseGetAllCompletedTransactionsRequest(): GetAllCompletedTransactionsRequest {
  return { offset: Long.UZERO, limit: Long.UZERO, statusBitflag: Long.UZERO };
}

export const GetAllCompletedTransactionsRequest: MessageFns<GetAllCompletedTransactionsRequest> = {
  encode(message: GetAllCompletedTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.offset.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.offset.toString());
    }
    if (!message.limit.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.limit.toString());
    }
    if (!message.statusBitflag.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.statusBitflag.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllCompletedTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllCompletedTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.statusBitflag = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllCompletedTransactionsRequest {
    return {
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.UZERO,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.UZERO,
      statusBitflag: isSet(object.statusBitflag) ? Long.fromValue(object.statusBitflag) : Long.UZERO,
    };
  },

  toJSON(message: GetAllCompletedTransactionsRequest): unknown {
    const obj: any = {};
    if (!message.offset.equals(Long.UZERO)) {
      obj.offset = (message.offset || Long.UZERO).toString();
    }
    if (!message.limit.equals(Long.UZERO)) {
      obj.limit = (message.limit || Long.UZERO).toString();
    }
    if (!message.statusBitflag.equals(Long.UZERO)) {
      obj.statusBitflag = (message.statusBitflag || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllCompletedTransactionsRequest>, I>>(
    base?: I,
  ): GetAllCompletedTransactionsRequest {
    return GetAllCompletedTransactionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllCompletedTransactionsRequest>, I>>(
    object: I,
  ): GetAllCompletedTransactionsRequest {
    const message = createBaseGetAllCompletedTransactionsRequest();
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.UZERO;
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : Long.UZERO;
    message.statusBitflag = (object.statusBitflag !== undefined && object.statusBitflag !== null)
      ? Long.fromValue(object.statusBitflag)
      : Long.UZERO;
    return message;
  },
};

function createBaseGetAllCompletedTransactionsResponse(): GetAllCompletedTransactionsResponse {
  return { transactions: [] };
}

export const GetAllCompletedTransactionsResponse: MessageFns<GetAllCompletedTransactionsResponse> = {
  encode(message: GetAllCompletedTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactions) {
      TransactionInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllCompletedTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllCompletedTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactions.push(TransactionInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllCompletedTransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TransactionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAllCompletedTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TransactionInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllCompletedTransactionsResponse>, I>>(
    base?: I,
  ): GetAllCompletedTransactionsResponse {
    return GetAllCompletedTransactionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllCompletedTransactionsResponse>, I>>(
    object: I,
  ): GetAllCompletedTransactionsResponse {
    const message = createBaseGetAllCompletedTransactionsResponse();
    message.transactions = object.transactions?.map((e) => TransactionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetBlockHeightTransactionsRequest(): GetBlockHeightTransactionsRequest {
  return { blockHeight: Long.UZERO };
}

export const GetBlockHeightTransactionsRequest: MessageFns<GetBlockHeightTransactionsRequest> = {
  encode(message: GetBlockHeightTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.blockHeight.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.blockHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockHeightTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockHeightTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlockHeightTransactionsRequest {
    return { blockHeight: isSet(object.blockHeight) ? Long.fromValue(object.blockHeight) : Long.UZERO };
  },

  toJSON(message: GetBlockHeightTransactionsRequest): unknown {
    const obj: any = {};
    if (!message.blockHeight.equals(Long.UZERO)) {
      obj.blockHeight = (message.blockHeight || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBlockHeightTransactionsRequest>, I>>(
    base?: I,
  ): GetBlockHeightTransactionsRequest {
    return GetBlockHeightTransactionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBlockHeightTransactionsRequest>, I>>(
    object: I,
  ): GetBlockHeightTransactionsRequest {
    const message = createBaseGetBlockHeightTransactionsRequest();
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.UZERO;
    return message;
  },
};

function createBaseGetBlockHeightTransactionsResponse(): GetBlockHeightTransactionsResponse {
  return { transactions: [] };
}

export const GetBlockHeightTransactionsResponse: MessageFns<GetBlockHeightTransactionsResponse> = {
  encode(message: GetBlockHeightTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactions) {
      TransactionInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockHeightTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockHeightTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactions.push(TransactionInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlockHeightTransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TransactionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetBlockHeightTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TransactionInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBlockHeightTransactionsResponse>, I>>(
    base?: I,
  ): GetBlockHeightTransactionsResponse {
    return GetBlockHeightTransactionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBlockHeightTransactionsResponse>, I>>(
    object: I,
  ): GetBlockHeightTransactionsResponse {
    const message = createBaseGetBlockHeightTransactionsResponse();
    message.transactions = object.transactions?.map((e) => TransactionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTransactionPayRefsRequest(): GetTransactionPayRefsRequest {
  return { transactionId: Long.UZERO };
}

export const GetTransactionPayRefsRequest: MessageFns<GetTransactionPayRefsRequest> = {
  encode(message: GetTransactionPayRefsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.transactionId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.transactionId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionPayRefsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionPayRefsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionPayRefsRequest {
    return { transactionId: isSet(object.transactionId) ? Long.fromValue(object.transactionId) : Long.UZERO };
  },

  toJSON(message: GetTransactionPayRefsRequest): unknown {
    const obj: any = {};
    if (!message.transactionId.equals(Long.UZERO)) {
      obj.transactionId = (message.transactionId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionPayRefsRequest>, I>>(base?: I): GetTransactionPayRefsRequest {
    return GetTransactionPayRefsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionPayRefsRequest>, I>>(object: I): GetTransactionPayRefsRequest {
    const message = createBaseGetTransactionPayRefsRequest();
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? Long.fromValue(object.transactionId)
      : Long.UZERO;
    return message;
  },
};

function createBaseGetTransactionPayRefsResponse(): GetTransactionPayRefsResponse {
  return { paymentReferences: [] };
}

export const GetTransactionPayRefsResponse: MessageFns<GetTransactionPayRefsResponse> = {
  encode(message: GetTransactionPayRefsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.paymentReferences) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionPayRefsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionPayRefsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentReferences.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionPayRefsResponse {
    return {
      paymentReferences: globalThis.Array.isArray(object?.paymentReferences)
        ? object.paymentReferences.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: GetTransactionPayRefsResponse): unknown {
    const obj: any = {};
    if (message.paymentReferences?.length) {
      obj.paymentReferences = message.paymentReferences.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionPayRefsResponse>, I>>(base?: I): GetTransactionPayRefsResponse {
    return GetTransactionPayRefsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionPayRefsResponse>, I>>(
    object: I,
  ): GetTransactionPayRefsResponse {
    const message = createBaseGetTransactionPayRefsResponse();
    message.paymentReferences = object.paymentReferences?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetTransactionsWithPayRefsResponse(): GetTransactionsWithPayRefsResponse {
  return { transaction: undefined, paymentReferences: [], recipientCount: Long.UZERO };
}

export const GetTransactionsWithPayRefsResponse: MessageFns<GetTransactionsWithPayRefsResponse> = {
  encode(message: GetTransactionsWithPayRefsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      TransactionInfo.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    for (const v of message.paymentReferences) {
      writer.uint32(18).bytes(v!);
    }
    if (!message.recipientCount.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.recipientCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionsWithPayRefsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionsWithPayRefsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = TransactionInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentReferences.push(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.recipientCount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionsWithPayRefsResponse {
    return {
      transaction: isSet(object.transaction) ? TransactionInfo.fromJSON(object.transaction) : undefined,
      paymentReferences: globalThis.Array.isArray(object?.paymentReferences)
        ? object.paymentReferences.map((e: any) => bytesFromBase64(e))
        : [],
      recipientCount: isSet(object.recipientCount) ? Long.fromValue(object.recipientCount) : Long.UZERO,
    };
  },

  toJSON(message: GetTransactionsWithPayRefsResponse): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = TransactionInfo.toJSON(message.transaction);
    }
    if (message.paymentReferences?.length) {
      obj.paymentReferences = message.paymentReferences.map((e) => base64FromBytes(e));
    }
    if (!message.recipientCount.equals(Long.UZERO)) {
      obj.recipientCount = (message.recipientCount || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionsWithPayRefsResponse>, I>>(
    base?: I,
  ): GetTransactionsWithPayRefsResponse {
    return GetTransactionsWithPayRefsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionsWithPayRefsResponse>, I>>(
    object: I,
  ): GetTransactionsWithPayRefsResponse {
    const message = createBaseGetTransactionsWithPayRefsResponse();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? TransactionInfo.fromPartial(object.transaction)
      : undefined;
    message.paymentReferences = object.paymentReferences?.map((e) => e) || [];
    message.recipientCount = (object.recipientCount !== undefined && object.recipientCount !== null)
      ? Long.fromValue(object.recipientCount)
      : Long.UZERO;
    return message;
  },
};

function createBaseGetPaymentByReferenceRequest(): GetPaymentByReferenceRequest {
  return { paymentReference: new Uint8Array(0) };
}

export const GetPaymentByReferenceRequest: MessageFns<GetPaymentByReferenceRequest> = {
  encode(message: GetPaymentByReferenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentReference.length !== 0) {
      writer.uint32(10).bytes(message.paymentReference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPaymentByReferenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentByReferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentReference = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPaymentByReferenceRequest {
    return {
      paymentReference: isSet(object.paymentReference) ? bytesFromBase64(object.paymentReference) : new Uint8Array(0),
    };
  },

  toJSON(message: GetPaymentByReferenceRequest): unknown {
    const obj: any = {};
    if (message.paymentReference.length !== 0) {
      obj.paymentReference = base64FromBytes(message.paymentReference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPaymentByReferenceRequest>, I>>(base?: I): GetPaymentByReferenceRequest {
    return GetPaymentByReferenceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPaymentByReferenceRequest>, I>>(object: I): GetPaymentByReferenceRequest {
    const message = createBaseGetPaymentByReferenceRequest();
    message.paymentReference = object.paymentReference ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetPaymentByReferenceResponse(): GetPaymentByReferenceResponse {
  return { transaction: undefined };
}

export const GetPaymentByReferenceResponse: MessageFns<GetPaymentByReferenceResponse> = {
  encode(message: GetPaymentByReferenceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      TransactionInfo.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPaymentByReferenceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentByReferenceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = TransactionInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPaymentByReferenceResponse {
    return { transaction: isSet(object.transaction) ? TransactionInfo.fromJSON(object.transaction) : undefined };
  },

  toJSON(message: GetPaymentByReferenceResponse): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = TransactionInfo.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPaymentByReferenceResponse>, I>>(base?: I): GetPaymentByReferenceResponse {
    return GetPaymentByReferenceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPaymentByReferenceResponse>, I>>(
    object: I,
  ): GetPaymentByReferenceResponse {
    const message = createBaseGetPaymentByReferenceResponse();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? TransactionInfo.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseGetFeeEstimateRequest(): GetFeeEstimateRequest {
  return { amount: Long.UZERO, feePerGram: Long.UZERO, outputCount: Long.UZERO };
}

export const GetFeeEstimateRequest: MessageFns<GetFeeEstimateRequest> = {
  encode(message: GetFeeEstimateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.amount.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.amount.toString());
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.feePerGram.toString());
    }
    if (!message.outputCount.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.outputCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeeEstimateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeeEstimateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.amount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.outputCount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeeEstimateRequest {
    return {
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.UZERO,
      feePerGram: isSet(object.feePerGram) ? Long.fromValue(object.feePerGram) : Long.UZERO,
      outputCount: isSet(object.outputCount) ? Long.fromValue(object.outputCount) : Long.UZERO,
    };
  },

  toJSON(message: GetFeeEstimateRequest): unknown {
    const obj: any = {};
    if (!message.amount.equals(Long.UZERO)) {
      obj.amount = (message.amount || Long.UZERO).toString();
    }
    if (!message.feePerGram.equals(Long.UZERO)) {
      obj.feePerGram = (message.feePerGram || Long.UZERO).toString();
    }
    if (!message.outputCount.equals(Long.UZERO)) {
      obj.outputCount = (message.outputCount || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFeeEstimateRequest>, I>>(base?: I): GetFeeEstimateRequest {
    return GetFeeEstimateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFeeEstimateRequest>, I>>(object: I): GetFeeEstimateRequest {
    const message = createBaseGetFeeEstimateRequest();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.UZERO;
    message.feePerGram = (object.feePerGram !== undefined && object.feePerGram !== null)
      ? Long.fromValue(object.feePerGram)
      : Long.UZERO;
    message.outputCount = (object.outputCount !== undefined && object.outputCount !== null)
      ? Long.fromValue(object.outputCount)
      : Long.UZERO;
    return message;
  },
};

function createBaseGetFeeEstimateResponse(): GetFeeEstimateResponse {
  return { estimatedFee: Long.UZERO };
}

export const GetFeeEstimateResponse: MessageFns<GetFeeEstimateResponse> = {
  encode(message: GetFeeEstimateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.estimatedFee.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.estimatedFee.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeeEstimateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeeEstimateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.estimatedFee = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeeEstimateResponse {
    return { estimatedFee: isSet(object.estimatedFee) ? Long.fromValue(object.estimatedFee) : Long.UZERO };
  },

  toJSON(message: GetFeeEstimateResponse): unknown {
    const obj: any = {};
    if (!message.estimatedFee.equals(Long.UZERO)) {
      obj.estimatedFee = (message.estimatedFee || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFeeEstimateResponse>, I>>(base?: I): GetFeeEstimateResponse {
    return GetFeeEstimateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFeeEstimateResponse>, I>>(object: I): GetFeeEstimateResponse {
    const message = createBaseGetFeeEstimateResponse();
    message.estimatedFee = (object.estimatedFee !== undefined && object.estimatedFee !== null)
      ? Long.fromValue(object.estimatedFee)
      : Long.UZERO;
    return message;
  },
};

function createBaseGetFeePerGramStatsRequest(): GetFeePerGramStatsRequest {
  return { blockCount: Long.UZERO };
}

export const GetFeePerGramStatsRequest: MessageFns<GetFeePerGramStatsRequest> = {
  encode(message: GetFeePerGramStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.blockCount.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.blockCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeePerGramStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeePerGramStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockCount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeePerGramStatsRequest {
    return { blockCount: isSet(object.blockCount) ? Long.fromValue(object.blockCount) : Long.UZERO };
  },

  toJSON(message: GetFeePerGramStatsRequest): unknown {
    const obj: any = {};
    if (!message.blockCount.equals(Long.UZERO)) {
      obj.blockCount = (message.blockCount || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFeePerGramStatsRequest>, I>>(base?: I): GetFeePerGramStatsRequest {
    return GetFeePerGramStatsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFeePerGramStatsRequest>, I>>(object: I): GetFeePerGramStatsRequest {
    const message = createBaseGetFeePerGramStatsRequest();
    message.blockCount = (object.blockCount !== undefined && object.blockCount !== null)
      ? Long.fromValue(object.blockCount)
      : Long.UZERO;
    return message;
  },
};

function createBaseGetFeePerGramStatsResponse(): GetFeePerGramStatsResponse {
  return { feePerGramStats: [] };
}

export const GetFeePerGramStatsResponse: MessageFns<GetFeePerGramStatsResponse> = {
  encode(message: GetFeePerGramStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.feePerGramStats) {
      FeePerGramStat.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeePerGramStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeePerGramStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feePerGramStats.push(FeePerGramStat.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeePerGramStatsResponse {
    return {
      feePerGramStats: globalThis.Array.isArray(object?.feePerGramStats)
        ? object.feePerGramStats.map((e: any) => FeePerGramStat.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetFeePerGramStatsResponse): unknown {
    const obj: any = {};
    if (message.feePerGramStats?.length) {
      obj.feePerGramStats = message.feePerGramStats.map((e) => FeePerGramStat.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFeePerGramStatsResponse>, I>>(base?: I): GetFeePerGramStatsResponse {
    return GetFeePerGramStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFeePerGramStatsResponse>, I>>(object: I): GetFeePerGramStatsResponse {
    const message = createBaseGetFeePerGramStatsResponse();
    message.feePerGramStats = object.feePerGramStats?.map((e) => FeePerGramStat.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReplaceByFeeRequest(): ReplaceByFeeRequest {
  return { transactionId: Long.UZERO, feeIncrease: Long.UZERO };
}

export const ReplaceByFeeRequest: MessageFns<ReplaceByFeeRequest> = {
  encode(message: ReplaceByFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.transactionId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.transactionId.toString());
    }
    if (!message.feeIncrease.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.feeIncrease.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplaceByFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplaceByFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feeIncrease = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplaceByFeeRequest {
    return {
      transactionId: isSet(object.transactionId) ? Long.fromValue(object.transactionId) : Long.UZERO,
      feeIncrease: isSet(object.feeIncrease) ? Long.fromValue(object.feeIncrease) : Long.UZERO,
    };
  },

  toJSON(message: ReplaceByFeeRequest): unknown {
    const obj: any = {};
    if (!message.transactionId.equals(Long.UZERO)) {
      obj.transactionId = (message.transactionId || Long.UZERO).toString();
    }
    if (!message.feeIncrease.equals(Long.UZERO)) {
      obj.feeIncrease = (message.feeIncrease || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReplaceByFeeRequest>, I>>(base?: I): ReplaceByFeeRequest {
    return ReplaceByFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReplaceByFeeRequest>, I>>(object: I): ReplaceByFeeRequest {
    const message = createBaseReplaceByFeeRequest();
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? Long.fromValue(object.transactionId)
      : Long.UZERO;
    message.feeIncrease = (object.feeIncrease !== undefined && object.feeIncrease !== null)
      ? Long.fromValue(object.feeIncrease)
      : Long.UZERO;
    return message;
  },
};

function createBaseReplaceByFeeResponse(): ReplaceByFeeResponse {
  return { transactionId: Long.UZERO };
}

export const ReplaceByFeeResponse: MessageFns<ReplaceByFeeResponse> = {
  encode(message: ReplaceByFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.transactionId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.transactionId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplaceByFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplaceByFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplaceByFeeResponse {
    return { transactionId: isSet(object.transactionId) ? Long.fromValue(object.transactionId) : Long.UZERO };
  },

  toJSON(message: ReplaceByFeeResponse): unknown {
    const obj: any = {};
    if (!message.transactionId.equals(Long.UZERO)) {
      obj.transactionId = (message.transactionId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReplaceByFeeResponse>, I>>(base?: I): ReplaceByFeeResponse {
    return ReplaceByFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReplaceByFeeResponse>, I>>(object: I): ReplaceByFeeResponse {
    const message = createBaseReplaceByFeeResponse();
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? Long.fromValue(object.transactionId)
      : Long.UZERO;
    return message;
  },
};

function createBaseUserPayForFeeRequest(): UserPayForFeeRequest {
  return { recipients: [] };
}

export const UserPayForFeeRequest: MessageFns<UserPayForFeeRequest> = {
  encode(message: UserPayForFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.recipients) {
      TxOutputsToSpendTransfer.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserPayForFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserPayForFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recipients.push(TxOutputsToSpendTransfer.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserPayForFeeRequest {
    return {
      recipients: globalThis.Array.isArray(object?.recipients)
        ? object.recipients.map((e: any) => TxOutputsToSpendTransfer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserPayForFeeRequest): unknown {
    const obj: any = {};
    if (message.recipients?.length) {
      obj.recipients = message.recipients.map((e) => TxOutputsToSpendTransfer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserPayForFeeRequest>, I>>(base?: I): UserPayForFeeRequest {
    return UserPayForFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserPayForFeeRequest>, I>>(object: I): UserPayForFeeRequest {
    const message = createBaseUserPayForFeeRequest();
    message.recipients = object.recipients?.map((e) => TxOutputsToSpendTransfer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTxOutputsToSpendTransfer(): TxOutputsToSpendTransfer {
  return { txId: Long.UZERO, fee: Long.UZERO, destination: "" };
}

export const TxOutputsToSpendTransfer: MessageFns<TxOutputsToSpendTransfer> = {
  encode(message: TxOutputsToSpendTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.txId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.txId.toString());
    }
    if (!message.fee.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.fee.toString());
    }
    if (message.destination !== "") {
      writer.uint32(26).string(message.destination);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TxOutputsToSpendTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTxOutputsToSpendTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fee = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destination = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TxOutputsToSpendTransfer {
    return {
      txId: isSet(object.txId) ? Long.fromValue(object.txId) : Long.UZERO,
      fee: isSet(object.fee) ? Long.fromValue(object.fee) : Long.UZERO,
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
    };
  },

  toJSON(message: TxOutputsToSpendTransfer): unknown {
    const obj: any = {};
    if (!message.txId.equals(Long.UZERO)) {
      obj.txId = (message.txId || Long.UZERO).toString();
    }
    if (!message.fee.equals(Long.UZERO)) {
      obj.fee = (message.fee || Long.UZERO).toString();
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TxOutputsToSpendTransfer>, I>>(base?: I): TxOutputsToSpendTransfer {
    return TxOutputsToSpendTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TxOutputsToSpendTransfer>, I>>(object: I): TxOutputsToSpendTransfer {
    const message = createBaseTxOutputsToSpendTransfer();
    message.txId = (object.txId !== undefined && object.txId !== null) ? Long.fromValue(object.txId) : Long.UZERO;
    message.fee = (object.fee !== undefined && object.fee !== null) ? Long.fromValue(object.fee) : Long.UZERO;
    message.destination = object.destination ?? "";
    return message;
  },
};

function createBaseUserPayForFeeResponse(): UserPayForFeeResponse {
  return { results: [] };
}

export const UserPayForFeeResponse: MessageFns<UserPayForFeeResponse> = {
  encode(message: UserPayForFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      TransferResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserPayForFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserPayForFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(TransferResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserPayForFeeResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => TransferResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserPayForFeeResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => TransferResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserPayForFeeResponse>, I>>(base?: I): UserPayForFeeResponse {
    return UserPayForFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserPayForFeeResponse>, I>>(object: I): UserPayForFeeResponse {
    const message = createBaseUserPayForFeeResponse();
    message.results = object.results?.map((e) => TransferResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFeePerGramStat(): FeePerGramStat {
  return { averageFeePerGram: Long.UZERO, minFeePerGram: Long.UZERO, maxFeePerGram: Long.UZERO };
}

export const FeePerGramStat: MessageFns<FeePerGramStat> = {
  encode(message: FeePerGramStat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.averageFeePerGram.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.averageFeePerGram.toString());
    }
    if (!message.minFeePerGram.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.minFeePerGram.toString());
    }
    if (!message.maxFeePerGram.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.maxFeePerGram.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeePerGramStat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeePerGramStat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.averageFeePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.minFeePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxFeePerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeePerGramStat {
    return {
      averageFeePerGram: isSet(object.averageFeePerGram) ? Long.fromValue(object.averageFeePerGram) : Long.UZERO,
      minFeePerGram: isSet(object.minFeePerGram) ? Long.fromValue(object.minFeePerGram) : Long.UZERO,
      maxFeePerGram: isSet(object.maxFeePerGram) ? Long.fromValue(object.maxFeePerGram) : Long.UZERO,
    };
  },

  toJSON(message: FeePerGramStat): unknown {
    const obj: any = {};
    if (!message.averageFeePerGram.equals(Long.UZERO)) {
      obj.averageFeePerGram = (message.averageFeePerGram || Long.UZERO).toString();
    }
    if (!message.minFeePerGram.equals(Long.UZERO)) {
      obj.minFeePerGram = (message.minFeePerGram || Long.UZERO).toString();
    }
    if (!message.maxFeePerGram.equals(Long.UZERO)) {
      obj.maxFeePerGram = (message.maxFeePerGram || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeePerGramStat>, I>>(base?: I): FeePerGramStat {
    return FeePerGramStat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeePerGramStat>, I>>(object: I): FeePerGramStat {
    const message = createBaseFeePerGramStat();
    message.averageFeePerGram = (object.averageFeePerGram !== undefined && object.averageFeePerGram !== null)
      ? Long.fromValue(object.averageFeePerGram)
      : Long.UZERO;
    message.minFeePerGram = (object.minFeePerGram !== undefined && object.minFeePerGram !== null)
      ? Long.fromValue(object.minFeePerGram)
      : Long.UZERO;
    message.maxFeePerGram = (object.maxFeePerGram !== undefined && object.maxFeePerGram !== null)
      ? Long.fromValue(object.maxFeePerGram)
      : Long.UZERO;
    return message;
  },
};

function createBaseSignMessageRequest(): SignMessageRequest {
  return { message: new Uint8Array(0) };
}

export const SignMessageRequest: MessageFns<SignMessageRequest> = {
  encode(message: SignMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message.length !== 0) {
      writer.uint32(10).bytes(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignMessageRequest {
    return { message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0) };
  },

  toJSON(message: SignMessageRequest): unknown {
    const obj: any = {};
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignMessageRequest>, I>>(base?: I): SignMessageRequest {
    return SignMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignMessageRequest>, I>>(object: I): SignMessageRequest {
    const message = createBaseSignMessageRequest();
    message.message = object.message ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSignMessageResponse(): SignMessageResponse {
  return { signature: "", publicNonce: "" };
}

export const SignMessageResponse: MessageFns<SignMessageResponse> = {
  encode(message: SignMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature !== "") {
      writer.uint32(10).string(message.signature);
    }
    if (message.publicNonce !== "") {
      writer.uint32(18).string(message.publicNonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicNonce = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignMessageResponse {
    return {
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      publicNonce: isSet(object.publicNonce) ? globalThis.String(object.publicNonce) : "",
    };
  },

  toJSON(message: SignMessageResponse): unknown {
    const obj: any = {};
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.publicNonce !== "") {
      obj.publicNonce = message.publicNonce;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignMessageResponse>, I>>(base?: I): SignMessageResponse {
    return SignMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignMessageResponse>, I>>(object: I): SignMessageResponse {
    const message = createBaseSignMessageResponse();
    message.signature = object.signature ?? "";
    message.publicNonce = object.publicNonce ?? "";
    return message;
  },
};

/** The gRPC interface for interacting with the wallet. */
export type WalletService = typeof WalletService;
export const WalletService = {
  getVersion: {
    path: "/tari.rpc.Wallet/GetVersion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetVersionRequest) => Buffer.from(GetVersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetVersionRequest.decode(value),
    responseSerialize: (value: GetVersionResponse) => Buffer.from(GetVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetVersionResponse.decode(value),
  },
  /**
   * Returns the current operational state of the wallet.
   *
   * This RPC provides an overview of the wallet's internal status, including:
   * - The latest blockchain height scanned by the wallet
   * - The current balance (available, pending incoming/outgoing)
   * - Network connectivity status with the base node
   *
   * This is commonly used by UI clients or backend systems to confirm the wallet is healthy,
   * synchronized, and connected to the Tari network.
   *
   * Example usage (JavaScript):
   * ```javascript
   * const response = await client.getState({});
   * console.log(response.scanned_height); // e.g., 1523493
   * console.log(response.balance.available_balance); // e.g., 1234567890
   * console.log(response.network.status); // e.g., "Online"
   * ```
   *
   * Example response:
   * ```json
   * {
   *   "scanned_height": 1523493,
   *   "balance": {
   *     "available_balance": 1234567890,
   *     "pending_incoming_balance": 100000000,
   *     "pending_outgoing_balance": 0
   *   },
   *   "network": {
   *     "status": "Online",
   *     "avg_latency_ms": 28,
   *     "num_node_connections": 8
   *   }
   * }
   * ```
   */
  getState: {
    path: "/tari.rpc.Wallet/GetState",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStateRequest) => Buffer.from(GetStateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetStateRequest.decode(value),
    responseSerialize: (value: GetStateResponse) => Buffer.from(GetStateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetStateResponse.decode(value),
  },
  /**
   * This RPC returns a lightweight response indicating whether the wallet is connected to the network, attempting to connect, or currently offline. This is useful for UIs or clients to determine if network interactions like transactions or syncs are possible.
   *
   * Example usage (JavaScript):
   * ```javascript
   * const response = await client.checkConnectivity({});
   * console.log(response.status); // e.g., 1 (Online)
   * ```
   *
   * Example response:
   * ```json
   * {
   *   "status": "Online"
   * }
   * ```
   */
  checkConnectivity: {
    path: "/tari.rpc.Wallet/CheckConnectivity",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetConnectivityRequest) => Buffer.from(GetConnectivityRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetConnectivityRequest.decode(value),
    responseSerialize: (value: CheckConnectivityResponse) =>
      Buffer.from(CheckConnectivityResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CheckConnectivityResponse.decode(value),
  },
  /** Check for new updates */
  checkForUpdates: {
    path: "/tari.rpc.Wallet/CheckForUpdates",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: SoftwareUpdate) => Buffer.from(SoftwareUpdate.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SoftwareUpdate.decode(value),
  },
  /**
   * The `Identify` RPC call returns the identity information of the wallet node.
   * This includes:
   * - **Public Key**: The wallet's cryptographic public key.
   * - **Public Address**: The wallet's public address used to receive funds.
   * - **Node ID**: The unique identifier of the wallet node in the network.
   *
   * Example usage (JavaScript):
   * ```javascript
   * // Call the Identify RPC method
   * client.Identify({}, (error, response) => {
   *   if (error) {
   *     console.error('Error:', error);
   *   } else {
   *     console.log('Identity Response:', response);
   *   }
   * });
   * ```
   *
   * **Sample JSON Response:**
   *
   * ```json
   * {
   *   "public_key": "0x04b2c5f3fe65bb1c3cde019e34f3eab1234598c820dca43bbf4d5686a980ddc69e0d4b180d85990d0a5e4aee46e0a6ad9283f0a41783992a70c548e53e47321fa",
   *   "public_address": "14HVCEeZC2RGE4SDn3yGwqzXepJ2LDqXva7kb4fherYMQR9dF7341T3TjMZobB1a6xouGvS5SXwEvXKwK3zLz2rgReh",
   *   "node_id": "0x1234abcd5678efgh9012ijkl3456mnop"
   * }
   * ```
   */
  identify: {
    path: "/tari.rpc.Wallet/Identify",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetIdentityRequest) => Buffer.from(GetIdentityRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetIdentityRequest.decode(value),
    responseSerialize: (value: GetIdentityResponse) => Buffer.from(GetIdentityResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetIdentityResponse.decode(value),
  },
  /**
   * This RPC returns two types of wallet addresses: interactive and one-sided addresses.
   * It provides these addresses in byte format as part of the response.
   * - **Interactive Address**: This is a type of address used for interaction and communication with the wallet.
   * - **One-Sided Address**: This is another address type, typically used in scenarios where a one-way interaction or transaction is needed.
   *
   * Example usage (JavaScript):
   * // Call the GetAddress RPC method
   * client.GetAddress({}, (error, response) => {
   *   if (error) {
   *     console.error('Error:', error);
   *   } else {
   *     console.log('Address Response:', response);
   *   }
   * });
   * ```
   *
   * **Sample JSON Response:**
   *  // ```json
   * {
   *   "interactive_address": "0x14b27bde3f7d9c9d7455f16b056a3c439c663af93356f56e16d2b2c79e6995c44c9c6c7c",
   *   "one_sided_address": "0x12b35ddcb2270a72d7b327abc7cd4f607a492c6e13e72e65c34742069e48bd3bc462df63"
   * }
   * ```
   */
  getAddress: {
    path: "/tari.rpc.Wallet/GetAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetAddressResponse) => Buffer.from(GetAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAddressResponse.decode(value),
  },
  /**
   * This RPC returns addresses generated for a specific payment ID. It provides both the interactive
   * and one-sided addresses for the given payment ID, along with their respective representations in
   * base58 and emoji formats.
   *
   * Example usage (JavaScript):
   *
   * ```javascript
   * // Prepare the payment ID for the request
   * const paymentId = Buffer.from('your_payment_id_here', 'hex');
   * const request = { payment_id: paymentId };
   *
   * // Call the GetPaymentIdAddress RPC method
   * client.GetPaymentIdAddress(request, (error, response) => {
   *   if (error) {
   *     console.error('Error:', error);
   *   } else {
   *     console.log('Payment ID Address Response:', response);
   *   }
   * });
   * ```
   *
   * **Sample JSON Response:**
   *
   * ```json
   * {
   *  "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
   *  "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
   *  "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
   *  "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
   *  "interactive_address_emoji": "🐢🌊💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭",
   *  "one_sided_address_emoji": "🐢📟💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞📜.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭"
   * }
   * ```
   */
  getPaymentIdAddress: {
    path: "/tari.rpc.Wallet/GetPaymentIdAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPaymentIdAddressRequest) =>
      Buffer.from(GetPaymentIdAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPaymentIdAddressRequest.decode(value),
    responseSerialize: (value: GetCompleteAddressResponse) =>
      Buffer.from(GetCompleteAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetCompleteAddressResponse.decode(value),
  },
  /**
   * This RPC call that retrieves the current wallet's interactive and one-sided addresses in multiple formats and returns them in a structured response.
   * The response includes:
   * - Raw binary
   * - Base58-encoded (human-readable)
   * - Emoji-encoded (for fun and friendliness)
   *
   * Example usage (JavaScript with gRPC):
   *
   * ```js
   * const client = new WalletClient('localhost:50051', grpc.credentials.createInsecure());
   * client.getCompleteAddress({}, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response);
   * });
   * ```
   *
   * Sample response:
   * ```json
   * {
   *  "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
   *  "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
   *  "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
   *  "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
   *  "interactive_address_emoji": "🐢🌊💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭",
   *  "one_sided_address_emoji": "🐢📟💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞📜.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭"
   * }
   * ```
   */
  getCompleteAddress: {
    path: "/tari.rpc.Wallet/GetCompleteAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetCompleteAddressResponse) =>
      Buffer.from(GetCompleteAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetCompleteAddressResponse.decode(value),
  },
  prepareOneSidedTransactionForSigning: {
    path: "/tari.rpc.Wallet/PrepareOneSidedTransactionForSigning",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PrepareOneSidedTransactionForSigningRequest) =>
      Buffer.from(PrepareOneSidedTransactionForSigningRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PrepareOneSidedTransactionForSigningRequest.decode(value),
    responseSerialize: (value: PrepareOneSidedTransactionForSigningResponse) =>
      Buffer.from(PrepareOneSidedTransactionForSigningResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PrepareOneSidedTransactionForSigningResponse.decode(value),
  },
  broadcastSignedOneSidedTransaction: {
    path: "/tari.rpc.Wallet/BroadcastSignedOneSidedTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BroadcastSignedOneSidedTransactionRequest) =>
      Buffer.from(BroadcastSignedOneSidedTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BroadcastSignedOneSidedTransactionRequest.decode(value),
    responseSerialize: (value: BroadcastSignedOneSidedTransactionResponse) =>
      Buffer.from(BroadcastSignedOneSidedTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BroadcastSignedOneSidedTransactionResponse.decode(value),
  },
  /**
   * This call supports standard interactive transactions (Mimblewimble),
   * one-sided transactions, and one-sided-to-stealth-address transactions.
   * Each recipient must include a valid Tari address, amount, fee, and payment type.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const recipient = new PaymentRecipient();
   * recipient.setAddress("14HVCEeZ...");
   * recipient.setAmount(1000000); // 1 T
   * recipient.setFeePerGram(25);
   * recipient.setPaymentType(PaymentType.ONE_SIDED);
   * recipient.setPaymentId(Buffer.from("abc123", "utf-8"));
   *
   * const request = new TransferRequest();
   * request.setRecipientsList([recipient]);
   *
   * client.transfer(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response.toObject());
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "results": [
   *     {
   *       "address": "14HVCEeZ...",
   *       "transaction_id": 12345,
   *       "is_success": true,
   *       "failure_message": ""
   *     }
   *   ]
   * }
   */
  transfer: {
    path: "/tari.rpc.Wallet/Transfer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TransferRequest) => Buffer.from(TransferRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TransferRequest.decode(value),
    responseSerialize: (value: TransferResponse) => Buffer.from(TransferResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransferResponse.decode(value),
  },
  /**
   * Returns the transaction details for the given transaction IDs.
   *
   * The GetTransactionInfo RPC retrieves detailed information about specific transactions based on their IDs.
   * The response includes details such as transaction status, direction, amount, fee, and more.
   *
   * ### Request Parameters:
   *
   * - `transaction_ids` (required):
   *   - **Type**: `repeated uint64`
   *   - **Description**: A list of transaction IDs to query.
   *   - **Restrictions**:
   *     - Must contain at least one ID.
   *     - All IDs must be valid unsigned 64-bit integers.
   *     - Duplicates will be ignored; only the first occurrence is processed.
   *     - If a transaction ID is not found, it will be returned with a `status` of `NOT_FOUND`.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = { transaction_ids: [12345, 67890] };
   * client.getTransactionInfo(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response.transactions);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "transactions": [
   *     {
   *       "tx_id": 12345,
   *       "source_address": "0x1234abcd...",
   *       "dest_address": "0x5678efgh...",
   *       "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
   *       "direction": "TRANSACTION_DIRECTION_OUTBOUND",
   *       "amount": 1000000,
   *       "fee": 25,
   *       "is_cancelled": false,
   *       "excess_sig": "0xabcdef...",
   *       "timestamp": 1681234567,
   *       "payment_id": "0xdeadbeef...",
   *       "mined_in_block_height": 1523493
   *     }
   *   ]
   * }
   */
  getTransactionInfo: {
    path: "/tari.rpc.Wallet/GetTransactionInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTransactionInfoRequest) =>
      Buffer.from(GetTransactionInfoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTransactionInfoRequest.decode(value),
    responseSerialize: (value: GetTransactionInfoResponse) =>
      Buffer.from(GetTransactionInfoResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTransactionInfoResponse.decode(value),
  },
  /**
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   payment_id: {
   *     utf8_string: "invoice-001"
   *   }
   * };
   * const call = client.getCompletedTransactions(request);
   * call.on('data', (response) => {
   *   console.log(response.transaction);
   * });
   * call.on('error', console.error);
   * call.on('end', () => console.log("Stream ended"));
   * ```
   *
   * ### Sample Streamed JSON Response:
   *
   * ```json
   * {
   *   "transaction": {
   *     "tx_id": 12345,
   *     "source_address": "0x1234abcd...",
   *     "dest_address": "0x5678efgh...",
   *     "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
   *     "direction": "TRANSACTION_DIRECTION_INBOUND",
   *     "amount": 500000,
   *     "fee": 20,
   *     "is_cancelled": false,
   *     "excess_sig": "0xabcdef...",
   *     "timestamp": 1681234567,
   *     "payment_id": "0xdeadbeef...",
   *     "mined_in_block_height": 1523493
   *   }
   * }
   * ```
   */
  getCompletedTransactions: {
    path: "/tari.rpc.Wallet/GetCompletedTransactions",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: GetCompletedTransactionsRequest) =>
      Buffer.from(GetCompletedTransactionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetCompletedTransactionsRequest.decode(value),
    responseSerialize: (value: GetCompletedTransactionsResponse) =>
      Buffer.from(GetCompletedTransactionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetCompletedTransactionsResponse.decode(value),
  },
  /**
   * Returns all transactions that were mined at a specific block height.
   *
   * The `GetBlockHeightTransactions` call retrieves all wallet transactions that were mined
   * at the specified block height. The response includes all transactions in a single response,
   * with each transaction including details such as status, direction, amount,
   * fees, and associated metadata.
   *
   * ### Request Parameters:
   *
   * - `block_height` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The specific block height to fetch transactions for.
   *   - **Restrictions**:
   *     - Must be a valid block height (greater than 0).
   *     - If the block height is beyond the current chain height, no transactions will be returned.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   block_height: 1523493
   * };
   * const response = await client.getBlockHeightTransactions(request);
   * console.log(response.transactions);
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "transactions": [
   *     {
   *       "tx_id": 12345,
   *       "source_address": "0x1234abcd...",
   *       "dest_address": "0x5678efgh...",
   *       "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
   *       "direction": "TRANSACTION_DIRECTION_INBOUND",
   *       "amount": 500000,
   *       "fee": 20,
   *       "is_cancelled": false,
   *       "excess_sig": "0xabcdef...",
   *       "timestamp": 1681234567,
   *       "payment_id": "0xdeadbeef...",
   *       "mined_in_block_height": 1523493
   *     }
   *   ]
   * }
   * ```
   */
  getBlockHeightTransactions: {
    path: "/tari.rpc.Wallet/GetBlockHeightTransactions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBlockHeightTransactionsRequest) =>
      Buffer.from(GetBlockHeightTransactionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetBlockHeightTransactionsRequest.decode(value),
    responseSerialize: (value: GetBlockHeightTransactionsResponse) =>
      Buffer.from(GetBlockHeightTransactionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetBlockHeightTransactionsResponse.decode(value),
  },
  /**
   * Returns all PayRefs (payment references) for a specific transaction.
   *
   * The `GetTransactionPayRefs` call retrieves all PayRefs associated with the specified
   * transaction ID. PayRefs are cryptographic references generated from output hashes
   * that allow recipients to verify payments without revealing sensitive transaction details.
   *
   * ### Request Parameters:
   *
   * - `transaction_id` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The transaction ID to retrieve PayRefs for.
   *   - **Restrictions**:
   *     - Must be a valid transaction ID that exists in the wallet.
   *     - If the transaction ID is invalid or not found, an error will be returned.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   transaction_id: 12345
   * };
   * const response = await client.getTransactionPayRefs(request);
   * console.log("PayRefs:", response.payment_references.map(ref => Buffer.from(ref).toString('hex')));
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "payment_references": [
   *     "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
   *     "0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"
   *   ]
   * }
   * ```
   */
  getTransactionPayRefs: {
    path: "/tari.rpc.Wallet/GetTransactionPayRefs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTransactionPayRefsRequest) =>
      Buffer.from(GetTransactionPayRefsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTransactionPayRefsRequest.decode(value),
    responseSerialize: (value: GetTransactionPayRefsResponse) =>
      Buffer.from(GetTransactionPayRefsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTransactionPayRefsResponse.decode(value),
  },
  /**
   * Returns the wallet balance details.
   *
   * The `GetBalance` call retrieves the current balance status of the wallet,
   * optionally filtered by a specific `payment_id`. The response includes detailed
   * breakdowns of available, pending incoming/outgoing, and timelocked balances.
   *
   * ### Request Parameters:
   *
   * - `payment_id` (optional):
   *   - **Type**: `UserPaymentId` (one of several formats).
   *   - **Description**: An optional filter to retrieve the balance associated with a specific payment ID.
   *   - **Accepted Formats** (must provide **only one**):
   *     - `u256`: a 32-byte hexadecimal identifier.
   *     - `utf8_string`: a human-readable string ID.
   *     - `user_bytes`: raw binary bytes.
   *   - **Restrictions**:
   *     - Only one format must be provided at a time.
   *     - If multiple or no formats are provided within `payment_id`, the request will return an error.
   *     - If `payment_id` is omitted, the total wallet balance is returned.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   payment_id: {
   *     utf8_string: "invoice-002"
   *   }
   * };
   * client.getBalance(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Balance:", response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "available_balance": 950000,
   *   "pending_incoming_balance": 200000,
   *   "pending_outgoing_balance": 50000,
   *   "timelocked_balance": 100000
   * }
   * ```
   */
  getBalance: {
    path: "/tari.rpc.Wallet/GetBalance",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBalanceRequest) => Buffer.from(GetBalanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetBalanceRequest.decode(value),
    responseSerialize: (value: GetBalanceResponse) => Buffer.from(GetBalanceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetBalanceResponse.decode(value),
  },
  /**
   * Returns the total value of unspent outputs in the wallet.
   *
   * The `GetUnspentAmounts` call retrieves the sum of all unspent output amounts
   * currently held by the wallet. These are outputs that have not yet been spent or time-locked,
   * and are available for future transactions.
   *
   * ### Request Parameters:
   *
   * - *(none)*
   *   - This method uses an empty request body (`google.protobuf.Empty`).
   *   - No filters or arguments are required.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * client.getUnspentAmounts({}, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Total unspent amount:", response.amount);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "amount": 1250000
   * }
   * ```
   */
  getUnspentAmounts: {
    path: "/tari.rpc.Wallet/GetUnspentAmounts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetUnspentAmountsResponse) =>
      Buffer.from(GetUnspentAmountsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUnspentAmountsResponse.decode(value),
  },
  /**
   * Creates a transaction that splits funds into multiple smaller outputs.
   *
   * The `CoinSplit` call initiates a transaction that divides wallet funds into several equal-sized outputs.
   * This is useful for preparing a wallet for many small transactions (e.g., for micropayments or batching).
   * The resulting transaction is broadcast and can be tracked via its transaction ID.
   *
   * ### Request Parameters:
   *
   * - `amount_per_split` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The value of each individual output in the split.
   *   - **Restrictions**: Must be greater than zero.
   *
   * - `split_count` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The number of outputs to create.
   *   - **Restrictions**: Must be greater than zero and within practical system limits.
   *
   * - `fee_per_gram` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The transaction fee rate (per gram of weight).
   *   - **Restrictions**: Should be set high enough to ensure confirmation.
   *
   * - `lock_height` (optional):
   *   - **Type**: `uint64`
   *   - **Description**: The earliest block height at which the transaction becomes valid.
   *   - **Restrictions**: Defaults to 0 if not specified.
   *
   * - `payment_id` (optional):
   *   - **Type**: `bytes`
   *   - **Description**: A user-defined identifier for tracking or referencing the transaction.
   *   - **Restrictions**: Optional; can be left empty.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   amount_per_split: 100000,
   *   split_count: 5,
   *   fee_per_gram: 25,
   *   lock_height: 0,
   *   payment_id: new Uint8Array([])
   * };
   * client.coinSplit(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Created CoinSplit Tx ID:", response.tx_id);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "tx_id": 987654321
   * }
   * ```
   */
  coinSplit: {
    path: "/tari.rpc.Wallet/CoinSplit",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CoinSplitRequest) => Buffer.from(CoinSplitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CoinSplitRequest.decode(value),
    responseSerialize: (value: CoinSplitResponse) => Buffer.from(CoinSplitResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CoinSplitResponse.decode(value),
  },
  /**
   * Imports UTXOs into the wallet as spendable outputs.
   *
   * The `ImportUtxos` call allows you to manually insert one or more previously received UTXOs
   * into the wallet, marking them as spendable without needing rewindable metadata.
   * Each UTXO is associated with a transaction ID in the response.
   *
   * ### Request Parameters:
   *
   * - `outputs` (required):
   *   - **Type**: `repeated UnblindedOutput`
   *   - **Description**: A list of unblinded outputs to import into the wallet.
   *   - **Restrictions**:
   *     - Each output must be valid and convertible to an internal UTXO format.
   *     - The list must contain at least one item.
   *
   * - `payment_id` (optional):
   *   - **Type**: `bytes`
   *   - **Description**: An optional user-defined identifier to associate with the imported outputs.
   *   - **Restrictions**:
   *     - Can be left empty if not needed.
   *     - Must be a valid byte string if provided.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   outputs: [/* array of unblinded outputs * /],
   *   payment_id: new Uint8Array([])
   * };
   * client.importUtxos(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Imported Tx IDs:", response.tx_ids);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "tx_ids": [101, 102, 103]
   * }
   * ```
   */
  importUtxos: {
    path: "/tari.rpc.Wallet/ImportUtxos",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ImportUtxosRequest) => Buffer.from(ImportUtxosRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ImportUtxosRequest.decode(value),
    responseSerialize: (value: ImportUtxosResponse) => Buffer.from(ImportUtxosResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ImportUtxosResponse.decode(value),
  },
  /**
   * Returns the wallet's current network connectivity status.
   *
   * The `GetNetworkStatus` call provides a snapshot of the wallet's connection to the Tari network,
   * including whether it is online, the number of active peer connections, and the average latency
   * to the configured base node.
   *
   * ### Request Parameters:
   *
   * - *(none)*
   *   - This method uses an empty request body (`google.protobuf.Empty`).
   *   - No filters or arguments are required.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * client.getNetworkStatus({}, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Network Status:", response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "status": "ONLINE",
   *   "avg_latency_ms": 142,
   *   "num_node_connections": 8
   * }
   * ```
   *
   * ### Status Field Values:
   *
   * The `status` field indicates the current network connectivity of the wallet. Possible values are:
   *
   * - `ONLINE`:
   *   - The wallet is fully connected to the network and functioning normally.
   *   - The node has enough active peer connections to operate efficiently.
   *
   * - `DEGRADED`:
   *   - The wallet is connected to some peers but not enough to maintain full functionality.
   *   - This could indicate issues with network connectivity, such as intermittent disconnections or insufficient peers, leading to reduced performance or reliability.
   *
   * - `OFFLINE`:
   *   - The wallet is not connected to any peers.
   *   - This status means the wallet is unable to communicate with the network and cannot perform any network-related operations.
   */
  getNetworkStatus: {
    path: "/tari.rpc.Wallet/GetNetworkStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: NetworkStatusResponse) => Buffer.from(NetworkStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NetworkStatusResponse.decode(value),
  },
  /**
   * Returns a list of peers currently connected to the wallet.
   *
   * The `ListConnectedPeers` call retrieves information about peers that the wallet is currently
   * connected to. This includes details such as peer addresses, connection status, supported protocols,
   * and other metadata relevant to the connection.
   *
   * ### Request Parameters:
   *
   * - *(none)*
   *   - This method uses an empty request body (`google.protobuf.Empty`).
   *   - No filters or arguments are required.
   *
   * ### Response Fields:
   *
   * - **connected_peers**: List of peers currently connected to the wallet.
   *   - **public_key**: The peer's public key (bytes).
   *   - **node_id**: The unique node ID of the peer (bytes).
   *   - **addresses**: List of the peer's addresses (repeated Address).
   *   - **last_connection**: The timestamp of the last connection attempt (uint64).
   *   - **flags**: Flags associated with the peer (uint32).
   *   - **banned_until**: The timestamp until which the peer is banned (uint64, 0 if not banned).
   *   - **banned_reason**: The reason for banning the peer (string, empty if not banned).
   *   - **offline_at**: The timestamp indicating when the peer went offline (uint64, 0 if online).
   *   - **features**: The features supported by the peer (uint32).
   *   - **supported_protocols**: List of supported protocols by the peer (repeated bytes).
   *   - **user_agent**: The user agent advertised by the peer (string).
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * client.listConnectedPeers({}, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Connected Peers:", response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "connected_peers": [
   *     {
   *       "public_key": "0x1234abcd...",
   *       "node_id": "0x5678efgh...",
   *       "addresses": [
   *         "127.0.0.1:18080",
   *         "192.168.1.2:18080"
   *       ],
   *       "last_connection": 1625493123,
   *       "flags": 1,
   *       "banned_until": 0,
   *       "banned_reason": "",
   *       "offline_at": 0,
   *       "features": 10,
   *       "supported_protocols": [
   *         "protocol_v1",
   *         "protocol_v2"
   *       ],
   *       "user_agent": "TariBaseNode/1.0.0"
   *     }
   *   ]
   * }
   * ```
   */
  listConnectedPeers: {
    path: "/tari.rpc.Wallet/ListConnectedPeers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: ListConnectedPeersResponse) =>
      Buffer.from(ListConnectedPeersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListConnectedPeersResponse.decode(value),
  },
  /**
   * Cancels a specific transaction by its ID.
   *
   * The `CancelTransaction` call allows a transaction to be cancelled by its unique transaction ID (TxId).
   * If the cancellation is successful, the response will indicate success. Otherwise, the response will
   * contain a failure message with the reason for the failure.
   *
   * ### Request Parameters:
   *
   * - **tx_id**: The unique identifier for the transaction to be cancelled (uint64).
   *
   * ### Response Fields:
   *
   * - **is_success**: A boolean indicating whether the cancellation was successful (bool).
   *   - `true` if the cancellation was successful, `false` if not.
   * - **failure_message**: A string that provides the reason for the failure, if applicable (string).
   *   - This field will be empty if the cancellation was successful.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = { tx_id: 12345 };
   * client.cancelTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "is_success": true,
   *   "failure_message": ""
   * }
   * ```
   */
  cancelTransaction: {
    path: "/tari.rpc.Wallet/CancelTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelTransactionRequest) => Buffer.from(CancelTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CancelTransactionRequest.decode(value),
    responseSerialize: (value: CancelTransactionResponse) =>
      Buffer.from(CancelTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CancelTransactionResponse.decode(value),
  },
  /** Will trigger a complete revalidation of all wallet outputs. */
  revalidateAllTransactions: {
    path: "/tari.rpc.Wallet/RevalidateAllTransactions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RevalidateRequest) => Buffer.from(RevalidateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RevalidateRequest.decode(value),
    responseSerialize: (value: RevalidateResponse) => Buffer.from(RevalidateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RevalidateResponse.decode(value),
  },
  /** Will trigger a validation of all wallet outputs. */
  validateAllTransactions: {
    path: "/tari.rpc.Wallet/ValidateAllTransactions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateRequest) => Buffer.from(ValidateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ValidateRequest.decode(value),
    responseSerialize: (value: ValidateResponse) => Buffer.from(ValidateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ValidateResponse.decode(value),
  },
  /**
   * Sends a XTR SHA Atomic Swap transaction.
   *
   * The `SendShaAtomicSwapTransaction` call is used to initiate an Atomic Swap
   * transaction using SHA. It allows the sender to send a payment to the recipient
   * in exchange for an atomic swap, with SHA used as the secret for the swap.
   * The method accepts the recipient's information and initiates the transaction.
   *
   * ### Request Parameters:
   * - **recipient** (required): A PaymentRecipient object containing the recipient's address,
   *   the amount to be swapped, the fee per gram, and the payment ID to identify the transaction.
   *
   * ### Response Fields:
   * - **transaction_id**: The ID of the transaction.
   * - **pre_image**: The SHA pre-image of the atomic swap.
   * - **output_hash**: The hash of the output associated with the transaction.
   * - **is_success**: Indicates whether the transaction was successful (true) or failed (false).
   * - **failure_message**: Provides an error message if the transaction failed.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   recipient: {
   *     address: "t1abc12345",
   *     amount: 1000000,
   *     fee_per_gram: 10,
   *     payment_id: "0xdeadbeef"
   *   }
   * };
   * client.sendShaAtomicSwapTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "transaction_id": 123456789,
   *   "pre_image": "0xabcdef1234567890",
   *   "output_hash": "0x123456abcdef7890",
   *   "is_success": true,
   *   "failure_message": ""
   * }
   */
  sendShaAtomicSwapTransaction: {
    path: "/tari.rpc.Wallet/SendShaAtomicSwapTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendShaAtomicSwapRequest) => Buffer.from(SendShaAtomicSwapRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendShaAtomicSwapRequest.decode(value),
    responseSerialize: (value: SendShaAtomicSwapResponse) =>
      Buffer.from(SendShaAtomicSwapResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SendShaAtomicSwapResponse.decode(value),
  },
  /**
   * Creates a burn transaction for burning a specified amount of Tari currency.
   *
   * The `CreateBurnTransaction` call facilitates burning a certain amount of Tari
   * by initiating a burn transaction. It allows the user to specify the amount to burn,
   * along with a fee per gram and optionally a payment ID and claim public key.
   *
   * ### Request Parameters:
   * - **amount** (required): The amount of Tari to be burned.
   * - **fee_per_gram** (required): The fee per gram for the transaction.
   * - **claim_public_key** (optional): The public key to claim ownership of the burned coins.
   * - **payment_id** (optional): A unique identifier for the payment associated with the burn transaction.
   *
   * ### Response Fields:
   * - **transaction_id**: The ID of the burn transaction.
   * - **is_success**: Indicates whether the burn transaction was successfully created.
   * - **failure_message**: Provides an error message if the transaction creation failed.
   * - **commitment**: The commitment associated with the burn transaction.
   * - **ownership_proof**: A proof of ownership for the burned coins.
   * - **range_proof**: The range proof associated with the burned coins.
   * - **reciprocal_claim_public_key**: The public key of the reciprocal claim for the burn.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   amount: 1000000,
   *   fee_per_gram: 10,
   *   claim_public_key: "0xabcdef1234567890",
   *   payment_id: "0xdeadbeef"
   * };
   * client.createBurnTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "transaction_id": 123456789,
   *   "is_success": true,
   *   "failure_message": "",
   *   "commitment": "0xcommitmenthash",
   *   "ownership_proof": "0xownershipproof",
   *   "range_proof": "0xrangeproof",
   *   "reciprocal_claim_public_key": "0xreciprocalpublickey"
   * }
   */
  createBurnTransaction: {
    path: "/tari.rpc.Wallet/CreateBurnTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateBurnTransactionRequest) =>
      Buffer.from(CreateBurnTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateBurnTransactionRequest.decode(value),
    responseSerialize: (value: CreateBurnTransactionResponse) =>
      Buffer.from(CreateBurnTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateBurnTransactionResponse.decode(value),
  },
  /**
   * Claims a SHA Atomic Swap transaction using a pre-image and output hash.
   *
   * The `ClaimShaAtomicSwapTransaction` call allows the user to unlock and claim funds from
   * a hash-time-locked contract (HTLC) by supplying the correct pre-image that matches a
   * previously committed SHA-256 hash. This pre-image proves the user's knowledge of the
   * secret required to spend the output.
   *
   * ### Request Parameters:
   * - **output** (required): The hex-encoded output hash (SHA-256 digest) that was locked in the atomic swap.
   * - **pre_image** (required): The hex-encoded original pre-image (raw bytes, *not* hashed) which, when hashed with SHA-256, must match the `output` hash.
   * - **fee_per_gram** (required): The transaction fee per gram, specified as an unsigned integer.
   *
   * ### Input Validation:
   * - `output` must be a valid hex-encoded SHA-256 hash (64 hex characters).
   * - `pre_image` must be a valid hex string representing the original secret (any byte length, commonly 32 bytes).
   * - `fee_per_gram` must be a non-zero `uint64`; a fee of `0` may be rejected or deprioritized by the network.
   *
   * ### Response Fields:
   * - **results**: A `TransferResult` object containing transaction ID, success status, and an error message if applicable.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   output: "3e1f89af...e923", // SHA-256 hash of the expected pre-image
   *   pre_image: "6a1b2c...eaf1", // raw pre-image (not hashed)
   *   fee_per_gram: 10
   * };
   * client.claimShaAtomicSwapTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response.results);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "results": {
   *     "address": "",
   *     "transaction_id": 789654,
   *     "is_success": true,
   *     "failure_message": ""
   *   }
   * }
   */
  claimShaAtomicSwapTransaction: {
    path: "/tari.rpc.Wallet/ClaimShaAtomicSwapTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ClaimShaAtomicSwapRequest) =>
      Buffer.from(ClaimShaAtomicSwapRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ClaimShaAtomicSwapRequest.decode(value),
    responseSerialize: (value: ClaimShaAtomicSwapResponse) =>
      Buffer.from(ClaimShaAtomicSwapResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ClaimShaAtomicSwapResponse.decode(value),
  },
  /**
   * Claims an HTLC refund transaction after the timelock period has passed.
   *
   * The `ClaimHtlcRefundTransaction` call enables the original sender of a Hash Time-Locked Contract (HTLC)
   * to reclaim the locked funds if the recipient has not claimed them in time using the correct pre-image.
   * This is possible only after the output's timelock has expired.
   *
   * ### Request Parameters:
   * - **output_hash** (required): Hex-encoded SHA-256 hash of the HTLC output being refunded.
   * - **fee_per_gram** (required): Transaction fee per gram, specified as a `uint64`.
   *
   * ### Input Validation:
   * - `output_hash` must be a valid 64-character hex string representing the hash of the HTLC output.
   * - `fee_per_gram` must be a non-zero `uint64` value.
   *
   * ### Response Fields:
   * - **results**: A `TransferResult` object including transaction ID, success status, and failure reason if any.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   output_hash: "aabbccddeeff0011...99",
   *   fee_per_gram: 20
   * };
   * client.claimHtlcRefundTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response.results);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "results": {
   *     "address": "",
   *     "transaction_id": 889977,
   *     "is_success": true,
   *     "failure_message": ""
   *   }
   * }
   */
  claimHtlcRefundTransaction: {
    path: "/tari.rpc.Wallet/ClaimHtlcRefundTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ClaimHtlcRefundRequest) => Buffer.from(ClaimHtlcRefundRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ClaimHtlcRefundRequest.decode(value),
    responseSerialize: (value: ClaimHtlcRefundResponse) => Buffer.from(ClaimHtlcRefundResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ClaimHtlcRefundResponse.decode(value),
  },
  /** Creates a transaction with a template registration output */
  createTemplateRegistration: {
    path: "/tari.rpc.Wallet/CreateTemplateRegistration",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateTemplateRegistrationRequest) =>
      Buffer.from(CreateTemplateRegistrationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateTemplateRegistrationRequest.decode(value),
    responseSerialize: (value: CreateTemplateRegistrationResponse) =>
      Buffer.from(CreateTemplateRegistrationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateTemplateRegistrationResponse.decode(value),
  },
  /**
   * Signs a message using the wallet's node identity private key.
   *
   * The `SignMessage` call creates a Schnorr signature over a message using the wallet's node identity private key.
   * This signature can be used to prove ownership of the wallet or authenticate messages.
   * The signature is returned as separate components (signature and public nonce) for verification.
   *
   * ### Request Parameters:
   *
   * - `message` (required):
   *   - **Type**: `bytes`
   *   - **Description**: The message to be signed (arbitrary bytes).
   *   - **Restrictions**: Can be any byte sequence.
   *
   * ### Response Fields:
   *
   * - **signature**: The Schnorr signature as hex-encoded bytes.
   * - **public_nonce**: The public nonce component of the signature as hex-encoded bytes.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   message: Buffer.from("Hello Tari!", "utf-8")
   * };
   * client.signMessage(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Signature:", response.signature, "Nonce:", response.public_nonce);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "signature": "a1b2c3d4e5f6...",
   *   "public_nonce": "f6e5d4c3b2a1..."
   * }
   * ```
   *
   * ### Security Notes:
   *
   * - This signs with the wallet's node identity private key.
   * - The signature can be verified using the wallet's public key.
   * - Use this for authentication and ownership proofs only.
   */
  signMessage: {
    path: "/tari.rpc.Wallet/SignMessage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SignMessageRequest) => Buffer.from(SignMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SignMessageRequest.decode(value),
    responseSerialize: (value: SignMessageResponse) => Buffer.from(SignMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SignMessageResponse.decode(value),
  },
  /**
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const call = client.streamTransactionEvents({});
   *
   * call.on("data", (response) => {
   *   console.log("Transaction Event:", response.transaction);
   * });
   *
   * call.on("end", () => {
   *   console.log("Stream ended.");
   * });
   *
   * call.on("error", (err) => {
   *   console.error("Stream error:", err);
   * });
   * ```
   *
   * ### Sample JSON Streamed Response:
   * ```json
   * {
   *   "transaction": {
   *     "event": "Mined",
   *     "tx_id": "103248",
   *     "source_address": "0xabc123...",
   *     "dest_address": "0xdef456...",
   *     "status": "Completed",
   *     "direction": "Outbound",
   *     "amount": 100000000,
   *     "payment_id": "0xdeadbeef..."
   *   }
   * }
   * ```
   */
  streamTransactionEvents: {
    path: "/tari.rpc.Wallet/StreamTransactionEvents",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: TransactionEventRequest) => Buffer.from(TransactionEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TransactionEventRequest.decode(value),
    responseSerialize: (value: TransactionEventResponse) =>
      Buffer.from(TransactionEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionEventResponse.decode(value),
  },
  importTransactions: {
    path: "/tari.rpc.Wallet/ImportTransactions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ImportTransactionsRequest) =>
      Buffer.from(ImportTransactionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ImportTransactionsRequest.decode(value),
    responseSerialize: (value: ImportTransactionsResponse) =>
      Buffer.from(ImportTransactionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ImportTransactionsResponse.decode(value),
  },
  /**
   * Get all completed transactions including cancelled ones, sorted by timestamp and paginated
   * DEPRECATED: Use GetAllCompletedTransactionsStream for better performance and memory efficiency
   *
   * @deprecated
   */
  getAllCompletedTransactions: {
    path: "/tari.rpc.Wallet/GetAllCompletedTransactions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAllCompletedTransactionsRequest) =>
      Buffer.from(GetAllCompletedTransactionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllCompletedTransactionsRequest.decode(value),
    responseSerialize: (value: GetAllCompletedTransactionsResponse) =>
      Buffer.from(GetAllCompletedTransactionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllCompletedTransactionsResponse.decode(value),
  },
  /**
   * Get all completed transactions including cancelled ones, sorted by timestamp and paginated (streaming version)
   * Recommended: Use this streaming version for better performance and progressive loading
   */
  getAllCompletedTransactionsStream: {
    path: "/tari.rpc.Wallet/GetAllCompletedTransactionsStream",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: GetAllCompletedTransactionsRequest) =>
      Buffer.from(GetAllCompletedTransactionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllCompletedTransactionsRequest.decode(value),
    responseSerialize: (value: GetCompletedTransactionsResponse) =>
      Buffer.from(GetCompletedTransactionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetCompletedTransactionsResponse.decode(value),
  },
  /**
   * Gets transaction information by payment reference (PayRef)
   *
   * The `GetPaymentByReference` call retrieves transaction information using a 32-byte payment reference hash.
   * PayRefs are generated as Blake2b_256(block_hash || output_hash) and provide a stable way to look up
   * transactions even after outputs are spent.
   *
   * ### Request Parameters:
   *
   * - `payment_reference` (required):
   *   - **Type**: `bytes` (32 bytes)
   *   - **Description**: The payment reference hash to look up
   *   - **Restrictions**: Must be exactly 32 bytes representing a valid PayRef
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const payref = Buffer.from('a1b2c3d4e5f6789012345678901234567890123456789012345678901234567890', 'hex');
   * const request = { payment_reference: payref };
   * client.getPaymentByReference(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log('Transaction found:', response.transaction);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "transaction": {
   *     "tx_id": 12345,
   *     "source_address": "0x1234abcd...",
   *     "dest_address": "0x5678efgh...",
   *     "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
   *     "direction": "TRANSACTION_DIRECTION_INBOUND",
   *     "amount": 1000000,
   *     "fee": 20,
   *     "is_cancelled": false,
   *     "excess_sig": "0xabcdef...",
   *     "timestamp": 1681234567,
   *     "payment_id": "0xdeadbeef...",
   *     "mined_in_block_height": 150000
   *   }
   * }
   * ```
   */
  getPaymentByReference: {
    path: "/tari.rpc.Wallet/GetPaymentByReference",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPaymentByReferenceRequest) =>
      Buffer.from(GetPaymentByReferenceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPaymentByReferenceRequest.decode(value),
    responseSerialize: (value: GetPaymentByReferenceResponse) =>
      Buffer.from(GetPaymentByReferenceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetPaymentByReferenceResponse.decode(value),
  },
  /**
   * Estimates the transaction fee based on amount, fee rate, and number of outputs.
   *
   * The `GetFeeEstimate` call allows clients to calculate the expected transaction fee before sending funds.
   * This is useful for presenting fee information to the user or for ensuring sufficient funds are available.
   *
   * ### Request Parameters:
   * - **amount** (required): The amount to send, in microTari. (1 Tari = 1,000,000 µT).
   * - **fee_per_gram** (required): The fee per gram (weight unit) to use for the estimate. Higher values may improve priority.
   * - **output_count** (required): The number of outputs to create in the transaction (e.g., 2 = recipient + change).
   *
   * ### Input Validation:
   * - `amount` must be a non-zero `uint64` representing the amount to transfer.
   * - `fee_per_gram` must be a non-zero `uint64`; zero or low fees may result in delayed confirmation or failure.
   * - `output_count` must be convertible to a valid `usize`; large values may increase the fee significantly.
   *
   * ### Response Fields:
   * - **estimated_fee**: A `uint64` value representing the estimated total transaction fee in microTari.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   amount: 1000000,         // Sending 1 Tari
   *   fee_per_gram: 5,         // Fee rate of 5 µT/g
   *   output_count: 2          // One recipient + one change output
   * };
   * client.getFeeEstimate(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Estimated fee:", response.estimated_fee);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "estimated_fee": 12345
   * }
   * ```
   */
  getFeeEstimate: {
    path: "/tari.rpc.Wallet/GetFeeEstimate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetFeeEstimateRequest) => Buffer.from(GetFeeEstimateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetFeeEstimateRequest.decode(value),
    responseSerialize: (value: GetFeeEstimateResponse) => Buffer.from(GetFeeEstimateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetFeeEstimateResponse.decode(value),
  },
  /**
   * Retrieves fee-per-gram statistics over recent blocks.
   *
   * The `GetFeePerGramStats` call returns aggregated fee rate information to help clients
   * understand recent network fee trends. This can be used for setting appropriate fees
   * when constructing transactions.
   *
   * ### Request Parameters:
   * - **block_count** (optional): The number of recent blocks to include in the statistics.
   *   If not specified or zero, a default number of blocks will be used.
   *
   * ### Input Validation:
   * - `block_count` must be a non-negative `uint64`. Large values may increase query time.
   *
   * ### Response Fields:
   * - **fee_per_gram_stats**: A list of `FeePerGramStat` objects summarizing fee data over the specified blocks.
   *
   * Each `FeePerGramStat` contains:
   * - **average_fee_per_gram**: Average fee per gram observed over the blocks.
   * - **min_fee_per_gram**: Minimum fee per gram observed.
   * - **max_fee_per_gram**: Maximum fee per gram observed.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   block_count: 10 // Consider fees over the last 10 blocks
   * };
   * client.getFeePerGramStats(request, (err, response) => {
   *   if (err) console.error(err);
   *   else response.fee_per_gram_stats.forEach(stat => {
   *     console.log(`Avg: ${stat.average_fee_per_gram}, Min: ${stat.min_fee_per_gram}, Max: ${stat.max_fee_per_gram}`);
   *   });
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "fee_per_gram_stats": [
   *     {
   *       "average_fee_per_gram": 5,
   *       "min_fee_per_gram": 3,
   *       "max_fee_per_gram": 10
   *     }
   *   ]
   * }
   * ```
   */
  getFeePerGramStats: {
    path: "/tari.rpc.Wallet/GetFeePerGramStats",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetFeePerGramStatsRequest) =>
      Buffer.from(GetFeePerGramStatsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetFeePerGramStatsRequest.decode(value),
    responseSerialize: (value: GetFeePerGramStatsResponse) =>
      Buffer.from(GetFeePerGramStatsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetFeePerGramStatsResponse.decode(value),
  },
  /**
   * Attempts to replace an existing transaction with a new one that has a higher fee.
   *
   * The `ReplaceByFee` call enables clients to increase the fee of a pending transaction,
   * potentially speeding up its confirmation by incentivizing miners to prioritize it.
   *
   * ### Request Parameters:
   * - **transaction_id** (required): The ID of the original transaction to replace.
   * - **fee_increase** (required): The additional fee amount to add, specified in microTari.
   *   Must be greater than zero.
   *
   * ### Input Validation:
   * - `transaction_id` must correspond to a currently unconfirmed transaction.
   * - `fee_increase` must be a non-zero `uint64`. Zero or negative values are invalid.
   *
   * ### Response Fields:
   * - **transaction_id**: The transaction ID of the new replacement transaction.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   transaction_id: 123456,
   *   fee_increase: 5000  // Increase fee by 5,000 microTari
   * };
   * client.replaceByFee(request, (err, response) => {
   *   if (err) console.error("Failed to replace by fee:", err);
   *   else console.log("Replacement transaction ID:", response.transaction_id);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "transaction_id": 7891011
   * }
   * ```
   */
  replaceByFee: {
    path: "/tari.rpc.Wallet/ReplaceByFee",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReplaceByFeeRequest) => Buffer.from(ReplaceByFeeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ReplaceByFeeRequest.decode(value),
    responseSerialize: (value: ReplaceByFeeResponse) => Buffer.from(ReplaceByFeeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ReplaceByFeeResponse.decode(value),
  },
  /**
   * Allows users to pay a specified fee for spending transaction outputs to given recipients.
   *
   * The `UserPayForFee` call enables clients to request that the wallet pays the fee
   * for one or more transactions identified by their IDs, sending funds to the specified recipients.
   * This is useful for fee bumping or covering transaction fees on behalf of recipients.
   *
   * ### Request Parameters:
   * - **recipients** (required): A list of transfers, each specifying:
   *    - `tx_id`: The transaction ID whose outputs will be spent.
   *    - `fee`: The fee amount in microTari to pay for this transfer.
   *    - `destination`: The Base58-encoded Tari address of the recipient.
   *
   * ### Input Validation:
   * - Each `tx_id` must correspond to a valid transaction whose outputs can be spent.
   * - Each `fee` must be a non-negative uint64 specifying the fee to pay.
   * - Each `destination` must be a valid Base58 Tari address.
   *
   * ### Response Fields:
   * - **results**: A list of `TransferResult` objects, one per requested recipient, each containing:
   *    - `address`: The recipient address as a string.
   *    - `transaction_id`: The ID of the newly created transaction (or zero if failed).
   *    - `is_success`: Boolean indicating if the fee payment transaction succeeded.
   *    - `failure_message`: A string describing the error if the transaction failed.
   *    - `transaction_info`: Detailed transaction metadata if available.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   recipients: [
   *     {
   *       tx_id: 123,
   *       fee: 1000,
   *       destination: "tari1qxyz..."
   *     },
   *     {
   *       tx_id: 456,
   *       fee: 2000,
   *       destination: "tari1qabcd..."
   *     }
   *   ]
   * };
   * client.userPayForFee(request, (err, response) => {
   *   if (err) console.error("Fee payment failed:", err);
   *   else {
   *     response.results.forEach(result => {
   *       if (result.is_success) {
   *         console.log(`Fee paid successfully to ${result.address} in tx ${result.transaction_id}`);
   *       } else {
   *         console.error(`Failed to pay fee for ${result.address}: ${result.failure_message}`);
   *       }
   *     });
   *   }
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "results": [
   *     {
   *       "address": "tari1qxyz...",
   *       "transaction_id": 789,
   *       "is_success": true,
   *       "failure_message": "",
   *       "transaction_info": {
   *         "tx_id": 789,
   *         "source_address": "...",
   *         "dest_address": "...",
   *         "status": "Completed",
   *         "direction": "Outbound",
   *         "amount": 50000,
   *         "fee": 1000,
   *         "is_cancelled": false,
   *         "timestamp": 1620000000
   *       }
   *     },
   *     {
   *       "address": "tari1qabcd...",
   *       "transaction_id": 0,
   *       "is_success": false,
   *       "failure_message": "Invalid destination address",
   *       "transaction_info": null
   *     }
   *   ]
   * }
   * ```
   */
  userPayForFee: {
    path: "/tari.rpc.Wallet/UserPayForFee",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserPayForFeeRequest) => Buffer.from(UserPayForFeeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UserPayForFeeRequest.decode(value),
    responseSerialize: (value: UserPayForFeeResponse) => Buffer.from(UserPayForFeeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UserPayForFeeResponse.decode(value),
  },
  registerValidatorNode: {
    path: "/tari.rpc.Wallet/RegisterValidatorNode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegisterValidatorNodeRequest) =>
      Buffer.from(RegisterValidatorNodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RegisterValidatorNodeRequest.decode(value),
    responseSerialize: (value: RegisterValidatorNodeResponse) =>
      Buffer.from(RegisterValidatorNodeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RegisterValidatorNodeResponse.decode(value),
  },
  submitValidatorEvictionProof: {
    path: "/tari.rpc.Wallet/SubmitValidatorEvictionProof",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SubmitValidatorEvictionProofRequest) =>
      Buffer.from(SubmitValidatorEvictionProofRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SubmitValidatorEvictionProofRequest.decode(value),
    responseSerialize: (value: SubmitValidatorEvictionProofResponse) =>
      Buffer.from(SubmitValidatorEvictionProofResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SubmitValidatorEvictionProofResponse.decode(value),
  },
  submitValidatorNodeExit: {
    path: "/tari.rpc.Wallet/SubmitValidatorNodeExit",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SubmitValidatorNodeExitRequest) =>
      Buffer.from(SubmitValidatorNodeExitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SubmitValidatorNodeExitRequest.decode(value),
    responseSerialize: (value: SubmitValidatorNodeExitResponse) =>
      Buffer.from(SubmitValidatorNodeExitResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SubmitValidatorNodeExitResponse.decode(value),
  },
} as const;

export interface WalletServer extends UntypedServiceImplementation {
  getVersion: handleUnaryCall<GetVersionRequest, GetVersionResponse>;
  /**
   * Returns the current operational state of the wallet.
   *
   * This RPC provides an overview of the wallet's internal status, including:
   * - The latest blockchain height scanned by the wallet
   * - The current balance (available, pending incoming/outgoing)
   * - Network connectivity status with the base node
   *
   * This is commonly used by UI clients or backend systems to confirm the wallet is healthy,
   * synchronized, and connected to the Tari network.
   *
   * Example usage (JavaScript):
   * ```javascript
   * const response = await client.getState({});
   * console.log(response.scanned_height); // e.g., 1523493
   * console.log(response.balance.available_balance); // e.g., 1234567890
   * console.log(response.network.status); // e.g., "Online"
   * ```
   *
   * Example response:
   * ```json
   * {
   *   "scanned_height": 1523493,
   *   "balance": {
   *     "available_balance": 1234567890,
   *     "pending_incoming_balance": 100000000,
   *     "pending_outgoing_balance": 0
   *   },
   *   "network": {
   *     "status": "Online",
   *     "avg_latency_ms": 28,
   *     "num_node_connections": 8
   *   }
   * }
   * ```
   */
  getState: handleUnaryCall<GetStateRequest, GetStateResponse>;
  /**
   * This RPC returns a lightweight response indicating whether the wallet is connected to the network, attempting to connect, or currently offline. This is useful for UIs or clients to determine if network interactions like transactions or syncs are possible.
   *
   * Example usage (JavaScript):
   * ```javascript
   * const response = await client.checkConnectivity({});
   * console.log(response.status); // e.g., 1 (Online)
   * ```
   *
   * Example response:
   * ```json
   * {
   *   "status": "Online"
   * }
   * ```
   */
  checkConnectivity: handleUnaryCall<GetConnectivityRequest, CheckConnectivityResponse>;
  /** Check for new updates */
  checkForUpdates: handleUnaryCall<Empty, SoftwareUpdate>;
  /**
   * The `Identify` RPC call returns the identity information of the wallet node.
   * This includes:
   * - **Public Key**: The wallet's cryptographic public key.
   * - **Public Address**: The wallet's public address used to receive funds.
   * - **Node ID**: The unique identifier of the wallet node in the network.
   *
   * Example usage (JavaScript):
   * ```javascript
   * // Call the Identify RPC method
   * client.Identify({}, (error, response) => {
   *   if (error) {
   *     console.error('Error:', error);
   *   } else {
   *     console.log('Identity Response:', response);
   *   }
   * });
   * ```
   *
   * **Sample JSON Response:**
   *
   * ```json
   * {
   *   "public_key": "0x04b2c5f3fe65bb1c3cde019e34f3eab1234598c820dca43bbf4d5686a980ddc69e0d4b180d85990d0a5e4aee46e0a6ad9283f0a41783992a70c548e53e47321fa",
   *   "public_address": "14HVCEeZC2RGE4SDn3yGwqzXepJ2LDqXva7kb4fherYMQR9dF7341T3TjMZobB1a6xouGvS5SXwEvXKwK3zLz2rgReh",
   *   "node_id": "0x1234abcd5678efgh9012ijkl3456mnop"
   * }
   * ```
   */
  identify: handleUnaryCall<GetIdentityRequest, GetIdentityResponse>;
  /**
   * This RPC returns two types of wallet addresses: interactive and one-sided addresses.
   * It provides these addresses in byte format as part of the response.
   * - **Interactive Address**: This is a type of address used for interaction and communication with the wallet.
   * - **One-Sided Address**: This is another address type, typically used in scenarios where a one-way interaction or transaction is needed.
   *
   * Example usage (JavaScript):
   * // Call the GetAddress RPC method
   * client.GetAddress({}, (error, response) => {
   *   if (error) {
   *     console.error('Error:', error);
   *   } else {
   *     console.log('Address Response:', response);
   *   }
   * });
   * ```
   *
   * **Sample JSON Response:**
   *  // ```json
   * {
   *   "interactive_address": "0x14b27bde3f7d9c9d7455f16b056a3c439c663af93356f56e16d2b2c79e6995c44c9c6c7c",
   *   "one_sided_address": "0x12b35ddcb2270a72d7b327abc7cd4f607a492c6e13e72e65c34742069e48bd3bc462df63"
   * }
   * ```
   */
  getAddress: handleUnaryCall<Empty, GetAddressResponse>;
  /**
   * This RPC returns addresses generated for a specific payment ID. It provides both the interactive
   * and one-sided addresses for the given payment ID, along with their respective representations in
   * base58 and emoji formats.
   *
   * Example usage (JavaScript):
   *
   * ```javascript
   * // Prepare the payment ID for the request
   * const paymentId = Buffer.from('your_payment_id_here', 'hex');
   * const request = { payment_id: paymentId };
   *
   * // Call the GetPaymentIdAddress RPC method
   * client.GetPaymentIdAddress(request, (error, response) => {
   *   if (error) {
   *     console.error('Error:', error);
   *   } else {
   *     console.log('Payment ID Address Response:', response);
   *   }
   * });
   * ```
   *
   * **Sample JSON Response:**
   *
   * ```json
   * {
   *  "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
   *  "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
   *  "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
   *  "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
   *  "interactive_address_emoji": "🐢🌊💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭",
   *  "one_sided_address_emoji": "🐢📟💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞📜.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭"
   * }
   * ```
   */
  getPaymentIdAddress: handleUnaryCall<GetPaymentIdAddressRequest, GetCompleteAddressResponse>;
  /**
   * This RPC call that retrieves the current wallet's interactive and one-sided addresses in multiple formats and returns them in a structured response.
   * The response includes:
   * - Raw binary
   * - Base58-encoded (human-readable)
   * - Emoji-encoded (for fun and friendliness)
   *
   * Example usage (JavaScript with gRPC):
   *
   * ```js
   * const client = new WalletClient('localhost:50051', grpc.credentials.createInsecure());
   * client.getCompleteAddress({}, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response);
   * });
   * ```
   *
   * Sample response:
   * ```json
   * {
   *  "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
   *  "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
   *  "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
   *  "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
   *  "interactive_address_emoji": "🐢🌊💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭",
   *  "one_sided_address_emoji": "🐢📟💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞📜.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭"
   * }
   * ```
   */
  getCompleteAddress: handleUnaryCall<Empty, GetCompleteAddressResponse>;
  prepareOneSidedTransactionForSigning: handleUnaryCall<
    PrepareOneSidedTransactionForSigningRequest,
    PrepareOneSidedTransactionForSigningResponse
  >;
  broadcastSignedOneSidedTransaction: handleUnaryCall<
    BroadcastSignedOneSidedTransactionRequest,
    BroadcastSignedOneSidedTransactionResponse
  >;
  /**
   * This call supports standard interactive transactions (Mimblewimble),
   * one-sided transactions, and one-sided-to-stealth-address transactions.
   * Each recipient must include a valid Tari address, amount, fee, and payment type.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const recipient = new PaymentRecipient();
   * recipient.setAddress("14HVCEeZ...");
   * recipient.setAmount(1000000); // 1 T
   * recipient.setFeePerGram(25);
   * recipient.setPaymentType(PaymentType.ONE_SIDED);
   * recipient.setPaymentId(Buffer.from("abc123", "utf-8"));
   *
   * const request = new TransferRequest();
   * request.setRecipientsList([recipient]);
   *
   * client.transfer(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response.toObject());
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "results": [
   *     {
   *       "address": "14HVCEeZ...",
   *       "transaction_id": 12345,
   *       "is_success": true,
   *       "failure_message": ""
   *     }
   *   ]
   * }
   */
  transfer: handleUnaryCall<TransferRequest, TransferResponse>;
  /**
   * Returns the transaction details for the given transaction IDs.
   *
   * The GetTransactionInfo RPC retrieves detailed information about specific transactions based on their IDs.
   * The response includes details such as transaction status, direction, amount, fee, and more.
   *
   * ### Request Parameters:
   *
   * - `transaction_ids` (required):
   *   - **Type**: `repeated uint64`
   *   - **Description**: A list of transaction IDs to query.
   *   - **Restrictions**:
   *     - Must contain at least one ID.
   *     - All IDs must be valid unsigned 64-bit integers.
   *     - Duplicates will be ignored; only the first occurrence is processed.
   *     - If a transaction ID is not found, it will be returned with a `status` of `NOT_FOUND`.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = { transaction_ids: [12345, 67890] };
   * client.getTransactionInfo(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response.transactions);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "transactions": [
   *     {
   *       "tx_id": 12345,
   *       "source_address": "0x1234abcd...",
   *       "dest_address": "0x5678efgh...",
   *       "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
   *       "direction": "TRANSACTION_DIRECTION_OUTBOUND",
   *       "amount": 1000000,
   *       "fee": 25,
   *       "is_cancelled": false,
   *       "excess_sig": "0xabcdef...",
   *       "timestamp": 1681234567,
   *       "payment_id": "0xdeadbeef...",
   *       "mined_in_block_height": 1523493
   *     }
   *   ]
   * }
   */
  getTransactionInfo: handleUnaryCall<GetTransactionInfoRequest, GetTransactionInfoResponse>;
  /**
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   payment_id: {
   *     utf8_string: "invoice-001"
   *   }
   * };
   * const call = client.getCompletedTransactions(request);
   * call.on('data', (response) => {
   *   console.log(response.transaction);
   * });
   * call.on('error', console.error);
   * call.on('end', () => console.log("Stream ended"));
   * ```
   *
   * ### Sample Streamed JSON Response:
   *
   * ```json
   * {
   *   "transaction": {
   *     "tx_id": 12345,
   *     "source_address": "0x1234abcd...",
   *     "dest_address": "0x5678efgh...",
   *     "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
   *     "direction": "TRANSACTION_DIRECTION_INBOUND",
   *     "amount": 500000,
   *     "fee": 20,
   *     "is_cancelled": false,
   *     "excess_sig": "0xabcdef...",
   *     "timestamp": 1681234567,
   *     "payment_id": "0xdeadbeef...",
   *     "mined_in_block_height": 1523493
   *   }
   * }
   * ```
   */
  getCompletedTransactions: handleServerStreamingCall<
    GetCompletedTransactionsRequest,
    GetCompletedTransactionsResponse
  >;
  /**
   * Returns all transactions that were mined at a specific block height.
   *
   * The `GetBlockHeightTransactions` call retrieves all wallet transactions that were mined
   * at the specified block height. The response includes all transactions in a single response,
   * with each transaction including details such as status, direction, amount,
   * fees, and associated metadata.
   *
   * ### Request Parameters:
   *
   * - `block_height` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The specific block height to fetch transactions for.
   *   - **Restrictions**:
   *     - Must be a valid block height (greater than 0).
   *     - If the block height is beyond the current chain height, no transactions will be returned.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   block_height: 1523493
   * };
   * const response = await client.getBlockHeightTransactions(request);
   * console.log(response.transactions);
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "transactions": [
   *     {
   *       "tx_id": 12345,
   *       "source_address": "0x1234abcd...",
   *       "dest_address": "0x5678efgh...",
   *       "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
   *       "direction": "TRANSACTION_DIRECTION_INBOUND",
   *       "amount": 500000,
   *       "fee": 20,
   *       "is_cancelled": false,
   *       "excess_sig": "0xabcdef...",
   *       "timestamp": 1681234567,
   *       "payment_id": "0xdeadbeef...",
   *       "mined_in_block_height": 1523493
   *     }
   *   ]
   * }
   * ```
   */
  getBlockHeightTransactions: handleUnaryCall<GetBlockHeightTransactionsRequest, GetBlockHeightTransactionsResponse>;
  /**
   * Returns all PayRefs (payment references) for a specific transaction.
   *
   * The `GetTransactionPayRefs` call retrieves all PayRefs associated with the specified
   * transaction ID. PayRefs are cryptographic references generated from output hashes
   * that allow recipients to verify payments without revealing sensitive transaction details.
   *
   * ### Request Parameters:
   *
   * - `transaction_id` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The transaction ID to retrieve PayRefs for.
   *   - **Restrictions**:
   *     - Must be a valid transaction ID that exists in the wallet.
   *     - If the transaction ID is invalid or not found, an error will be returned.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   transaction_id: 12345
   * };
   * const response = await client.getTransactionPayRefs(request);
   * console.log("PayRefs:", response.payment_references.map(ref => Buffer.from(ref).toString('hex')));
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "payment_references": [
   *     "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
   *     "0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"
   *   ]
   * }
   * ```
   */
  getTransactionPayRefs: handleUnaryCall<GetTransactionPayRefsRequest, GetTransactionPayRefsResponse>;
  /**
   * Returns the wallet balance details.
   *
   * The `GetBalance` call retrieves the current balance status of the wallet,
   * optionally filtered by a specific `payment_id`. The response includes detailed
   * breakdowns of available, pending incoming/outgoing, and timelocked balances.
   *
   * ### Request Parameters:
   *
   * - `payment_id` (optional):
   *   - **Type**: `UserPaymentId` (one of several formats).
   *   - **Description**: An optional filter to retrieve the balance associated with a specific payment ID.
   *   - **Accepted Formats** (must provide **only one**):
   *     - `u256`: a 32-byte hexadecimal identifier.
   *     - `utf8_string`: a human-readable string ID.
   *     - `user_bytes`: raw binary bytes.
   *   - **Restrictions**:
   *     - Only one format must be provided at a time.
   *     - If multiple or no formats are provided within `payment_id`, the request will return an error.
   *     - If `payment_id` is omitted, the total wallet balance is returned.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   payment_id: {
   *     utf8_string: "invoice-002"
   *   }
   * };
   * client.getBalance(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Balance:", response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "available_balance": 950000,
   *   "pending_incoming_balance": 200000,
   *   "pending_outgoing_balance": 50000,
   *   "timelocked_balance": 100000
   * }
   * ```
   */
  getBalance: handleUnaryCall<GetBalanceRequest, GetBalanceResponse>;
  /**
   * Returns the total value of unspent outputs in the wallet.
   *
   * The `GetUnspentAmounts` call retrieves the sum of all unspent output amounts
   * currently held by the wallet. These are outputs that have not yet been spent or time-locked,
   * and are available for future transactions.
   *
   * ### Request Parameters:
   *
   * - *(none)*
   *   - This method uses an empty request body (`google.protobuf.Empty`).
   *   - No filters or arguments are required.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * client.getUnspentAmounts({}, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Total unspent amount:", response.amount);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "amount": 1250000
   * }
   * ```
   */
  getUnspentAmounts: handleUnaryCall<Empty, GetUnspentAmountsResponse>;
  /**
   * Creates a transaction that splits funds into multiple smaller outputs.
   *
   * The `CoinSplit` call initiates a transaction that divides wallet funds into several equal-sized outputs.
   * This is useful for preparing a wallet for many small transactions (e.g., for micropayments or batching).
   * The resulting transaction is broadcast and can be tracked via its transaction ID.
   *
   * ### Request Parameters:
   *
   * - `amount_per_split` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The value of each individual output in the split.
   *   - **Restrictions**: Must be greater than zero.
   *
   * - `split_count` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The number of outputs to create.
   *   - **Restrictions**: Must be greater than zero and within practical system limits.
   *
   * - `fee_per_gram` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The transaction fee rate (per gram of weight).
   *   - **Restrictions**: Should be set high enough to ensure confirmation.
   *
   * - `lock_height` (optional):
   *   - **Type**: `uint64`
   *   - **Description**: The earliest block height at which the transaction becomes valid.
   *   - **Restrictions**: Defaults to 0 if not specified.
   *
   * - `payment_id` (optional):
   *   - **Type**: `bytes`
   *   - **Description**: A user-defined identifier for tracking or referencing the transaction.
   *   - **Restrictions**: Optional; can be left empty.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   amount_per_split: 100000,
   *   split_count: 5,
   *   fee_per_gram: 25,
   *   lock_height: 0,
   *   payment_id: new Uint8Array([])
   * };
   * client.coinSplit(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Created CoinSplit Tx ID:", response.tx_id);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "tx_id": 987654321
   * }
   * ```
   */
  coinSplit: handleUnaryCall<CoinSplitRequest, CoinSplitResponse>;
  /**
   * Imports UTXOs into the wallet as spendable outputs.
   *
   * The `ImportUtxos` call allows you to manually insert one or more previously received UTXOs
   * into the wallet, marking them as spendable without needing rewindable metadata.
   * Each UTXO is associated with a transaction ID in the response.
   *
   * ### Request Parameters:
   *
   * - `outputs` (required):
   *   - **Type**: `repeated UnblindedOutput`
   *   - **Description**: A list of unblinded outputs to import into the wallet.
   *   - **Restrictions**:
   *     - Each output must be valid and convertible to an internal UTXO format.
   *     - The list must contain at least one item.
   *
   * - `payment_id` (optional):
   *   - **Type**: `bytes`
   *   - **Description**: An optional user-defined identifier to associate with the imported outputs.
   *   - **Restrictions**:
   *     - Can be left empty if not needed.
   *     - Must be a valid byte string if provided.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   outputs: [/* array of unblinded outputs * /],
   *   payment_id: new Uint8Array([])
   * };
   * client.importUtxos(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Imported Tx IDs:", response.tx_ids);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "tx_ids": [101, 102, 103]
   * }
   * ```
   */
  importUtxos: handleUnaryCall<ImportUtxosRequest, ImportUtxosResponse>;
  /**
   * Returns the wallet's current network connectivity status.
   *
   * The `GetNetworkStatus` call provides a snapshot of the wallet's connection to the Tari network,
   * including whether it is online, the number of active peer connections, and the average latency
   * to the configured base node.
   *
   * ### Request Parameters:
   *
   * - *(none)*
   *   - This method uses an empty request body (`google.protobuf.Empty`).
   *   - No filters or arguments are required.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * client.getNetworkStatus({}, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Network Status:", response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "status": "ONLINE",
   *   "avg_latency_ms": 142,
   *   "num_node_connections": 8
   * }
   * ```
   *
   * ### Status Field Values:
   *
   * The `status` field indicates the current network connectivity of the wallet. Possible values are:
   *
   * - `ONLINE`:
   *   - The wallet is fully connected to the network and functioning normally.
   *   - The node has enough active peer connections to operate efficiently.
   *
   * - `DEGRADED`:
   *   - The wallet is connected to some peers but not enough to maintain full functionality.
   *   - This could indicate issues with network connectivity, such as intermittent disconnections or insufficient peers, leading to reduced performance or reliability.
   *
   * - `OFFLINE`:
   *   - The wallet is not connected to any peers.
   *   - This status means the wallet is unable to communicate with the network and cannot perform any network-related operations.
   */
  getNetworkStatus: handleUnaryCall<Empty, NetworkStatusResponse>;
  /**
   * Returns a list of peers currently connected to the wallet.
   *
   * The `ListConnectedPeers` call retrieves information about peers that the wallet is currently
   * connected to. This includes details such as peer addresses, connection status, supported protocols,
   * and other metadata relevant to the connection.
   *
   * ### Request Parameters:
   *
   * - *(none)*
   *   - This method uses an empty request body (`google.protobuf.Empty`).
   *   - No filters or arguments are required.
   *
   * ### Response Fields:
   *
   * - **connected_peers**: List of peers currently connected to the wallet.
   *   - **public_key**: The peer's public key (bytes).
   *   - **node_id**: The unique node ID of the peer (bytes).
   *   - **addresses**: List of the peer's addresses (repeated Address).
   *   - **last_connection**: The timestamp of the last connection attempt (uint64).
   *   - **flags**: Flags associated with the peer (uint32).
   *   - **banned_until**: The timestamp until which the peer is banned (uint64, 0 if not banned).
   *   - **banned_reason**: The reason for banning the peer (string, empty if not banned).
   *   - **offline_at**: The timestamp indicating when the peer went offline (uint64, 0 if online).
   *   - **features**: The features supported by the peer (uint32).
   *   - **supported_protocols**: List of supported protocols by the peer (repeated bytes).
   *   - **user_agent**: The user agent advertised by the peer (string).
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * client.listConnectedPeers({}, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Connected Peers:", response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "connected_peers": [
   *     {
   *       "public_key": "0x1234abcd...",
   *       "node_id": "0x5678efgh...",
   *       "addresses": [
   *         "127.0.0.1:18080",
   *         "192.168.1.2:18080"
   *       ],
   *       "last_connection": 1625493123,
   *       "flags": 1,
   *       "banned_until": 0,
   *       "banned_reason": "",
   *       "offline_at": 0,
   *       "features": 10,
   *       "supported_protocols": [
   *         "protocol_v1",
   *         "protocol_v2"
   *       ],
   *       "user_agent": "TariBaseNode/1.0.0"
   *     }
   *   ]
   * }
   * ```
   */
  listConnectedPeers: handleUnaryCall<Empty, ListConnectedPeersResponse>;
  /**
   * Cancels a specific transaction by its ID.
   *
   * The `CancelTransaction` call allows a transaction to be cancelled by its unique transaction ID (TxId).
   * If the cancellation is successful, the response will indicate success. Otherwise, the response will
   * contain a failure message with the reason for the failure.
   *
   * ### Request Parameters:
   *
   * - **tx_id**: The unique identifier for the transaction to be cancelled (uint64).
   *
   * ### Response Fields:
   *
   * - **is_success**: A boolean indicating whether the cancellation was successful (bool).
   *   - `true` if the cancellation was successful, `false` if not.
   * - **failure_message**: A string that provides the reason for the failure, if applicable (string).
   *   - This field will be empty if the cancellation was successful.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = { tx_id: 12345 };
   * client.cancelTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "is_success": true,
   *   "failure_message": ""
   * }
   * ```
   */
  cancelTransaction: handleUnaryCall<CancelTransactionRequest, CancelTransactionResponse>;
  /** Will trigger a complete revalidation of all wallet outputs. */
  revalidateAllTransactions: handleUnaryCall<RevalidateRequest, RevalidateResponse>;
  /** Will trigger a validation of all wallet outputs. */
  validateAllTransactions: handleUnaryCall<ValidateRequest, ValidateResponse>;
  /**
   * Sends a XTR SHA Atomic Swap transaction.
   *
   * The `SendShaAtomicSwapTransaction` call is used to initiate an Atomic Swap
   * transaction using SHA. It allows the sender to send a payment to the recipient
   * in exchange for an atomic swap, with SHA used as the secret for the swap.
   * The method accepts the recipient's information and initiates the transaction.
   *
   * ### Request Parameters:
   * - **recipient** (required): A PaymentRecipient object containing the recipient's address,
   *   the amount to be swapped, the fee per gram, and the payment ID to identify the transaction.
   *
   * ### Response Fields:
   * - **transaction_id**: The ID of the transaction.
   * - **pre_image**: The SHA pre-image of the atomic swap.
   * - **output_hash**: The hash of the output associated with the transaction.
   * - **is_success**: Indicates whether the transaction was successful (true) or failed (false).
   * - **failure_message**: Provides an error message if the transaction failed.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   recipient: {
   *     address: "t1abc12345",
   *     amount: 1000000,
   *     fee_per_gram: 10,
   *     payment_id: "0xdeadbeef"
   *   }
   * };
   * client.sendShaAtomicSwapTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "transaction_id": 123456789,
   *   "pre_image": "0xabcdef1234567890",
   *   "output_hash": "0x123456abcdef7890",
   *   "is_success": true,
   *   "failure_message": ""
   * }
   */
  sendShaAtomicSwapTransaction: handleUnaryCall<SendShaAtomicSwapRequest, SendShaAtomicSwapResponse>;
  /**
   * Creates a burn transaction for burning a specified amount of Tari currency.
   *
   * The `CreateBurnTransaction` call facilitates burning a certain amount of Tari
   * by initiating a burn transaction. It allows the user to specify the amount to burn,
   * along with a fee per gram and optionally a payment ID and claim public key.
   *
   * ### Request Parameters:
   * - **amount** (required): The amount of Tari to be burned.
   * - **fee_per_gram** (required): The fee per gram for the transaction.
   * - **claim_public_key** (optional): The public key to claim ownership of the burned coins.
   * - **payment_id** (optional): A unique identifier for the payment associated with the burn transaction.
   *
   * ### Response Fields:
   * - **transaction_id**: The ID of the burn transaction.
   * - **is_success**: Indicates whether the burn transaction was successfully created.
   * - **failure_message**: Provides an error message if the transaction creation failed.
   * - **commitment**: The commitment associated with the burn transaction.
   * - **ownership_proof**: A proof of ownership for the burned coins.
   * - **range_proof**: The range proof associated with the burned coins.
   * - **reciprocal_claim_public_key**: The public key of the reciprocal claim for the burn.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   amount: 1000000,
   *   fee_per_gram: 10,
   *   claim_public_key: "0xabcdef1234567890",
   *   payment_id: "0xdeadbeef"
   * };
   * client.createBurnTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "transaction_id": 123456789,
   *   "is_success": true,
   *   "failure_message": "",
   *   "commitment": "0xcommitmenthash",
   *   "ownership_proof": "0xownershipproof",
   *   "range_proof": "0xrangeproof",
   *   "reciprocal_claim_public_key": "0xreciprocalpublickey"
   * }
   */
  createBurnTransaction: handleUnaryCall<CreateBurnTransactionRequest, CreateBurnTransactionResponse>;
  /**
   * Claims a SHA Atomic Swap transaction using a pre-image and output hash.
   *
   * The `ClaimShaAtomicSwapTransaction` call allows the user to unlock and claim funds from
   * a hash-time-locked contract (HTLC) by supplying the correct pre-image that matches a
   * previously committed SHA-256 hash. This pre-image proves the user's knowledge of the
   * secret required to spend the output.
   *
   * ### Request Parameters:
   * - **output** (required): The hex-encoded output hash (SHA-256 digest) that was locked in the atomic swap.
   * - **pre_image** (required): The hex-encoded original pre-image (raw bytes, *not* hashed) which, when hashed with SHA-256, must match the `output` hash.
   * - **fee_per_gram** (required): The transaction fee per gram, specified as an unsigned integer.
   *
   * ### Input Validation:
   * - `output` must be a valid hex-encoded SHA-256 hash (64 hex characters).
   * - `pre_image` must be a valid hex string representing the original secret (any byte length, commonly 32 bytes).
   * - `fee_per_gram` must be a non-zero `uint64`; a fee of `0` may be rejected or deprioritized by the network.
   *
   * ### Response Fields:
   * - **results**: A `TransferResult` object containing transaction ID, success status, and an error message if applicable.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   output: "3e1f89af...e923", // SHA-256 hash of the expected pre-image
   *   pre_image: "6a1b2c...eaf1", // raw pre-image (not hashed)
   *   fee_per_gram: 10
   * };
   * client.claimShaAtomicSwapTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response.results);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "results": {
   *     "address": "",
   *     "transaction_id": 789654,
   *     "is_success": true,
   *     "failure_message": ""
   *   }
   * }
   */
  claimShaAtomicSwapTransaction: handleUnaryCall<ClaimShaAtomicSwapRequest, ClaimShaAtomicSwapResponse>;
  /**
   * Claims an HTLC refund transaction after the timelock period has passed.
   *
   * The `ClaimHtlcRefundTransaction` call enables the original sender of a Hash Time-Locked Contract (HTLC)
   * to reclaim the locked funds if the recipient has not claimed them in time using the correct pre-image.
   * This is possible only after the output's timelock has expired.
   *
   * ### Request Parameters:
   * - **output_hash** (required): Hex-encoded SHA-256 hash of the HTLC output being refunded.
   * - **fee_per_gram** (required): Transaction fee per gram, specified as a `uint64`.
   *
   * ### Input Validation:
   * - `output_hash` must be a valid 64-character hex string representing the hash of the HTLC output.
   * - `fee_per_gram` must be a non-zero `uint64` value.
   *
   * ### Response Fields:
   * - **results**: A `TransferResult` object including transaction ID, success status, and failure reason if any.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   output_hash: "aabbccddeeff0011...99",
   *   fee_per_gram: 20
   * };
   * client.claimHtlcRefundTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response.results);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "results": {
   *     "address": "",
   *     "transaction_id": 889977,
   *     "is_success": true,
   *     "failure_message": ""
   *   }
   * }
   */
  claimHtlcRefundTransaction: handleUnaryCall<ClaimHtlcRefundRequest, ClaimHtlcRefundResponse>;
  /** Creates a transaction with a template registration output */
  createTemplateRegistration: handleUnaryCall<CreateTemplateRegistrationRequest, CreateTemplateRegistrationResponse>;
  /**
   * Signs a message using the wallet's node identity private key.
   *
   * The `SignMessage` call creates a Schnorr signature over a message using the wallet's node identity private key.
   * This signature can be used to prove ownership of the wallet or authenticate messages.
   * The signature is returned as separate components (signature and public nonce) for verification.
   *
   * ### Request Parameters:
   *
   * - `message` (required):
   *   - **Type**: `bytes`
   *   - **Description**: The message to be signed (arbitrary bytes).
   *   - **Restrictions**: Can be any byte sequence.
   *
   * ### Response Fields:
   *
   * - **signature**: The Schnorr signature as hex-encoded bytes.
   * - **public_nonce**: The public nonce component of the signature as hex-encoded bytes.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   message: Buffer.from("Hello Tari!", "utf-8")
   * };
   * client.signMessage(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Signature:", response.signature, "Nonce:", response.public_nonce);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "signature": "a1b2c3d4e5f6...",
   *   "public_nonce": "f6e5d4c3b2a1..."
   * }
   * ```
   *
   * ### Security Notes:
   *
   * - This signs with the wallet's node identity private key.
   * - The signature can be verified using the wallet's public key.
   * - Use this for authentication and ownership proofs only.
   */
  signMessage: handleUnaryCall<SignMessageRequest, SignMessageResponse>;
  /**
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const call = client.streamTransactionEvents({});
   *
   * call.on("data", (response) => {
   *   console.log("Transaction Event:", response.transaction);
   * });
   *
   * call.on("end", () => {
   *   console.log("Stream ended.");
   * });
   *
   * call.on("error", (err) => {
   *   console.error("Stream error:", err);
   * });
   * ```
   *
   * ### Sample JSON Streamed Response:
   * ```json
   * {
   *   "transaction": {
   *     "event": "Mined",
   *     "tx_id": "103248",
   *     "source_address": "0xabc123...",
   *     "dest_address": "0xdef456...",
   *     "status": "Completed",
   *     "direction": "Outbound",
   *     "amount": 100000000,
   *     "payment_id": "0xdeadbeef..."
   *   }
   * }
   * ```
   */
  streamTransactionEvents: handleServerStreamingCall<TransactionEventRequest, TransactionEventResponse>;
  importTransactions: handleUnaryCall<ImportTransactionsRequest, ImportTransactionsResponse>;
  /**
   * Get all completed transactions including cancelled ones, sorted by timestamp and paginated
   * DEPRECATED: Use GetAllCompletedTransactionsStream for better performance and memory efficiency
   *
   * @deprecated
   */
  getAllCompletedTransactions: handleUnaryCall<GetAllCompletedTransactionsRequest, GetAllCompletedTransactionsResponse>;
  /**
   * Get all completed transactions including cancelled ones, sorted by timestamp and paginated (streaming version)
   * Recommended: Use this streaming version for better performance and progressive loading
   */
  getAllCompletedTransactionsStream: handleServerStreamingCall<
    GetAllCompletedTransactionsRequest,
    GetCompletedTransactionsResponse
  >;
  /**
   * Gets transaction information by payment reference (PayRef)
   *
   * The `GetPaymentByReference` call retrieves transaction information using a 32-byte payment reference hash.
   * PayRefs are generated as Blake2b_256(block_hash || output_hash) and provide a stable way to look up
   * transactions even after outputs are spent.
   *
   * ### Request Parameters:
   *
   * - `payment_reference` (required):
   *   - **Type**: `bytes` (32 bytes)
   *   - **Description**: The payment reference hash to look up
   *   - **Restrictions**: Must be exactly 32 bytes representing a valid PayRef
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const payref = Buffer.from('a1b2c3d4e5f6789012345678901234567890123456789012345678901234567890', 'hex');
   * const request = { payment_reference: payref };
   * client.getPaymentByReference(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log('Transaction found:', response.transaction);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "transaction": {
   *     "tx_id": 12345,
   *     "source_address": "0x1234abcd...",
   *     "dest_address": "0x5678efgh...",
   *     "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
   *     "direction": "TRANSACTION_DIRECTION_INBOUND",
   *     "amount": 1000000,
   *     "fee": 20,
   *     "is_cancelled": false,
   *     "excess_sig": "0xabcdef...",
   *     "timestamp": 1681234567,
   *     "payment_id": "0xdeadbeef...",
   *     "mined_in_block_height": 150000
   *   }
   * }
   * ```
   */
  getPaymentByReference: handleUnaryCall<GetPaymentByReferenceRequest, GetPaymentByReferenceResponse>;
  /**
   * Estimates the transaction fee based on amount, fee rate, and number of outputs.
   *
   * The `GetFeeEstimate` call allows clients to calculate the expected transaction fee before sending funds.
   * This is useful for presenting fee information to the user or for ensuring sufficient funds are available.
   *
   * ### Request Parameters:
   * - **amount** (required): The amount to send, in microTari. (1 Tari = 1,000,000 µT).
   * - **fee_per_gram** (required): The fee per gram (weight unit) to use for the estimate. Higher values may improve priority.
   * - **output_count** (required): The number of outputs to create in the transaction (e.g., 2 = recipient + change).
   *
   * ### Input Validation:
   * - `amount` must be a non-zero `uint64` representing the amount to transfer.
   * - `fee_per_gram` must be a non-zero `uint64`; zero or low fees may result in delayed confirmation or failure.
   * - `output_count` must be convertible to a valid `usize`; large values may increase the fee significantly.
   *
   * ### Response Fields:
   * - **estimated_fee**: A `uint64` value representing the estimated total transaction fee in microTari.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   amount: 1000000,         // Sending 1 Tari
   *   fee_per_gram: 5,         // Fee rate of 5 µT/g
   *   output_count: 2          // One recipient + one change output
   * };
   * client.getFeeEstimate(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Estimated fee:", response.estimated_fee);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "estimated_fee": 12345
   * }
   * ```
   */
  getFeeEstimate: handleUnaryCall<GetFeeEstimateRequest, GetFeeEstimateResponse>;
  /**
   * Retrieves fee-per-gram statistics over recent blocks.
   *
   * The `GetFeePerGramStats` call returns aggregated fee rate information to help clients
   * understand recent network fee trends. This can be used for setting appropriate fees
   * when constructing transactions.
   *
   * ### Request Parameters:
   * - **block_count** (optional): The number of recent blocks to include in the statistics.
   *   If not specified or zero, a default number of blocks will be used.
   *
   * ### Input Validation:
   * - `block_count` must be a non-negative `uint64`. Large values may increase query time.
   *
   * ### Response Fields:
   * - **fee_per_gram_stats**: A list of `FeePerGramStat` objects summarizing fee data over the specified blocks.
   *
   * Each `FeePerGramStat` contains:
   * - **average_fee_per_gram**: Average fee per gram observed over the blocks.
   * - **min_fee_per_gram**: Minimum fee per gram observed.
   * - **max_fee_per_gram**: Maximum fee per gram observed.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   block_count: 10 // Consider fees over the last 10 blocks
   * };
   * client.getFeePerGramStats(request, (err, response) => {
   *   if (err) console.error(err);
   *   else response.fee_per_gram_stats.forEach(stat => {
   *     console.log(`Avg: ${stat.average_fee_per_gram}, Min: ${stat.min_fee_per_gram}, Max: ${stat.max_fee_per_gram}`);
   *   });
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "fee_per_gram_stats": [
   *     {
   *       "average_fee_per_gram": 5,
   *       "min_fee_per_gram": 3,
   *       "max_fee_per_gram": 10
   *     }
   *   ]
   * }
   * ```
   */
  getFeePerGramStats: handleUnaryCall<GetFeePerGramStatsRequest, GetFeePerGramStatsResponse>;
  /**
   * Attempts to replace an existing transaction with a new one that has a higher fee.
   *
   * The `ReplaceByFee` call enables clients to increase the fee of a pending transaction,
   * potentially speeding up its confirmation by incentivizing miners to prioritize it.
   *
   * ### Request Parameters:
   * - **transaction_id** (required): The ID of the original transaction to replace.
   * - **fee_increase** (required): The additional fee amount to add, specified in microTari.
   *   Must be greater than zero.
   *
   * ### Input Validation:
   * - `transaction_id` must correspond to a currently unconfirmed transaction.
   * - `fee_increase` must be a non-zero `uint64`. Zero or negative values are invalid.
   *
   * ### Response Fields:
   * - **transaction_id**: The transaction ID of the new replacement transaction.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   transaction_id: 123456,
   *   fee_increase: 5000  // Increase fee by 5,000 microTari
   * };
   * client.replaceByFee(request, (err, response) => {
   *   if (err) console.error("Failed to replace by fee:", err);
   *   else console.log("Replacement transaction ID:", response.transaction_id);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "transaction_id": 7891011
   * }
   * ```
   */
  replaceByFee: handleUnaryCall<ReplaceByFeeRequest, ReplaceByFeeResponse>;
  /**
   * Allows users to pay a specified fee for spending transaction outputs to given recipients.
   *
   * The `UserPayForFee` call enables clients to request that the wallet pays the fee
   * for one or more transactions identified by their IDs, sending funds to the specified recipients.
   * This is useful for fee bumping or covering transaction fees on behalf of recipients.
   *
   * ### Request Parameters:
   * - **recipients** (required): A list of transfers, each specifying:
   *    - `tx_id`: The transaction ID whose outputs will be spent.
   *    - `fee`: The fee amount in microTari to pay for this transfer.
   *    - `destination`: The Base58-encoded Tari address of the recipient.
   *
   * ### Input Validation:
   * - Each `tx_id` must correspond to a valid transaction whose outputs can be spent.
   * - Each `fee` must be a non-negative uint64 specifying the fee to pay.
   * - Each `destination` must be a valid Base58 Tari address.
   *
   * ### Response Fields:
   * - **results**: A list of `TransferResult` objects, one per requested recipient, each containing:
   *    - `address`: The recipient address as a string.
   *    - `transaction_id`: The ID of the newly created transaction (or zero if failed).
   *    - `is_success`: Boolean indicating if the fee payment transaction succeeded.
   *    - `failure_message`: A string describing the error if the transaction failed.
   *    - `transaction_info`: Detailed transaction metadata if available.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   recipients: [
   *     {
   *       tx_id: 123,
   *       fee: 1000,
   *       destination: "tari1qxyz..."
   *     },
   *     {
   *       tx_id: 456,
   *       fee: 2000,
   *       destination: "tari1qabcd..."
   *     }
   *   ]
   * };
   * client.userPayForFee(request, (err, response) => {
   *   if (err) console.error("Fee payment failed:", err);
   *   else {
   *     response.results.forEach(result => {
   *       if (result.is_success) {
   *         console.log(`Fee paid successfully to ${result.address} in tx ${result.transaction_id}`);
   *       } else {
   *         console.error(`Failed to pay fee for ${result.address}: ${result.failure_message}`);
   *       }
   *     });
   *   }
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "results": [
   *     {
   *       "address": "tari1qxyz...",
   *       "transaction_id": 789,
   *       "is_success": true,
   *       "failure_message": "",
   *       "transaction_info": {
   *         "tx_id": 789,
   *         "source_address": "...",
   *         "dest_address": "...",
   *         "status": "Completed",
   *         "direction": "Outbound",
   *         "amount": 50000,
   *         "fee": 1000,
   *         "is_cancelled": false,
   *         "timestamp": 1620000000
   *       }
   *     },
   *     {
   *       "address": "tari1qabcd...",
   *       "transaction_id": 0,
   *       "is_success": false,
   *       "failure_message": "Invalid destination address",
   *       "transaction_info": null
   *     }
   *   ]
   * }
   * ```
   */
  userPayForFee: handleUnaryCall<UserPayForFeeRequest, UserPayForFeeResponse>;
  registerValidatorNode: handleUnaryCall<RegisterValidatorNodeRequest, RegisterValidatorNodeResponse>;
  submitValidatorEvictionProof: handleUnaryCall<
    SubmitValidatorEvictionProofRequest,
    SubmitValidatorEvictionProofResponse
  >;
  submitValidatorNodeExit: handleUnaryCall<SubmitValidatorNodeExitRequest, SubmitValidatorNodeExitResponse>;
}

export interface WalletClient extends Client {
  getVersion(
    request: GetVersionRequest,
    callback: (error: ServiceError | null, response: GetVersionResponse) => void,
  ): ClientUnaryCall;
  getVersion(
    request: GetVersionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetVersionResponse) => void,
  ): ClientUnaryCall;
  getVersion(
    request: GetVersionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetVersionResponse) => void,
  ): ClientUnaryCall;
  /**
   * Returns the current operational state of the wallet.
   *
   * This RPC provides an overview of the wallet's internal status, including:
   * - The latest blockchain height scanned by the wallet
   * - The current balance (available, pending incoming/outgoing)
   * - Network connectivity status with the base node
   *
   * This is commonly used by UI clients or backend systems to confirm the wallet is healthy,
   * synchronized, and connected to the Tari network.
   *
   * Example usage (JavaScript):
   * ```javascript
   * const response = await client.getState({});
   * console.log(response.scanned_height); // e.g., 1523493
   * console.log(response.balance.available_balance); // e.g., 1234567890
   * console.log(response.network.status); // e.g., "Online"
   * ```
   *
   * Example response:
   * ```json
   * {
   *   "scanned_height": 1523493,
   *   "balance": {
   *     "available_balance": 1234567890,
   *     "pending_incoming_balance": 100000000,
   *     "pending_outgoing_balance": 0
   *   },
   *   "network": {
   *     "status": "Online",
   *     "avg_latency_ms": 28,
   *     "num_node_connections": 8
   *   }
   * }
   * ```
   */
  getState(
    request: GetStateRequest,
    callback: (error: ServiceError | null, response: GetStateResponse) => void,
  ): ClientUnaryCall;
  getState(
    request: GetStateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetStateResponse) => void,
  ): ClientUnaryCall;
  getState(
    request: GetStateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetStateResponse) => void,
  ): ClientUnaryCall;
  /**
   * This RPC returns a lightweight response indicating whether the wallet is connected to the network, attempting to connect, or currently offline. This is useful for UIs or clients to determine if network interactions like transactions or syncs are possible.
   *
   * Example usage (JavaScript):
   * ```javascript
   * const response = await client.checkConnectivity({});
   * console.log(response.status); // e.g., 1 (Online)
   * ```
   *
   * Example response:
   * ```json
   * {
   *   "status": "Online"
   * }
   * ```
   */
  checkConnectivity(
    request: GetConnectivityRequest,
    callback: (error: ServiceError | null, response: CheckConnectivityResponse) => void,
  ): ClientUnaryCall;
  checkConnectivity(
    request: GetConnectivityRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CheckConnectivityResponse) => void,
  ): ClientUnaryCall;
  checkConnectivity(
    request: GetConnectivityRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CheckConnectivityResponse) => void,
  ): ClientUnaryCall;
  /** Check for new updates */
  checkForUpdates(
    request: Empty,
    callback: (error: ServiceError | null, response: SoftwareUpdate) => void,
  ): ClientUnaryCall;
  checkForUpdates(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SoftwareUpdate) => void,
  ): ClientUnaryCall;
  checkForUpdates(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SoftwareUpdate) => void,
  ): ClientUnaryCall;
  /**
   * The `Identify` RPC call returns the identity information of the wallet node.
   * This includes:
   * - **Public Key**: The wallet's cryptographic public key.
   * - **Public Address**: The wallet's public address used to receive funds.
   * - **Node ID**: The unique identifier of the wallet node in the network.
   *
   * Example usage (JavaScript):
   * ```javascript
   * // Call the Identify RPC method
   * client.Identify({}, (error, response) => {
   *   if (error) {
   *     console.error('Error:', error);
   *   } else {
   *     console.log('Identity Response:', response);
   *   }
   * });
   * ```
   *
   * **Sample JSON Response:**
   *
   * ```json
   * {
   *   "public_key": "0x04b2c5f3fe65bb1c3cde019e34f3eab1234598c820dca43bbf4d5686a980ddc69e0d4b180d85990d0a5e4aee46e0a6ad9283f0a41783992a70c548e53e47321fa",
   *   "public_address": "14HVCEeZC2RGE4SDn3yGwqzXepJ2LDqXva7kb4fherYMQR9dF7341T3TjMZobB1a6xouGvS5SXwEvXKwK3zLz2rgReh",
   *   "node_id": "0x1234abcd5678efgh9012ijkl3456mnop"
   * }
   * ```
   */
  identify(
    request: GetIdentityRequest,
    callback: (error: ServiceError | null, response: GetIdentityResponse) => void,
  ): ClientUnaryCall;
  identify(
    request: GetIdentityRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetIdentityResponse) => void,
  ): ClientUnaryCall;
  identify(
    request: GetIdentityRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetIdentityResponse) => void,
  ): ClientUnaryCall;
  /**
   * This RPC returns two types of wallet addresses: interactive and one-sided addresses.
   * It provides these addresses in byte format as part of the response.
   * - **Interactive Address**: This is a type of address used for interaction and communication with the wallet.
   * - **One-Sided Address**: This is another address type, typically used in scenarios where a one-way interaction or transaction is needed.
   *
   * Example usage (JavaScript):
   * // Call the GetAddress RPC method
   * client.GetAddress({}, (error, response) => {
   *   if (error) {
   *     console.error('Error:', error);
   *   } else {
   *     console.log('Address Response:', response);
   *   }
   * });
   * ```
   *
   * **Sample JSON Response:**
   *  // ```json
   * {
   *   "interactive_address": "0x14b27bde3f7d9c9d7455f16b056a3c439c663af93356f56e16d2b2c79e6995c44c9c6c7c",
   *   "one_sided_address": "0x12b35ddcb2270a72d7b327abc7cd4f607a492c6e13e72e65c34742069e48bd3bc462df63"
   * }
   * ```
   */
  getAddress(
    request: Empty,
    callback: (error: ServiceError | null, response: GetAddressResponse) => void,
  ): ClientUnaryCall;
  getAddress(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAddressResponse) => void,
  ): ClientUnaryCall;
  getAddress(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAddressResponse) => void,
  ): ClientUnaryCall;
  /**
   * This RPC returns addresses generated for a specific payment ID. It provides both the interactive
   * and one-sided addresses for the given payment ID, along with their respective representations in
   * base58 and emoji formats.
   *
   * Example usage (JavaScript):
   *
   * ```javascript
   * // Prepare the payment ID for the request
   * const paymentId = Buffer.from('your_payment_id_here', 'hex');
   * const request = { payment_id: paymentId };
   *
   * // Call the GetPaymentIdAddress RPC method
   * client.GetPaymentIdAddress(request, (error, response) => {
   *   if (error) {
   *     console.error('Error:', error);
   *   } else {
   *     console.log('Payment ID Address Response:', response);
   *   }
   * });
   * ```
   *
   * **Sample JSON Response:**
   *
   * ```json
   * {
   *  "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
   *  "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
   *  "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
   *  "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
   *  "interactive_address_emoji": "🐢🌊💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭",
   *  "one_sided_address_emoji": "🐢📟💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞📜.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭"
   * }
   * ```
   */
  getPaymentIdAddress(
    request: GetPaymentIdAddressRequest,
    callback: (error: ServiceError | null, response: GetCompleteAddressResponse) => void,
  ): ClientUnaryCall;
  getPaymentIdAddress(
    request: GetPaymentIdAddressRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetCompleteAddressResponse) => void,
  ): ClientUnaryCall;
  getPaymentIdAddress(
    request: GetPaymentIdAddressRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetCompleteAddressResponse) => void,
  ): ClientUnaryCall;
  /**
   * This RPC call that retrieves the current wallet's interactive and one-sided addresses in multiple formats and returns them in a structured response.
   * The response includes:
   * - Raw binary
   * - Base58-encoded (human-readable)
   * - Emoji-encoded (for fun and friendliness)
   *
   * Example usage (JavaScript with gRPC):
   *
   * ```js
   * const client = new WalletClient('localhost:50051', grpc.credentials.createInsecure());
   * client.getCompleteAddress({}, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response);
   * });
   * ```
   *
   * Sample response:
   * ```json
   * {
   *  "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
   *  "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
   *  "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
   *  "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
   *  "interactive_address_emoji": "🐢🌊💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭",
   *  "one_sided_address_emoji": "🐢📟💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞📜.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭"
   * }
   * ```
   */
  getCompleteAddress(
    request: Empty,
    callback: (error: ServiceError | null, response: GetCompleteAddressResponse) => void,
  ): ClientUnaryCall;
  getCompleteAddress(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetCompleteAddressResponse) => void,
  ): ClientUnaryCall;
  getCompleteAddress(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetCompleteAddressResponse) => void,
  ): ClientUnaryCall;
  prepareOneSidedTransactionForSigning(
    request: PrepareOneSidedTransactionForSigningRequest,
    callback: (error: ServiceError | null, response: PrepareOneSidedTransactionForSigningResponse) => void,
  ): ClientUnaryCall;
  prepareOneSidedTransactionForSigning(
    request: PrepareOneSidedTransactionForSigningRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PrepareOneSidedTransactionForSigningResponse) => void,
  ): ClientUnaryCall;
  prepareOneSidedTransactionForSigning(
    request: PrepareOneSidedTransactionForSigningRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PrepareOneSidedTransactionForSigningResponse) => void,
  ): ClientUnaryCall;
  broadcastSignedOneSidedTransaction(
    request: BroadcastSignedOneSidedTransactionRequest,
    callback: (error: ServiceError | null, response: BroadcastSignedOneSidedTransactionResponse) => void,
  ): ClientUnaryCall;
  broadcastSignedOneSidedTransaction(
    request: BroadcastSignedOneSidedTransactionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BroadcastSignedOneSidedTransactionResponse) => void,
  ): ClientUnaryCall;
  broadcastSignedOneSidedTransaction(
    request: BroadcastSignedOneSidedTransactionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BroadcastSignedOneSidedTransactionResponse) => void,
  ): ClientUnaryCall;
  /**
   * This call supports standard interactive transactions (Mimblewimble),
   * one-sided transactions, and one-sided-to-stealth-address transactions.
   * Each recipient must include a valid Tari address, amount, fee, and payment type.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const recipient = new PaymentRecipient();
   * recipient.setAddress("14HVCEeZ...");
   * recipient.setAmount(1000000); // 1 T
   * recipient.setFeePerGram(25);
   * recipient.setPaymentType(PaymentType.ONE_SIDED);
   * recipient.setPaymentId(Buffer.from("abc123", "utf-8"));
   *
   * const request = new TransferRequest();
   * request.setRecipientsList([recipient]);
   *
   * client.transfer(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response.toObject());
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "results": [
   *     {
   *       "address": "14HVCEeZ...",
   *       "transaction_id": 12345,
   *       "is_success": true,
   *       "failure_message": ""
   *     }
   *   ]
   * }
   */
  transfer(
    request: TransferRequest,
    callback: (error: ServiceError | null, response: TransferResponse) => void,
  ): ClientUnaryCall;
  transfer(
    request: TransferRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransferResponse) => void,
  ): ClientUnaryCall;
  transfer(
    request: TransferRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransferResponse) => void,
  ): ClientUnaryCall;
  /**
   * Returns the transaction details for the given transaction IDs.
   *
   * The GetTransactionInfo RPC retrieves detailed information about specific transactions based on their IDs.
   * The response includes details such as transaction status, direction, amount, fee, and more.
   *
   * ### Request Parameters:
   *
   * - `transaction_ids` (required):
   *   - **Type**: `repeated uint64`
   *   - **Description**: A list of transaction IDs to query.
   *   - **Restrictions**:
   *     - Must contain at least one ID.
   *     - All IDs must be valid unsigned 64-bit integers.
   *     - Duplicates will be ignored; only the first occurrence is processed.
   *     - If a transaction ID is not found, it will be returned with a `status` of `NOT_FOUND`.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = { transaction_ids: [12345, 67890] };
   * client.getTransactionInfo(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response.transactions);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "transactions": [
   *     {
   *       "tx_id": 12345,
   *       "source_address": "0x1234abcd...",
   *       "dest_address": "0x5678efgh...",
   *       "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
   *       "direction": "TRANSACTION_DIRECTION_OUTBOUND",
   *       "amount": 1000000,
   *       "fee": 25,
   *       "is_cancelled": false,
   *       "excess_sig": "0xabcdef...",
   *       "timestamp": 1681234567,
   *       "payment_id": "0xdeadbeef...",
   *       "mined_in_block_height": 1523493
   *     }
   *   ]
   * }
   */
  getTransactionInfo(
    request: GetTransactionInfoRequest,
    callback: (error: ServiceError | null, response: GetTransactionInfoResponse) => void,
  ): ClientUnaryCall;
  getTransactionInfo(
    request: GetTransactionInfoRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTransactionInfoResponse) => void,
  ): ClientUnaryCall;
  getTransactionInfo(
    request: GetTransactionInfoRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTransactionInfoResponse) => void,
  ): ClientUnaryCall;
  /**
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   payment_id: {
   *     utf8_string: "invoice-001"
   *   }
   * };
   * const call = client.getCompletedTransactions(request);
   * call.on('data', (response) => {
   *   console.log(response.transaction);
   * });
   * call.on('error', console.error);
   * call.on('end', () => console.log("Stream ended"));
   * ```
   *
   * ### Sample Streamed JSON Response:
   *
   * ```json
   * {
   *   "transaction": {
   *     "tx_id": 12345,
   *     "source_address": "0x1234abcd...",
   *     "dest_address": "0x5678efgh...",
   *     "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
   *     "direction": "TRANSACTION_DIRECTION_INBOUND",
   *     "amount": 500000,
   *     "fee": 20,
   *     "is_cancelled": false,
   *     "excess_sig": "0xabcdef...",
   *     "timestamp": 1681234567,
   *     "payment_id": "0xdeadbeef...",
   *     "mined_in_block_height": 1523493
   *   }
   * }
   * ```
   */
  getCompletedTransactions(
    request: GetCompletedTransactionsRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetCompletedTransactionsResponse>;
  getCompletedTransactions(
    request: GetCompletedTransactionsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetCompletedTransactionsResponse>;
  /**
   * Returns all transactions that were mined at a specific block height.
   *
   * The `GetBlockHeightTransactions` call retrieves all wallet transactions that were mined
   * at the specified block height. The response includes all transactions in a single response,
   * with each transaction including details such as status, direction, amount,
   * fees, and associated metadata.
   *
   * ### Request Parameters:
   *
   * - `block_height` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The specific block height to fetch transactions for.
   *   - **Restrictions**:
   *     - Must be a valid block height (greater than 0).
   *     - If the block height is beyond the current chain height, no transactions will be returned.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   block_height: 1523493
   * };
   * const response = await client.getBlockHeightTransactions(request);
   * console.log(response.transactions);
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "transactions": [
   *     {
   *       "tx_id": 12345,
   *       "source_address": "0x1234abcd...",
   *       "dest_address": "0x5678efgh...",
   *       "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
   *       "direction": "TRANSACTION_DIRECTION_INBOUND",
   *       "amount": 500000,
   *       "fee": 20,
   *       "is_cancelled": false,
   *       "excess_sig": "0xabcdef...",
   *       "timestamp": 1681234567,
   *       "payment_id": "0xdeadbeef...",
   *       "mined_in_block_height": 1523493
   *     }
   *   ]
   * }
   * ```
   */
  getBlockHeightTransactions(
    request: GetBlockHeightTransactionsRequest,
    callback: (error: ServiceError | null, response: GetBlockHeightTransactionsResponse) => void,
  ): ClientUnaryCall;
  getBlockHeightTransactions(
    request: GetBlockHeightTransactionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBlockHeightTransactionsResponse) => void,
  ): ClientUnaryCall;
  getBlockHeightTransactions(
    request: GetBlockHeightTransactionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBlockHeightTransactionsResponse) => void,
  ): ClientUnaryCall;
  /**
   * Returns all PayRefs (payment references) for a specific transaction.
   *
   * The `GetTransactionPayRefs` call retrieves all PayRefs associated with the specified
   * transaction ID. PayRefs are cryptographic references generated from output hashes
   * that allow recipients to verify payments without revealing sensitive transaction details.
   *
   * ### Request Parameters:
   *
   * - `transaction_id` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The transaction ID to retrieve PayRefs for.
   *   - **Restrictions**:
   *     - Must be a valid transaction ID that exists in the wallet.
   *     - If the transaction ID is invalid or not found, an error will be returned.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   transaction_id: 12345
   * };
   * const response = await client.getTransactionPayRefs(request);
   * console.log("PayRefs:", response.payment_references.map(ref => Buffer.from(ref).toString('hex')));
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "payment_references": [
   *     "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
   *     "0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"
   *   ]
   * }
   * ```
   */
  getTransactionPayRefs(
    request: GetTransactionPayRefsRequest,
    callback: (error: ServiceError | null, response: GetTransactionPayRefsResponse) => void,
  ): ClientUnaryCall;
  getTransactionPayRefs(
    request: GetTransactionPayRefsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTransactionPayRefsResponse) => void,
  ): ClientUnaryCall;
  getTransactionPayRefs(
    request: GetTransactionPayRefsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTransactionPayRefsResponse) => void,
  ): ClientUnaryCall;
  /**
   * Returns the wallet balance details.
   *
   * The `GetBalance` call retrieves the current balance status of the wallet,
   * optionally filtered by a specific `payment_id`. The response includes detailed
   * breakdowns of available, pending incoming/outgoing, and timelocked balances.
   *
   * ### Request Parameters:
   *
   * - `payment_id` (optional):
   *   - **Type**: `UserPaymentId` (one of several formats).
   *   - **Description**: An optional filter to retrieve the balance associated with a specific payment ID.
   *   - **Accepted Formats** (must provide **only one**):
   *     - `u256`: a 32-byte hexadecimal identifier.
   *     - `utf8_string`: a human-readable string ID.
   *     - `user_bytes`: raw binary bytes.
   *   - **Restrictions**:
   *     - Only one format must be provided at a time.
   *     - If multiple or no formats are provided within `payment_id`, the request will return an error.
   *     - If `payment_id` is omitted, the total wallet balance is returned.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   payment_id: {
   *     utf8_string: "invoice-002"
   *   }
   * };
   * client.getBalance(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Balance:", response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "available_balance": 950000,
   *   "pending_incoming_balance": 200000,
   *   "pending_outgoing_balance": 50000,
   *   "timelocked_balance": 100000
   * }
   * ```
   */
  getBalance(
    request: GetBalanceRequest,
    callback: (error: ServiceError | null, response: GetBalanceResponse) => void,
  ): ClientUnaryCall;
  getBalance(
    request: GetBalanceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBalanceResponse) => void,
  ): ClientUnaryCall;
  getBalance(
    request: GetBalanceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBalanceResponse) => void,
  ): ClientUnaryCall;
  /**
   * Returns the total value of unspent outputs in the wallet.
   *
   * The `GetUnspentAmounts` call retrieves the sum of all unspent output amounts
   * currently held by the wallet. These are outputs that have not yet been spent or time-locked,
   * and are available for future transactions.
   *
   * ### Request Parameters:
   *
   * - *(none)*
   *   - This method uses an empty request body (`google.protobuf.Empty`).
   *   - No filters or arguments are required.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * client.getUnspentAmounts({}, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Total unspent amount:", response.amount);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "amount": 1250000
   * }
   * ```
   */
  getUnspentAmounts(
    request: Empty,
    callback: (error: ServiceError | null, response: GetUnspentAmountsResponse) => void,
  ): ClientUnaryCall;
  getUnspentAmounts(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetUnspentAmountsResponse) => void,
  ): ClientUnaryCall;
  getUnspentAmounts(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetUnspentAmountsResponse) => void,
  ): ClientUnaryCall;
  /**
   * Creates a transaction that splits funds into multiple smaller outputs.
   *
   * The `CoinSplit` call initiates a transaction that divides wallet funds into several equal-sized outputs.
   * This is useful for preparing a wallet for many small transactions (e.g., for micropayments or batching).
   * The resulting transaction is broadcast and can be tracked via its transaction ID.
   *
   * ### Request Parameters:
   *
   * - `amount_per_split` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The value of each individual output in the split.
   *   - **Restrictions**: Must be greater than zero.
   *
   * - `split_count` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The number of outputs to create.
   *   - **Restrictions**: Must be greater than zero and within practical system limits.
   *
   * - `fee_per_gram` (required):
   *   - **Type**: `uint64`
   *   - **Description**: The transaction fee rate (per gram of weight).
   *   - **Restrictions**: Should be set high enough to ensure confirmation.
   *
   * - `lock_height` (optional):
   *   - **Type**: `uint64`
   *   - **Description**: The earliest block height at which the transaction becomes valid.
   *   - **Restrictions**: Defaults to 0 if not specified.
   *
   * - `payment_id` (optional):
   *   - **Type**: `bytes`
   *   - **Description**: A user-defined identifier for tracking or referencing the transaction.
   *   - **Restrictions**: Optional; can be left empty.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   amount_per_split: 100000,
   *   split_count: 5,
   *   fee_per_gram: 25,
   *   lock_height: 0,
   *   payment_id: new Uint8Array([])
   * };
   * client.coinSplit(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Created CoinSplit Tx ID:", response.tx_id);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "tx_id": 987654321
   * }
   * ```
   */
  coinSplit(
    request: CoinSplitRequest,
    callback: (error: ServiceError | null, response: CoinSplitResponse) => void,
  ): ClientUnaryCall;
  coinSplit(
    request: CoinSplitRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CoinSplitResponse) => void,
  ): ClientUnaryCall;
  coinSplit(
    request: CoinSplitRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CoinSplitResponse) => void,
  ): ClientUnaryCall;
  /**
   * Imports UTXOs into the wallet as spendable outputs.
   *
   * The `ImportUtxos` call allows you to manually insert one or more previously received UTXOs
   * into the wallet, marking them as spendable without needing rewindable metadata.
   * Each UTXO is associated with a transaction ID in the response.
   *
   * ### Request Parameters:
   *
   * - `outputs` (required):
   *   - **Type**: `repeated UnblindedOutput`
   *   - **Description**: A list of unblinded outputs to import into the wallet.
   *   - **Restrictions**:
   *     - Each output must be valid and convertible to an internal UTXO format.
   *     - The list must contain at least one item.
   *
   * - `payment_id` (optional):
   *   - **Type**: `bytes`
   *   - **Description**: An optional user-defined identifier to associate with the imported outputs.
   *   - **Restrictions**:
   *     - Can be left empty if not needed.
   *     - Must be a valid byte string if provided.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   outputs: [/* array of unblinded outputs * /],
   *   payment_id: new Uint8Array([])
   * };
   * client.importUtxos(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Imported Tx IDs:", response.tx_ids);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "tx_ids": [101, 102, 103]
   * }
   * ```
   */
  importUtxos(
    request: ImportUtxosRequest,
    callback: (error: ServiceError | null, response: ImportUtxosResponse) => void,
  ): ClientUnaryCall;
  importUtxos(
    request: ImportUtxosRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ImportUtxosResponse) => void,
  ): ClientUnaryCall;
  importUtxos(
    request: ImportUtxosRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ImportUtxosResponse) => void,
  ): ClientUnaryCall;
  /**
   * Returns the wallet's current network connectivity status.
   *
   * The `GetNetworkStatus` call provides a snapshot of the wallet's connection to the Tari network,
   * including whether it is online, the number of active peer connections, and the average latency
   * to the configured base node.
   *
   * ### Request Parameters:
   *
   * - *(none)*
   *   - This method uses an empty request body (`google.protobuf.Empty`).
   *   - No filters or arguments are required.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * client.getNetworkStatus({}, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Network Status:", response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "status": "ONLINE",
   *   "avg_latency_ms": 142,
   *   "num_node_connections": 8
   * }
   * ```
   *
   * ### Status Field Values:
   *
   * The `status` field indicates the current network connectivity of the wallet. Possible values are:
   *
   * - `ONLINE`:
   *   - The wallet is fully connected to the network and functioning normally.
   *   - The node has enough active peer connections to operate efficiently.
   *
   * - `DEGRADED`:
   *   - The wallet is connected to some peers but not enough to maintain full functionality.
   *   - This could indicate issues with network connectivity, such as intermittent disconnections or insufficient peers, leading to reduced performance or reliability.
   *
   * - `OFFLINE`:
   *   - The wallet is not connected to any peers.
   *   - This status means the wallet is unable to communicate with the network and cannot perform any network-related operations.
   */
  getNetworkStatus(
    request: Empty,
    callback: (error: ServiceError | null, response: NetworkStatusResponse) => void,
  ): ClientUnaryCall;
  getNetworkStatus(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NetworkStatusResponse) => void,
  ): ClientUnaryCall;
  getNetworkStatus(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NetworkStatusResponse) => void,
  ): ClientUnaryCall;
  /**
   * Returns a list of peers currently connected to the wallet.
   *
   * The `ListConnectedPeers` call retrieves information about peers that the wallet is currently
   * connected to. This includes details such as peer addresses, connection status, supported protocols,
   * and other metadata relevant to the connection.
   *
   * ### Request Parameters:
   *
   * - *(none)*
   *   - This method uses an empty request body (`google.protobuf.Empty`).
   *   - No filters or arguments are required.
   *
   * ### Response Fields:
   *
   * - **connected_peers**: List of peers currently connected to the wallet.
   *   - **public_key**: The peer's public key (bytes).
   *   - **node_id**: The unique node ID of the peer (bytes).
   *   - **addresses**: List of the peer's addresses (repeated Address).
   *   - **last_connection**: The timestamp of the last connection attempt (uint64).
   *   - **flags**: Flags associated with the peer (uint32).
   *   - **banned_until**: The timestamp until which the peer is banned (uint64, 0 if not banned).
   *   - **banned_reason**: The reason for banning the peer (string, empty if not banned).
   *   - **offline_at**: The timestamp indicating when the peer went offline (uint64, 0 if online).
   *   - **features**: The features supported by the peer (uint32).
   *   - **supported_protocols**: List of supported protocols by the peer (repeated bytes).
   *   - **user_agent**: The user agent advertised by the peer (string).
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * client.listConnectedPeers({}, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Connected Peers:", response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "connected_peers": [
   *     {
   *       "public_key": "0x1234abcd...",
   *       "node_id": "0x5678efgh...",
   *       "addresses": [
   *         "127.0.0.1:18080",
   *         "192.168.1.2:18080"
   *       ],
   *       "last_connection": 1625493123,
   *       "flags": 1,
   *       "banned_until": 0,
   *       "banned_reason": "",
   *       "offline_at": 0,
   *       "features": 10,
   *       "supported_protocols": [
   *         "protocol_v1",
   *         "protocol_v2"
   *       ],
   *       "user_agent": "TariBaseNode/1.0.0"
   *     }
   *   ]
   * }
   * ```
   */
  listConnectedPeers(
    request: Empty,
    callback: (error: ServiceError | null, response: ListConnectedPeersResponse) => void,
  ): ClientUnaryCall;
  listConnectedPeers(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListConnectedPeersResponse) => void,
  ): ClientUnaryCall;
  listConnectedPeers(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListConnectedPeersResponse) => void,
  ): ClientUnaryCall;
  /**
   * Cancels a specific transaction by its ID.
   *
   * The `CancelTransaction` call allows a transaction to be cancelled by its unique transaction ID (TxId).
   * If the cancellation is successful, the response will indicate success. Otherwise, the response will
   * contain a failure message with the reason for the failure.
   *
   * ### Request Parameters:
   *
   * - **tx_id**: The unique identifier for the transaction to be cancelled (uint64).
   *
   * ### Response Fields:
   *
   * - **is_success**: A boolean indicating whether the cancellation was successful (bool).
   *   - `true` if the cancellation was successful, `false` if not.
   * - **failure_message**: A string that provides the reason for the failure, if applicable (string).
   *   - This field will be empty if the cancellation was successful.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = { tx_id: 12345 };
   * client.cancelTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "is_success": true,
   *   "failure_message": ""
   * }
   * ```
   */
  cancelTransaction(
    request: CancelTransactionRequest,
    callback: (error: ServiceError | null, response: CancelTransactionResponse) => void,
  ): ClientUnaryCall;
  cancelTransaction(
    request: CancelTransactionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CancelTransactionResponse) => void,
  ): ClientUnaryCall;
  cancelTransaction(
    request: CancelTransactionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CancelTransactionResponse) => void,
  ): ClientUnaryCall;
  /** Will trigger a complete revalidation of all wallet outputs. */
  revalidateAllTransactions(
    request: RevalidateRequest,
    callback: (error: ServiceError | null, response: RevalidateResponse) => void,
  ): ClientUnaryCall;
  revalidateAllTransactions(
    request: RevalidateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RevalidateResponse) => void,
  ): ClientUnaryCall;
  revalidateAllTransactions(
    request: RevalidateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RevalidateResponse) => void,
  ): ClientUnaryCall;
  /** Will trigger a validation of all wallet outputs. */
  validateAllTransactions(
    request: ValidateRequest,
    callback: (error: ServiceError | null, response: ValidateResponse) => void,
  ): ClientUnaryCall;
  validateAllTransactions(
    request: ValidateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ValidateResponse) => void,
  ): ClientUnaryCall;
  validateAllTransactions(
    request: ValidateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ValidateResponse) => void,
  ): ClientUnaryCall;
  /**
   * Sends a XTR SHA Atomic Swap transaction.
   *
   * The `SendShaAtomicSwapTransaction` call is used to initiate an Atomic Swap
   * transaction using SHA. It allows the sender to send a payment to the recipient
   * in exchange for an atomic swap, with SHA used as the secret for the swap.
   * The method accepts the recipient's information and initiates the transaction.
   *
   * ### Request Parameters:
   * - **recipient** (required): A PaymentRecipient object containing the recipient's address,
   *   the amount to be swapped, the fee per gram, and the payment ID to identify the transaction.
   *
   * ### Response Fields:
   * - **transaction_id**: The ID of the transaction.
   * - **pre_image**: The SHA pre-image of the atomic swap.
   * - **output_hash**: The hash of the output associated with the transaction.
   * - **is_success**: Indicates whether the transaction was successful (true) or failed (false).
   * - **failure_message**: Provides an error message if the transaction failed.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   recipient: {
   *     address: "t1abc12345",
   *     amount: 1000000,
   *     fee_per_gram: 10,
   *     payment_id: "0xdeadbeef"
   *   }
   * };
   * client.sendShaAtomicSwapTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "transaction_id": 123456789,
   *   "pre_image": "0xabcdef1234567890",
   *   "output_hash": "0x123456abcdef7890",
   *   "is_success": true,
   *   "failure_message": ""
   * }
   */
  sendShaAtomicSwapTransaction(
    request: SendShaAtomicSwapRequest,
    callback: (error: ServiceError | null, response: SendShaAtomicSwapResponse) => void,
  ): ClientUnaryCall;
  sendShaAtomicSwapTransaction(
    request: SendShaAtomicSwapRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SendShaAtomicSwapResponse) => void,
  ): ClientUnaryCall;
  sendShaAtomicSwapTransaction(
    request: SendShaAtomicSwapRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SendShaAtomicSwapResponse) => void,
  ): ClientUnaryCall;
  /**
   * Creates a burn transaction for burning a specified amount of Tari currency.
   *
   * The `CreateBurnTransaction` call facilitates burning a certain amount of Tari
   * by initiating a burn transaction. It allows the user to specify the amount to burn,
   * along with a fee per gram and optionally a payment ID and claim public key.
   *
   * ### Request Parameters:
   * - **amount** (required): The amount of Tari to be burned.
   * - **fee_per_gram** (required): The fee per gram for the transaction.
   * - **claim_public_key** (optional): The public key to claim ownership of the burned coins.
   * - **payment_id** (optional): A unique identifier for the payment associated with the burn transaction.
   *
   * ### Response Fields:
   * - **transaction_id**: The ID of the burn transaction.
   * - **is_success**: Indicates whether the burn transaction was successfully created.
   * - **failure_message**: Provides an error message if the transaction creation failed.
   * - **commitment**: The commitment associated with the burn transaction.
   * - **ownership_proof**: A proof of ownership for the burned coins.
   * - **range_proof**: The range proof associated with the burned coins.
   * - **reciprocal_claim_public_key**: The public key of the reciprocal claim for the burn.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   amount: 1000000,
   *   fee_per_gram: 10,
   *   claim_public_key: "0xabcdef1234567890",
   *   payment_id: "0xdeadbeef"
   * };
   * client.createBurnTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "transaction_id": 123456789,
   *   "is_success": true,
   *   "failure_message": "",
   *   "commitment": "0xcommitmenthash",
   *   "ownership_proof": "0xownershipproof",
   *   "range_proof": "0xrangeproof",
   *   "reciprocal_claim_public_key": "0xreciprocalpublickey"
   * }
   */
  createBurnTransaction(
    request: CreateBurnTransactionRequest,
    callback: (error: ServiceError | null, response: CreateBurnTransactionResponse) => void,
  ): ClientUnaryCall;
  createBurnTransaction(
    request: CreateBurnTransactionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateBurnTransactionResponse) => void,
  ): ClientUnaryCall;
  createBurnTransaction(
    request: CreateBurnTransactionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateBurnTransactionResponse) => void,
  ): ClientUnaryCall;
  /**
   * Claims a SHA Atomic Swap transaction using a pre-image and output hash.
   *
   * The `ClaimShaAtomicSwapTransaction` call allows the user to unlock and claim funds from
   * a hash-time-locked contract (HTLC) by supplying the correct pre-image that matches a
   * previously committed SHA-256 hash. This pre-image proves the user's knowledge of the
   * secret required to spend the output.
   *
   * ### Request Parameters:
   * - **output** (required): The hex-encoded output hash (SHA-256 digest) that was locked in the atomic swap.
   * - **pre_image** (required): The hex-encoded original pre-image (raw bytes, *not* hashed) which, when hashed with SHA-256, must match the `output` hash.
   * - **fee_per_gram** (required): The transaction fee per gram, specified as an unsigned integer.
   *
   * ### Input Validation:
   * - `output` must be a valid hex-encoded SHA-256 hash (64 hex characters).
   * - `pre_image` must be a valid hex string representing the original secret (any byte length, commonly 32 bytes).
   * - `fee_per_gram` must be a non-zero `uint64`; a fee of `0` may be rejected or deprioritized by the network.
   *
   * ### Response Fields:
   * - **results**: A `TransferResult` object containing transaction ID, success status, and an error message if applicable.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   output: "3e1f89af...e923", // SHA-256 hash of the expected pre-image
   *   pre_image: "6a1b2c...eaf1", // raw pre-image (not hashed)
   *   fee_per_gram: 10
   * };
   * client.claimShaAtomicSwapTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response.results);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "results": {
   *     "address": "",
   *     "transaction_id": 789654,
   *     "is_success": true,
   *     "failure_message": ""
   *   }
   * }
   */
  claimShaAtomicSwapTransaction(
    request: ClaimShaAtomicSwapRequest,
    callback: (error: ServiceError | null, response: ClaimShaAtomicSwapResponse) => void,
  ): ClientUnaryCall;
  claimShaAtomicSwapTransaction(
    request: ClaimShaAtomicSwapRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ClaimShaAtomicSwapResponse) => void,
  ): ClientUnaryCall;
  claimShaAtomicSwapTransaction(
    request: ClaimShaAtomicSwapRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ClaimShaAtomicSwapResponse) => void,
  ): ClientUnaryCall;
  /**
   * Claims an HTLC refund transaction after the timelock period has passed.
   *
   * The `ClaimHtlcRefundTransaction` call enables the original sender of a Hash Time-Locked Contract (HTLC)
   * to reclaim the locked funds if the recipient has not claimed them in time using the correct pre-image.
   * This is possible only after the output's timelock has expired.
   *
   * ### Request Parameters:
   * - **output_hash** (required): Hex-encoded SHA-256 hash of the HTLC output being refunded.
   * - **fee_per_gram** (required): Transaction fee per gram, specified as a `uint64`.
   *
   * ### Input Validation:
   * - `output_hash` must be a valid 64-character hex string representing the hash of the HTLC output.
   * - `fee_per_gram` must be a non-zero `uint64` value.
   *
   * ### Response Fields:
   * - **results**: A `TransferResult` object including transaction ID, success status, and failure reason if any.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   output_hash: "aabbccddeeff0011...99",
   *   fee_per_gram: 20
   * };
   * client.claimHtlcRefundTransaction(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log(response.results);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "results": {
   *     "address": "",
   *     "transaction_id": 889977,
   *     "is_success": true,
   *     "failure_message": ""
   *   }
   * }
   */
  claimHtlcRefundTransaction(
    request: ClaimHtlcRefundRequest,
    callback: (error: ServiceError | null, response: ClaimHtlcRefundResponse) => void,
  ): ClientUnaryCall;
  claimHtlcRefundTransaction(
    request: ClaimHtlcRefundRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ClaimHtlcRefundResponse) => void,
  ): ClientUnaryCall;
  claimHtlcRefundTransaction(
    request: ClaimHtlcRefundRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ClaimHtlcRefundResponse) => void,
  ): ClientUnaryCall;
  /** Creates a transaction with a template registration output */
  createTemplateRegistration(
    request: CreateTemplateRegistrationRequest,
    callback: (error: ServiceError | null, response: CreateTemplateRegistrationResponse) => void,
  ): ClientUnaryCall;
  createTemplateRegistration(
    request: CreateTemplateRegistrationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateTemplateRegistrationResponse) => void,
  ): ClientUnaryCall;
  createTemplateRegistration(
    request: CreateTemplateRegistrationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateTemplateRegistrationResponse) => void,
  ): ClientUnaryCall;
  /**
   * Signs a message using the wallet's node identity private key.
   *
   * The `SignMessage` call creates a Schnorr signature over a message using the wallet's node identity private key.
   * This signature can be used to prove ownership of the wallet or authenticate messages.
   * The signature is returned as separate components (signature and public nonce) for verification.
   *
   * ### Request Parameters:
   *
   * - `message` (required):
   *   - **Type**: `bytes`
   *   - **Description**: The message to be signed (arbitrary bytes).
   *   - **Restrictions**: Can be any byte sequence.
   *
   * ### Response Fields:
   *
   * - **signature**: The Schnorr signature as hex-encoded bytes.
   * - **public_nonce**: The public nonce component of the signature as hex-encoded bytes.
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const request = {
   *   message: Buffer.from("Hello Tari!", "utf-8")
   * };
   * client.signMessage(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Signature:", response.signature, "Nonce:", response.public_nonce);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "signature": "a1b2c3d4e5f6...",
   *   "public_nonce": "f6e5d4c3b2a1..."
   * }
   * ```
   *
   * ### Security Notes:
   *
   * - This signs with the wallet's node identity private key.
   * - The signature can be verified using the wallet's public key.
   * - Use this for authentication and ownership proofs only.
   */
  signMessage(
    request: SignMessageRequest,
    callback: (error: ServiceError | null, response: SignMessageResponse) => void,
  ): ClientUnaryCall;
  signMessage(
    request: SignMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SignMessageResponse) => void,
  ): ClientUnaryCall;
  signMessage(
    request: SignMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SignMessageResponse) => void,
  ): ClientUnaryCall;
  /**
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const call = client.streamTransactionEvents({});
   *
   * call.on("data", (response) => {
   *   console.log("Transaction Event:", response.transaction);
   * });
   *
   * call.on("end", () => {
   *   console.log("Stream ended.");
   * });
   *
   * call.on("error", (err) => {
   *   console.error("Stream error:", err);
   * });
   * ```
   *
   * ### Sample JSON Streamed Response:
   * ```json
   * {
   *   "transaction": {
   *     "event": "Mined",
   *     "tx_id": "103248",
   *     "source_address": "0xabc123...",
   *     "dest_address": "0xdef456...",
   *     "status": "Completed",
   *     "direction": "Outbound",
   *     "amount": 100000000,
   *     "payment_id": "0xdeadbeef..."
   *   }
   * }
   * ```
   */
  streamTransactionEvents(
    request: TransactionEventRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<TransactionEventResponse>;
  streamTransactionEvents(
    request: TransactionEventRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<TransactionEventResponse>;
  importTransactions(
    request: ImportTransactionsRequest,
    callback: (error: ServiceError | null, response: ImportTransactionsResponse) => void,
  ): ClientUnaryCall;
  importTransactions(
    request: ImportTransactionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ImportTransactionsResponse) => void,
  ): ClientUnaryCall;
  importTransactions(
    request: ImportTransactionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ImportTransactionsResponse) => void,
  ): ClientUnaryCall;
  /**
   * Get all completed transactions including cancelled ones, sorted by timestamp and paginated
   * DEPRECATED: Use GetAllCompletedTransactionsStream for better performance and memory efficiency
   *
   * @deprecated
   */
  getAllCompletedTransactions(
    request: GetAllCompletedTransactionsRequest,
    callback: (error: ServiceError | null, response: GetAllCompletedTransactionsResponse) => void,
  ): ClientUnaryCall;
  getAllCompletedTransactions(
    request: GetAllCompletedTransactionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAllCompletedTransactionsResponse) => void,
  ): ClientUnaryCall;
  getAllCompletedTransactions(
    request: GetAllCompletedTransactionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAllCompletedTransactionsResponse) => void,
  ): ClientUnaryCall;
  /**
   * Get all completed transactions including cancelled ones, sorted by timestamp and paginated (streaming version)
   * Recommended: Use this streaming version for better performance and progressive loading
   */
  getAllCompletedTransactionsStream(
    request: GetAllCompletedTransactionsRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetCompletedTransactionsResponse>;
  getAllCompletedTransactionsStream(
    request: GetAllCompletedTransactionsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetCompletedTransactionsResponse>;
  /**
   * Gets transaction information by payment reference (PayRef)
   *
   * The `GetPaymentByReference` call retrieves transaction information using a 32-byte payment reference hash.
   * PayRefs are generated as Blake2b_256(block_hash || output_hash) and provide a stable way to look up
   * transactions even after outputs are spent.
   *
   * ### Request Parameters:
   *
   * - `payment_reference` (required):
   *   - **Type**: `bytes` (32 bytes)
   *   - **Description**: The payment reference hash to look up
   *   - **Restrictions**: Must be exactly 32 bytes representing a valid PayRef
   *
   * ### Example JavaScript gRPC client usage:
   *
   * ```javascript
   * const payref = Buffer.from('a1b2c3d4e5f6789012345678901234567890123456789012345678901234567890', 'hex');
   * const request = { payment_reference: payref };
   * client.getPaymentByReference(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log('Transaction found:', response.transaction);
   * });
   * ```
   *
   * ### Sample JSON Response:
   *
   * ```json
   * {
   *   "transaction": {
   *     "tx_id": 12345,
   *     "source_address": "0x1234abcd...",
   *     "dest_address": "0x5678efgh...",
   *     "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
   *     "direction": "TRANSACTION_DIRECTION_INBOUND",
   *     "amount": 1000000,
   *     "fee": 20,
   *     "is_cancelled": false,
   *     "excess_sig": "0xabcdef...",
   *     "timestamp": 1681234567,
   *     "payment_id": "0xdeadbeef...",
   *     "mined_in_block_height": 150000
   *   }
   * }
   * ```
   */
  getPaymentByReference(
    request: GetPaymentByReferenceRequest,
    callback: (error: ServiceError | null, response: GetPaymentByReferenceResponse) => void,
  ): ClientUnaryCall;
  getPaymentByReference(
    request: GetPaymentByReferenceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetPaymentByReferenceResponse) => void,
  ): ClientUnaryCall;
  getPaymentByReference(
    request: GetPaymentByReferenceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetPaymentByReferenceResponse) => void,
  ): ClientUnaryCall;
  /**
   * Estimates the transaction fee based on amount, fee rate, and number of outputs.
   *
   * The `GetFeeEstimate` call allows clients to calculate the expected transaction fee before sending funds.
   * This is useful for presenting fee information to the user or for ensuring sufficient funds are available.
   *
   * ### Request Parameters:
   * - **amount** (required): The amount to send, in microTari. (1 Tari = 1,000,000 µT).
   * - **fee_per_gram** (required): The fee per gram (weight unit) to use for the estimate. Higher values may improve priority.
   * - **output_count** (required): The number of outputs to create in the transaction (e.g., 2 = recipient + change).
   *
   * ### Input Validation:
   * - `amount` must be a non-zero `uint64` representing the amount to transfer.
   * - `fee_per_gram` must be a non-zero `uint64`; zero or low fees may result in delayed confirmation or failure.
   * - `output_count` must be convertible to a valid `usize`; large values may increase the fee significantly.
   *
   * ### Response Fields:
   * - **estimated_fee**: A `uint64` value representing the estimated total transaction fee in microTari.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   amount: 1000000,         // Sending 1 Tari
   *   fee_per_gram: 5,         // Fee rate of 5 µT/g
   *   output_count: 2          // One recipient + one change output
   * };
   * client.getFeeEstimate(request, (err, response) => {
   *   if (err) console.error(err);
   *   else console.log("Estimated fee:", response.estimated_fee);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "estimated_fee": 12345
   * }
   * ```
   */
  getFeeEstimate(
    request: GetFeeEstimateRequest,
    callback: (error: ServiceError | null, response: GetFeeEstimateResponse) => void,
  ): ClientUnaryCall;
  getFeeEstimate(
    request: GetFeeEstimateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetFeeEstimateResponse) => void,
  ): ClientUnaryCall;
  getFeeEstimate(
    request: GetFeeEstimateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetFeeEstimateResponse) => void,
  ): ClientUnaryCall;
  /**
   * Retrieves fee-per-gram statistics over recent blocks.
   *
   * The `GetFeePerGramStats` call returns aggregated fee rate information to help clients
   * understand recent network fee trends. This can be used for setting appropriate fees
   * when constructing transactions.
   *
   * ### Request Parameters:
   * - **block_count** (optional): The number of recent blocks to include in the statistics.
   *   If not specified or zero, a default number of blocks will be used.
   *
   * ### Input Validation:
   * - `block_count` must be a non-negative `uint64`. Large values may increase query time.
   *
   * ### Response Fields:
   * - **fee_per_gram_stats**: A list of `FeePerGramStat` objects summarizing fee data over the specified blocks.
   *
   * Each `FeePerGramStat` contains:
   * - **average_fee_per_gram**: Average fee per gram observed over the blocks.
   * - **min_fee_per_gram**: Minimum fee per gram observed.
   * - **max_fee_per_gram**: Maximum fee per gram observed.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   block_count: 10 // Consider fees over the last 10 blocks
   * };
   * client.getFeePerGramStats(request, (err, response) => {
   *   if (err) console.error(err);
   *   else response.fee_per_gram_stats.forEach(stat => {
   *     console.log(`Avg: ${stat.average_fee_per_gram}, Min: ${stat.min_fee_per_gram}, Max: ${stat.max_fee_per_gram}`);
   *   });
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "fee_per_gram_stats": [
   *     {
   *       "average_fee_per_gram": 5,
   *       "min_fee_per_gram": 3,
   *       "max_fee_per_gram": 10
   *     }
   *   ]
   * }
   * ```
   */
  getFeePerGramStats(
    request: GetFeePerGramStatsRequest,
    callback: (error: ServiceError | null, response: GetFeePerGramStatsResponse) => void,
  ): ClientUnaryCall;
  getFeePerGramStats(
    request: GetFeePerGramStatsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetFeePerGramStatsResponse) => void,
  ): ClientUnaryCall;
  getFeePerGramStats(
    request: GetFeePerGramStatsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetFeePerGramStatsResponse) => void,
  ): ClientUnaryCall;
  /**
   * Attempts to replace an existing transaction with a new one that has a higher fee.
   *
   * The `ReplaceByFee` call enables clients to increase the fee of a pending transaction,
   * potentially speeding up its confirmation by incentivizing miners to prioritize it.
   *
   * ### Request Parameters:
   * - **transaction_id** (required): The ID of the original transaction to replace.
   * - **fee_increase** (required): The additional fee amount to add, specified in microTari.
   *   Must be greater than zero.
   *
   * ### Input Validation:
   * - `transaction_id` must correspond to a currently unconfirmed transaction.
   * - `fee_increase` must be a non-zero `uint64`. Zero or negative values are invalid.
   *
   * ### Response Fields:
   * - **transaction_id**: The transaction ID of the new replacement transaction.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   transaction_id: 123456,
   *   fee_increase: 5000  // Increase fee by 5,000 microTari
   * };
   * client.replaceByFee(request, (err, response) => {
   *   if (err) console.error("Failed to replace by fee:", err);
   *   else console.log("Replacement transaction ID:", response.transaction_id);
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "transaction_id": 7891011
   * }
   * ```
   */
  replaceByFee(
    request: ReplaceByFeeRequest,
    callback: (error: ServiceError | null, response: ReplaceByFeeResponse) => void,
  ): ClientUnaryCall;
  replaceByFee(
    request: ReplaceByFeeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ReplaceByFeeResponse) => void,
  ): ClientUnaryCall;
  replaceByFee(
    request: ReplaceByFeeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ReplaceByFeeResponse) => void,
  ): ClientUnaryCall;
  /**
   * Allows users to pay a specified fee for spending transaction outputs to given recipients.
   *
   * The `UserPayForFee` call enables clients to request that the wallet pays the fee
   * for one or more transactions identified by their IDs, sending funds to the specified recipients.
   * This is useful for fee bumping or covering transaction fees on behalf of recipients.
   *
   * ### Request Parameters:
   * - **recipients** (required): A list of transfers, each specifying:
   *    - `tx_id`: The transaction ID whose outputs will be spent.
   *    - `fee`: The fee amount in microTari to pay for this transfer.
   *    - `destination`: The Base58-encoded Tari address of the recipient.
   *
   * ### Input Validation:
   * - Each `tx_id` must correspond to a valid transaction whose outputs can be spent.
   * - Each `fee` must be a non-negative uint64 specifying the fee to pay.
   * - Each `destination` must be a valid Base58 Tari address.
   *
   * ### Response Fields:
   * - **results**: A list of `TransferResult` objects, one per requested recipient, each containing:
   *    - `address`: The recipient address as a string.
   *    - `transaction_id`: The ID of the newly created transaction (or zero if failed).
   *    - `is_success`: Boolean indicating if the fee payment transaction succeeded.
   *    - `failure_message`: A string describing the error if the transaction failed.
   *    - `transaction_info`: Detailed transaction metadata if available.
   *
   * ### Example JavaScript gRPC client usage:
   * ```javascript
   * const request = {
   *   recipients: [
   *     {
   *       tx_id: 123,
   *       fee: 1000,
   *       destination: "tari1qxyz..."
   *     },
   *     {
   *       tx_id: 456,
   *       fee: 2000,
   *       destination: "tari1qabcd..."
   *     }
   *   ]
   * };
   * client.userPayForFee(request, (err, response) => {
   *   if (err) console.error("Fee payment failed:", err);
   *   else {
   *     response.results.forEach(result => {
   *       if (result.is_success) {
   *         console.log(`Fee paid successfully to ${result.address} in tx ${result.transaction_id}`);
   *       } else {
   *         console.error(`Failed to pay fee for ${result.address}: ${result.failure_message}`);
   *       }
   *     });
   *   }
   * });
   * ```
   *
   * ### Sample JSON Response:
   * ```json
   * {
   *   "results": [
   *     {
   *       "address": "tari1qxyz...",
   *       "transaction_id": 789,
   *       "is_success": true,
   *       "failure_message": "",
   *       "transaction_info": {
   *         "tx_id": 789,
   *         "source_address": "...",
   *         "dest_address": "...",
   *         "status": "Completed",
   *         "direction": "Outbound",
   *         "amount": 50000,
   *         "fee": 1000,
   *         "is_cancelled": false,
   *         "timestamp": 1620000000
   *       }
   *     },
   *     {
   *       "address": "tari1qabcd...",
   *       "transaction_id": 0,
   *       "is_success": false,
   *       "failure_message": "Invalid destination address",
   *       "transaction_info": null
   *     }
   *   ]
   * }
   * ```
   */
  userPayForFee(
    request: UserPayForFeeRequest,
    callback: (error: ServiceError | null, response: UserPayForFeeResponse) => void,
  ): ClientUnaryCall;
  userPayForFee(
    request: UserPayForFeeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UserPayForFeeResponse) => void,
  ): ClientUnaryCall;
  userPayForFee(
    request: UserPayForFeeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UserPayForFeeResponse) => void,
  ): ClientUnaryCall;
  registerValidatorNode(
    request: RegisterValidatorNodeRequest,
    callback: (error: ServiceError | null, response: RegisterValidatorNodeResponse) => void,
  ): ClientUnaryCall;
  registerValidatorNode(
    request: RegisterValidatorNodeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RegisterValidatorNodeResponse) => void,
  ): ClientUnaryCall;
  registerValidatorNode(
    request: RegisterValidatorNodeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RegisterValidatorNodeResponse) => void,
  ): ClientUnaryCall;
  submitValidatorEvictionProof(
    request: SubmitValidatorEvictionProofRequest,
    callback: (error: ServiceError | null, response: SubmitValidatorEvictionProofResponse) => void,
  ): ClientUnaryCall;
  submitValidatorEvictionProof(
    request: SubmitValidatorEvictionProofRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SubmitValidatorEvictionProofResponse) => void,
  ): ClientUnaryCall;
  submitValidatorEvictionProof(
    request: SubmitValidatorEvictionProofRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SubmitValidatorEvictionProofResponse) => void,
  ): ClientUnaryCall;
  submitValidatorNodeExit(
    request: SubmitValidatorNodeExitRequest,
    callback: (error: ServiceError | null, response: SubmitValidatorNodeExitResponse) => void,
  ): ClientUnaryCall;
  submitValidatorNodeExit(
    request: SubmitValidatorNodeExitRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SubmitValidatorNodeExitResponse) => void,
  ): ClientUnaryCall;
  submitValidatorNodeExit(
    request: SubmitValidatorNodeExitRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SubmitValidatorNodeExitResponse) => void,
  ): ClientUnaryCall;
}

export const WalletClient = makeGenericClientConstructor(WalletService, "tari.rpc.Wallet") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): WalletClient;
  service: typeof WalletService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
