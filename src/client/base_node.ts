// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: base_node.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import { Block, BlockHeader, HistoricalBlock, NewBlockTemplate, PowAlgo } from "./block";
import { ListConnectedPeersResponse, NetworkStatusResponse, NodeIdentity, Peer, SoftwareUpdate } from "./network";
import { TemplateRegistration, ValidatorNodeRegistration } from "./sidechain_types";
import { OutputFeatures, Transaction, TransactionOutput } from "./transaction";
import { BlockHeight, ConsensusConstants, Empty, Signature } from "./types";

export const protobufPackage = "tari.rpc";

/**
 * Copyright 2020. The Tari Project
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 * disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

export enum BaseNodeState {
  START_UP = 0,
  HEADER_SYNC = 1,
  HORIZON_SYNC = 2,
  CONNECTING = 3,
  BLOCK_SYNC = 4,
  LISTENING = 5,
  SYNC_FAILED = 6,
  UNRECOGNIZED = -1,
}

export function baseNodeStateFromJSON(object: any): BaseNodeState {
  switch (object) {
    case 0:
    case "START_UP":
      return BaseNodeState.START_UP;
    case 1:
    case "HEADER_SYNC":
      return BaseNodeState.HEADER_SYNC;
    case 2:
    case "HORIZON_SYNC":
      return BaseNodeState.HORIZON_SYNC;
    case 3:
    case "CONNECTING":
      return BaseNodeState.CONNECTING;
    case 4:
    case "BLOCK_SYNC":
      return BaseNodeState.BLOCK_SYNC;
    case 5:
    case "LISTENING":
      return BaseNodeState.LISTENING;
    case 6:
    case "SYNC_FAILED":
      return BaseNodeState.SYNC_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BaseNodeState.UNRECOGNIZED;
  }
}

export function baseNodeStateToJSON(object: BaseNodeState): string {
  switch (object) {
    case BaseNodeState.START_UP:
      return "START_UP";
    case BaseNodeState.HEADER_SYNC:
      return "HEADER_SYNC";
    case BaseNodeState.HORIZON_SYNC:
      return "HORIZON_SYNC";
    case BaseNodeState.CONNECTING:
      return "CONNECTING";
    case BaseNodeState.BLOCK_SYNC:
      return "BLOCK_SYNC";
    case BaseNodeState.LISTENING:
      return "LISTENING";
    case BaseNodeState.SYNC_FAILED:
      return "SYNC_FAILED";
    case BaseNodeState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CalcType {
  MEAN = 0,
  MEDIAN = 1,
  QUANTILE = 2,
  QUARTILE = 3,
  UNRECOGNIZED = -1,
}

export function calcTypeFromJSON(object: any): CalcType {
  switch (object) {
    case 0:
    case "MEAN":
      return CalcType.MEAN;
    case 1:
    case "MEDIAN":
      return CalcType.MEDIAN;
    case 2:
    case "QUANTILE":
      return CalcType.QUANTILE;
    case 3:
    case "QUARTILE":
      return CalcType.QUARTILE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CalcType.UNRECOGNIZED;
  }
}

export function calcTypeToJSON(object: CalcType): string {
  switch (object) {
    case CalcType.MEAN:
      return "MEAN";
    case CalcType.MEDIAN:
      return "MEDIAN";
    case CalcType.QUANTILE:
      return "QUANTILE";
    case CalcType.QUARTILE:
      return "QUARTILE";
    case CalcType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Sorting {
  SORTING_DESC = 0,
  SORTING_ASC = 1,
  UNRECOGNIZED = -1,
}

export function sortingFromJSON(object: any): Sorting {
  switch (object) {
    case 0:
    case "SORTING_DESC":
      return Sorting.SORTING_DESC;
    case 1:
    case "SORTING_ASC":
      return Sorting.SORTING_ASC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Sorting.UNRECOGNIZED;
  }
}

export function sortingToJSON(object: Sorting): string {
  switch (object) {
    case Sorting.SORTING_DESC:
      return "SORTING_DESC";
    case Sorting.SORTING_ASC:
      return "SORTING_ASC";
    case Sorting.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SyncState {
  STARTUP = 0,
  HEADER_STARTING = 1,
  HEADER = 2,
  BLOCK_STARTING = 3,
  BLOCK = 4,
  DONE = 5,
  UNRECOGNIZED = -1,
}

export function syncStateFromJSON(object: any): SyncState {
  switch (object) {
    case 0:
    case "STARTUP":
      return SyncState.STARTUP;
    case 1:
    case "HEADER_STARTING":
      return SyncState.HEADER_STARTING;
    case 2:
    case "HEADER":
      return SyncState.HEADER;
    case 3:
    case "BLOCK_STARTING":
      return SyncState.BLOCK_STARTING;
    case 4:
    case "BLOCK":
      return SyncState.BLOCK;
    case 5:
    case "DONE":
      return SyncState.DONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SyncState.UNRECOGNIZED;
  }
}

export function syncStateToJSON(object: SyncState): string {
  switch (object) {
    case SyncState.STARTUP:
      return "STARTUP";
    case SyncState.HEADER_STARTING:
      return "HEADER_STARTING";
    case SyncState.HEADER:
      return "HEADER";
    case SyncState.BLOCK_STARTING:
      return "BLOCK_STARTING";
    case SyncState.BLOCK:
      return "BLOCK";
    case SyncState.DONE:
      return "DONE";
    case SyncState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SubmitTransactionResult {
  NONE = 0,
  ACCEPTED = 1,
  NOT_PROCESSABLE_AT_THIS_TIME = 2,
  ALREADY_MINED = 3,
  REJECTED = 4,
  UNRECOGNIZED = -1,
}

export function submitTransactionResultFromJSON(object: any): SubmitTransactionResult {
  switch (object) {
    case 0:
    case "NONE":
      return SubmitTransactionResult.NONE;
    case 1:
    case "ACCEPTED":
      return SubmitTransactionResult.ACCEPTED;
    case 2:
    case "NOT_PROCESSABLE_AT_THIS_TIME":
      return SubmitTransactionResult.NOT_PROCESSABLE_AT_THIS_TIME;
    case 3:
    case "ALREADY_MINED":
      return SubmitTransactionResult.ALREADY_MINED;
    case 4:
    case "REJECTED":
      return SubmitTransactionResult.REJECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubmitTransactionResult.UNRECOGNIZED;
  }
}

export function submitTransactionResultToJSON(object: SubmitTransactionResult): string {
  switch (object) {
    case SubmitTransactionResult.NONE:
      return "NONE";
    case SubmitTransactionResult.ACCEPTED:
      return "ACCEPTED";
    case SubmitTransactionResult.NOT_PROCESSABLE_AT_THIS_TIME:
      return "NOT_PROCESSABLE_AT_THIS_TIME";
    case SubmitTransactionResult.ALREADY_MINED:
      return "ALREADY_MINED";
    case SubmitTransactionResult.REJECTED:
      return "REJECTED";
    case SubmitTransactionResult.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransactionLocation {
  UNKNOWN = 0,
  MEMPOOL = 1,
  MINED = 2,
  NOT_STORED = 3,
  UNRECOGNIZED = -1,
}

export function transactionLocationFromJSON(object: any): TransactionLocation {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return TransactionLocation.UNKNOWN;
    case 1:
    case "MEMPOOL":
      return TransactionLocation.MEMPOOL;
    case 2:
    case "MINED":
      return TransactionLocation.MINED;
    case 3:
    case "NOT_STORED":
      return TransactionLocation.NOT_STORED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionLocation.UNRECOGNIZED;
  }
}

export function transactionLocationToJSON(object: TransactionLocation): string {
  switch (object) {
    case TransactionLocation.UNKNOWN:
      return "UNKNOWN";
    case TransactionLocation.MEMPOOL:
      return "MEMPOOL";
    case TransactionLocation.MINED:
      return "MINED";
    case TransactionLocation.NOT_STORED:
      return "NOT_STORED";
    case TransactionLocation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GetAssetMetadataRequest {
  assetPublicKey: Uint8Array;
}

export interface GetAssetMetadataResponse {
  name: string;
  description: string;
  image: string;
  ownerCommitment: Uint8Array;
  features: OutputFeatures | undefined;
  minedHeight: Long;
  minedInBlock: Uint8Array;
}

export interface ListAssetRegistrationsRequest {
  offset: Long;
  count: Long;
}

export interface ListAssetRegistrationsResponse {
  assetPublicKey: Uint8Array;
  uniqueId: Uint8Array;
  ownerCommitment: Uint8Array;
  minedHeight: Long;
  minedInBlock: Uint8Array;
  features: OutputFeatures | undefined;
  script: Uint8Array;
}

export interface GetTokensRequest {
  assetPublicKey: Uint8Array;
  /** Optionally get a set of specific unique_ids */
  uniqueIds: Uint8Array[];
}

export interface GetTokensResponse {
  uniqueId: Uint8Array;
  assetPublicKey: Uint8Array;
  ownerCommitment: Uint8Array;
  minedInBlock: Uint8Array;
  minedHeight: Long;
  features: OutputFeatures | undefined;
  script: Uint8Array;
}

export interface SubmitBlockResponse {
  blockHash: Uint8Array;
}

export interface BlockBlobRequest {
  headerBlob: Uint8Array;
  bodyBlob: Uint8Array;
}

/** / return type of GetTipInfo */
export interface TipInfoResponse {
  metadata: MetaData | undefined;
  initialSyncAchieved: boolean;
  baseNodeState: BaseNodeState;
  failedCheckpoints: boolean;
}

export interface ReadinessStatus {
  state?: ReadinessStatus_State | undefined;
  migration?: MigrationProgress | undefined;
  timestamp: Long;
}

export enum ReadinessStatus_State {
  NOT_READY = 0,
  STARTING_UP = 1,
  /** DATABASE_INITIALIZING - Database phase (10-19) */
  DATABASE_INITIALIZING = 10,
  /** RECOVERING_PREPARING - Recovery phase (20-29) */
  RECOVERING_PREPARING = 20,
  RECOVERING_REBUILDING = 21,
  RECOVERING_REBUILDING_DATABASE = 22,
  /** BUILDING_CONTEXT_BLOCKCHAIN - Context building phase (30-39) */
  BUILDING_CONTEXT_BLOCKCHAIN = 32,
  BUILDING_CONTEXT_BOOTSTRAP = 34,
  READY = 100,
  UNRECOGNIZED = -1,
}

export function readinessStatus_StateFromJSON(object: any): ReadinessStatus_State {
  switch (object) {
    case 0:
    case "NOT_READY":
      return ReadinessStatus_State.NOT_READY;
    case 1:
    case "STARTING_UP":
      return ReadinessStatus_State.STARTING_UP;
    case 10:
    case "DATABASE_INITIALIZING":
      return ReadinessStatus_State.DATABASE_INITIALIZING;
    case 20:
    case "RECOVERING_PREPARING":
      return ReadinessStatus_State.RECOVERING_PREPARING;
    case 21:
    case "RECOVERING_REBUILDING":
      return ReadinessStatus_State.RECOVERING_REBUILDING;
    case 22:
    case "RECOVERING_REBUILDING_DATABASE":
      return ReadinessStatus_State.RECOVERING_REBUILDING_DATABASE;
    case 32:
    case "BUILDING_CONTEXT_BLOCKCHAIN":
      return ReadinessStatus_State.BUILDING_CONTEXT_BLOCKCHAIN;
    case 34:
    case "BUILDING_CONTEXT_BOOTSTRAP":
      return ReadinessStatus_State.BUILDING_CONTEXT_BOOTSTRAP;
    case 100:
    case "READY":
      return ReadinessStatus_State.READY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReadinessStatus_State.UNRECOGNIZED;
  }
}

export function readinessStatus_StateToJSON(object: ReadinessStatus_State): string {
  switch (object) {
    case ReadinessStatus_State.NOT_READY:
      return "NOT_READY";
    case ReadinessStatus_State.STARTING_UP:
      return "STARTING_UP";
    case ReadinessStatus_State.DATABASE_INITIALIZING:
      return "DATABASE_INITIALIZING";
    case ReadinessStatus_State.RECOVERING_PREPARING:
      return "RECOVERING_PREPARING";
    case ReadinessStatus_State.RECOVERING_REBUILDING:
      return "RECOVERING_REBUILDING";
    case ReadinessStatus_State.RECOVERING_REBUILDING_DATABASE:
      return "RECOVERING_REBUILDING_DATABASE";
    case ReadinessStatus_State.BUILDING_CONTEXT_BLOCKCHAIN:
      return "BUILDING_CONTEXT_BLOCKCHAIN";
    case ReadinessStatus_State.BUILDING_CONTEXT_BOOTSTRAP:
      return "BUILDING_CONTEXT_BOOTSTRAP";
    case ReadinessStatus_State.READY:
      return "READY";
    case ReadinessStatus_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface MigrationProgress {
  currentBlock: Long;
  totalBlocks: Long;
  progressPercentage: number;
  currentDbVersion: Long;
  targetDbVersion: Long;
}

/** / return type of GetNewBlockTemplate */
export interface NewBlockTemplateResponse {
  newBlockTemplate: NewBlockTemplate | undefined;
  initialSyncAchieved: boolean;
  minerData: MinerData | undefined;
}

/** / return type of NewBlockTemplateRequest */
export interface NewBlockTemplateRequest {
  algo:
    | PowAlgo
    | undefined;
  /** This field should be moved to optional once optional keyword is standard */
  maxWeight: Long;
}

/** / return type of NewBlockTemplateRequest */
export interface GetNewBlockTemplateWithCoinbasesRequest {
  algo:
    | PowAlgo
    | undefined;
  /** This field should be moved to optional once optional keyword is standard */
  maxWeight: Long;
  coinbases: NewBlockCoinbase[];
}

/** / request  type of GetNewBlockWithCoinbasesRequest */
export interface GetNewBlockWithCoinbasesRequest {
  newTemplate: NewBlockTemplate | undefined;
  coinbases: NewBlockCoinbase[];
}

export interface NewBlockCoinbase {
  address: string;
  value: Long;
  stealthPayment: boolean;
  revealedValueProof: boolean;
  coinbaseExtra: Uint8Array;
}

/** Network difficulty response */
export interface NetworkDifficultyResponse {
  difficulty: Long;
  estimatedHashRate: Long;
  height: Long;
  timestamp: Long;
  powAlgo: Long;
  sha3xEstimatedHashRate: Long;
  moneroRandomxEstimatedHashRate: Long;
  tariRandomxEstimatedHashRate: Long;
  numCoinbases: Long;
  coinbaseExtras: Uint8Array[];
}

/** A generic single value response for a specific height */
export interface ValueAtHeightResponse {
  /** This is the total circulating token supply up to date ('mined_rewards + spendable_pre_mine'). */
  circulatingSupply: Long;
  /**
   * uint64 spendable_supply = 2;      // No longer used
   * This is the block height the values are valid for.
   */
  height: Long;
  /** This is the total mined rewards up to date, including time locked coinbase rewards that is not spendable. */
  minedRewards: Long;
  /**
   * This is the total spendable minded rewards up to date, which excludes all coinbase rewards that is
   * still time locked.
   */
  spendableRewards: Long;
  /** This is the total spendable pre-mine tokens released up to date, i.e. not time-locked anymore. */
  spendablePreMine: Long;
  /** This is the total spendable token supply up to date ('spendable_rewards + spendable_pre_mine'). */
  totalSpendable: Long;
  /** This is the total pre-mine tokens in the genesis block, time-locked and not time-locked. */
  totalPreMine: Long;
  /** This is the total pre-mine tokens that are still time-locked up to date (`total_pre_mine - spendable_pre_mine`). */
  timeLockedPreMine: Long;
}

/** A generic uint value */
export interface IntegerValue {
  value: Long;
}

export interface BaseNodeGetVersionResponse {
  version: string;
  network: number;
}

/**
 * / GetBlockSize / GetBlockFees Request
 * / Either the starting and ending heights OR the from_tip param must be specified
 */
export interface BlockGroupRequest {
  /** The height from the chain tip (optional) */
  fromTip: Long;
  /** The starting height (optional) */
  startHeight: Long;
  /** The ending height (optional) */
  endHeight: Long;
  /**
   * / The type of calculation required (optional)
   * / Defaults to median
   * / median, mean, quartile, quantile
   */
  calcType: CalcType;
}

/** / GetBlockSize / GetBlockFees  Response */
export interface BlockGroupResponse {
  value: number[];
  calcType: CalcType;
}

/**
 * The request used for querying a function that requires a height, either between 2 points or from the chain tip
 * If start_height and end_height are set and > 0, they take precedence, otherwise from_tip is used
 */
export interface HeightRequest {
  /** The height from the chain tip (optional) */
  fromTip: Long;
  /** The starting height (optional) */
  startHeight: Long;
  /** The ending height (optional) */
  endHeight: Long;
}

/** The return type of the rpc GetBlockTiming */
export interface BlockTimingResponse {
  max: Long;
  min: Long;
  avg: number;
}

/** Request that returns a header based by hash */
export interface GetHeaderByHashRequest {
  /** The hash of the block header */
  hash: Uint8Array;
}

export interface BlockHeaderResponse {
  /** The block header */
  header:
    | BlockHeader
    | undefined;
  /** The number of blocks from the tip of this block (a.k.a depth) */
  confirmations: Long;
  /** The block reward i.e mining reward + fees */
  reward: Long;
  /** Achieved difficulty */
  difficulty: Long;
  /** The number of transactions contained in the block */
  numTransactions: number;
}

/**
 * The request used for querying headers from the base node. The parameters `from_height` and `num_headers` can be used
 * to page through the current best chain.
 */
export interface ListHeadersRequest {
  /**
   * The height to start at. Depending on sorting, will either default to use the tip or genesis block, for `SORTING_DESC`
   * and `SORTING_ASC` respectively, if a value is not provided. The first header returned will be at this height
   * followed by `num_headers` - 1 headers in the direction specified by `sorting`. If greater than the current tip,
   * the current tip will be used.
   */
  fromHeight: Long;
  /** The number of headers to return. If not specified, it will default to 10 */
  numHeaders: Long;
  /**
   * The ordering to return the headers in. If not specified will default to SORTING_DESC. Note that if `from_height`
   * is not specified or is 0, if `sorting` is SORTING_DESC, the tip will be used as `from_height`, otherwise the
   * block at height 0 will be used.
   */
  sorting: Sorting;
}

/**
 * The request used for querying blocks in the base node's current best chain. Currently only querying by height is
 * available. Multiple blocks may be queried.e.g. [189092,100023,122424]. The order in which they are returned is not
 * guaranteed.
 */
export interface GetBlocksRequest {
  heights: Long[];
}

/** The return type of the rpc GetBlocks. Blocks are not guaranteed to be returned in the order requested. */
export interface GetBlocksResponse {
  blocks: HistoricalBlock[];
}

export interface MetaData {
  /** The current chain height, or the block number of the longest valid chain, or `None` if there is no chain */
  bestBlockHeight: Long;
  /** The block hash of the current tip of the longest valid chain, or `None` for an empty chain */
  bestBlockHash: Uint8Array;
  /** The current geometric mean of the pow of the chain tip, or `None` if there is no chain */
  accumulatedDifficulty: Uint8Array;
  /** This is the min height this node can provide complete blocks for. A 0 here means this node is archival and can provide complete blocks for every height. */
  prunedHeight: Long;
  timestamp: Long;
}

export interface SyncInfoResponse {
  tipHeight: Long;
  localHeight: Long;
  peerNodeId: Uint8Array[];
}

export interface SyncProgressResponse {
  tipHeight: Long;
  localHeight: Long;
  state: SyncState;
  shortDesc: string;
  initialConnectedPeers: Long;
}

/** This is the message that is returned for a miner after it asks for a new block. */
export interface GetNewBlockResult {
  /** This is the header hash of the completed block */
  blockHash: Uint8Array;
  /** This is the completed block */
  block: Block | undefined;
  mergeMiningHash: Uint8Array;
  tariUniqueId: Uint8Array;
  minerData: MinerData | undefined;
  vmKey: Uint8Array;
}

/** This is the message that is returned for a miner after it asks for a new block. */
export interface GetNewBlockBlobResult {
  /** This is the header hash of the completed block */
  blockHash: Uint8Array;
  /** This is the completed block's header */
  header: Uint8Array;
  /** This is the completed block's body */
  blockBody: Uint8Array;
  mergeMiningHash: Uint8Array;
  utxoMr: Uint8Array;
  tariUniqueId: Uint8Array;
}

/** This is mining data for the miner asking for a new block */
export interface MinerData {
  algo: PowAlgo | undefined;
  targetDifficulty: Long;
  reward: Long;
  /** bytes merge_mining_hash =4; */
  totalFees: Long;
}

/** This is the request type for the Search Kernels rpc */
export interface SearchKernelsRequest {
  signatures: Signature[];
}

/** This is the request type for the Search Utxo rpc */
export interface SearchUtxosRequest {
  commitments: Uint8Array[];
}

export interface FetchMatchingUtxosRequest {
  hashes: Uint8Array[];
}

export interface FetchMatchingUtxosResponse {
  output: TransactionOutput | undefined;
}

/** This is the request type of the get all peers rpc call */
export interface GetPeersResponse {
  peer: Peer | undefined;
}

export interface GetPeersRequest {
}

export interface SubmitTransactionRequest {
  transaction: Transaction | undefined;
}

export interface SubmitTransactionResponse {
  result: SubmitTransactionResult;
}

export interface GetMempoolTransactionsRequest {
}

export interface GetMempoolTransactionsResponse {
  transaction: Transaction | undefined;
}

export interface TransactionStateRequest {
  excessSig: Signature | undefined;
}

export interface TransactionStateResponse {
  result: TransactionLocation;
}

export interface MempoolStatsResponse {
  unconfirmedTxs: Long;
  reorgTxs: Long;
  unconfirmedWeight: Long;
}

export interface GetActiveValidatorNodesRequest {
  height: Long;
  sidechainId: Uint8Array;
}

export interface GetActiveValidatorNodesResponse {
  shardKey: Uint8Array;
  publicKey: Uint8Array;
  sidechainId: Uint8Array;
}

export interface GetValidatorNodeChangesRequest {
  epoch: Long;
  sidechainId: Uint8Array;
}

export interface ValidatorNodeChange {
  add?: ValidatorNodeChangeAdd | undefined;
  remove?: ValidatorNodeChangeRemove | undefined;
}

export interface ValidatorNodeChangeAdd {
  activationEpoch: Long;
  registration: ValidatorNodeRegistration | undefined;
  minimumValuePromise: Long;
  shardKey: Uint8Array;
}

export interface ValidatorNodeChangeRemove {
  publicKey: Uint8Array;
}

export interface GetValidatorNodeChangesResponse {
  changes: ValidatorNodeChange[];
}

export interface GetShardKeyRequest {
  epoch: Long;
  publicKey: Uint8Array;
}

export interface GetShardKeyResponse {
  shardKey: Uint8Array;
}

export interface GetTemplateRegistrationsRequest {
  startHash: Uint8Array;
  count: Long;
}

export interface GetTemplateRegistrationResponse {
  utxoHash: Uint8Array;
  registration: TemplateRegistration | undefined;
}

export interface BlockInfo {
  height: Long;
  hash: Uint8Array;
  nextBlockHash: Uint8Array;
}

export interface GetSideChainUtxosRequest {
  startHash: Uint8Array;
  count: Long;
}

export interface GetSideChainUtxosResponse {
  blockInfo: BlockInfo | undefined;
  outputs: TransactionOutput[];
}

export interface GetNetworkStateRequest {
}

export interface GetNetworkStateResponse {
  /** metadata */
  metadata:
    | MetaData
    | undefined;
  /** has the base node synced */
  initialSyncAchieved: boolean;
  /** current state of the base node */
  baseNodeState: BaseNodeState;
  /** do we have failed checkpoints */
  failedCheckpoints: boolean;
  /** The block reward of the next tip */
  reward: Long;
  /** estimate sha3x hash rate */
  sha3xEstimatedHashRate: Long;
  /** estimate randomx hash rate */
  moneroRandomxEstimatedHashRate: Long;
  tariRandomxEstimatedHashRate: Long;
  /** number of connections */
  numConnections: Long;
  /** liveness results */
  livenessResults: LivenessResult[];
  /** readiness status */
  readinessStatus: ReadinessStatus | undefined;
}

export interface LivenessResult {
  /** node id */
  peerNodeId: Uint8Array;
  /** time to discover */
  discoverLatency: Long;
  /** Dial latency */
  pingLatency: Long;
}

/** Request to search for outputs by payment reference */
export interface SearchPaymentReferencesRequest {
  /** Payment reference as hex string (64 characters) */
  paymentReferenceHex: string[];
  paymentReferenceBytes: Uint8Array[];
  /** Optional: include spent outputs in results */
  includeSpent: boolean;
}

/** Response containing payment reference match */
export interface PaymentReferenceResponse {
  /** The payment reference that was found */
  paymentReferenceHex: string;
  /** Block height where the output was mined */
  blockHeight: Long;
  /** Block hash where the output was mined */
  blockHash: Uint8Array;
  /** Timestamp when the output was mined */
  minedTimestamp: Long;
  /** Output commitment (32 bytes) */
  commitment: Uint8Array;
  /** Whether this output has been spent */
  isSpent: boolean;
  /** Height where output was spent - will be 0 for unspent outputs as it is not applicable */
  spentHeight: Long;
  /** Block hash where output was spent - will be empty for unspent outputs */
  spentBlockHash: Uint8Array;
  /** Minimum value promise */
  minValuePromise: Long;
  /** Timestamp when the output was spent - will be 0 for unspent outputs as it is not applicable */
  spentTimestamp: Long;
  /** Output hash of the output */
  outputHash: Uint8Array;
}

function createBaseGetAssetMetadataRequest(): GetAssetMetadataRequest {
  return { assetPublicKey: new Uint8Array(0) };
}

export const GetAssetMetadataRequest: MessageFns<GetAssetMetadataRequest> = {
  encode(message: GetAssetMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.assetPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAssetMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetMetadataRequest {
    return {
      assetPublicKey: isSet(object.assetPublicKey) ? bytesFromBase64(object.assetPublicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: GetAssetMetadataRequest): unknown {
    const obj: any = {};
    if (message.assetPublicKey.length !== 0) {
      obj.assetPublicKey = base64FromBytes(message.assetPublicKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAssetMetadataRequest>, I>>(base?: I): GetAssetMetadataRequest {
    return GetAssetMetadataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAssetMetadataRequest>, I>>(object: I): GetAssetMetadataRequest {
    const message = createBaseGetAssetMetadataRequest();
    message.assetPublicKey = object.assetPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetAssetMetadataResponse(): GetAssetMetadataResponse {
  return {
    name: "",
    description: "",
    image: "",
    ownerCommitment: new Uint8Array(0),
    features: undefined,
    minedHeight: Long.UZERO,
    minedInBlock: new Uint8Array(0),
  };
}

export const GetAssetMetadataResponse: MessageFns<GetAssetMetadataResponse> = {
  encode(message: GetAssetMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.image !== "") {
      writer.uint32(34).string(message.image);
    }
    if (message.ownerCommitment.length !== 0) {
      writer.uint32(42).bytes(message.ownerCommitment);
    }
    if (message.features !== undefined) {
      OutputFeatures.encode(message.features, writer.uint32(50).fork()).join();
    }
    if (!message.minedHeight.equals(Long.UZERO)) {
      writer.uint32(56).uint64(message.minedHeight.toString());
    }
    if (message.minedInBlock.length !== 0) {
      writer.uint32(66).bytes(message.minedInBlock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAssetMetadataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.image = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ownerCommitment = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.features = OutputFeatures.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.minedHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.minedInBlock = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetMetadataResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      ownerCommitment: isSet(object.ownerCommitment) ? bytesFromBase64(object.ownerCommitment) : new Uint8Array(0),
      features: isSet(object.features) ? OutputFeatures.fromJSON(object.features) : undefined,
      minedHeight: isSet(object.minedHeight) ? Long.fromValue(object.minedHeight) : Long.UZERO,
      minedInBlock: isSet(object.minedInBlock) ? bytesFromBase64(object.minedInBlock) : new Uint8Array(0),
    };
  },

  toJSON(message: GetAssetMetadataResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.ownerCommitment.length !== 0) {
      obj.ownerCommitment = base64FromBytes(message.ownerCommitment);
    }
    if (message.features !== undefined) {
      obj.features = OutputFeatures.toJSON(message.features);
    }
    if (!message.minedHeight.equals(Long.UZERO)) {
      obj.minedHeight = (message.minedHeight || Long.UZERO).toString();
    }
    if (message.minedInBlock.length !== 0) {
      obj.minedInBlock = base64FromBytes(message.minedInBlock);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAssetMetadataResponse>, I>>(base?: I): GetAssetMetadataResponse {
    return GetAssetMetadataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAssetMetadataResponse>, I>>(object: I): GetAssetMetadataResponse {
    const message = createBaseGetAssetMetadataResponse();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.image = object.image ?? "";
    message.ownerCommitment = object.ownerCommitment ?? new Uint8Array(0);
    message.features = (object.features !== undefined && object.features !== null)
      ? OutputFeatures.fromPartial(object.features)
      : undefined;
    message.minedHeight = (object.minedHeight !== undefined && object.minedHeight !== null)
      ? Long.fromValue(object.minedHeight)
      : Long.UZERO;
    message.minedInBlock = object.minedInBlock ?? new Uint8Array(0);
    return message;
  },
};

function createBaseListAssetRegistrationsRequest(): ListAssetRegistrationsRequest {
  return { offset: Long.UZERO, count: Long.UZERO };
}

export const ListAssetRegistrationsRequest: MessageFns<ListAssetRegistrationsRequest> = {
  encode(message: ListAssetRegistrationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.offset.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.offset.toString());
    }
    if (!message.count.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.count.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetRegistrationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetRegistrationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetRegistrationsRequest {
    return {
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.UZERO,
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.UZERO,
    };
  },

  toJSON(message: ListAssetRegistrationsRequest): unknown {
    const obj: any = {};
    if (!message.offset.equals(Long.UZERO)) {
      obj.offset = (message.offset || Long.UZERO).toString();
    }
    if (!message.count.equals(Long.UZERO)) {
      obj.count = (message.count || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAssetRegistrationsRequest>, I>>(base?: I): ListAssetRegistrationsRequest {
    return ListAssetRegistrationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAssetRegistrationsRequest>, I>>(
    object: I,
  ): ListAssetRegistrationsRequest {
    const message = createBaseListAssetRegistrationsRequest();
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.UZERO;
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.UZERO;
    return message;
  },
};

function createBaseListAssetRegistrationsResponse(): ListAssetRegistrationsResponse {
  return {
    assetPublicKey: new Uint8Array(0),
    uniqueId: new Uint8Array(0),
    ownerCommitment: new Uint8Array(0),
    minedHeight: Long.UZERO,
    minedInBlock: new Uint8Array(0),
    features: undefined,
    script: new Uint8Array(0),
  };
}

export const ListAssetRegistrationsResponse: MessageFns<ListAssetRegistrationsResponse> = {
  encode(message: ListAssetRegistrationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.assetPublicKey);
    }
    if (message.uniqueId.length !== 0) {
      writer.uint32(18).bytes(message.uniqueId);
    }
    if (message.ownerCommitment.length !== 0) {
      writer.uint32(26).bytes(message.ownerCommitment);
    }
    if (!message.minedHeight.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.minedHeight.toString());
    }
    if (message.minedInBlock.length !== 0) {
      writer.uint32(42).bytes(message.minedInBlock);
    }
    if (message.features !== undefined) {
      OutputFeatures.encode(message.features, writer.uint32(50).fork()).join();
    }
    if (message.script.length !== 0) {
      writer.uint32(58).bytes(message.script);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetRegistrationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetRegistrationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uniqueId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ownerCommitment = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.minedHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.minedInBlock = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.features = OutputFeatures.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.script = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetRegistrationsResponse {
    return {
      assetPublicKey: isSet(object.assetPublicKey) ? bytesFromBase64(object.assetPublicKey) : new Uint8Array(0),
      uniqueId: isSet(object.uniqueId) ? bytesFromBase64(object.uniqueId) : new Uint8Array(0),
      ownerCommitment: isSet(object.ownerCommitment) ? bytesFromBase64(object.ownerCommitment) : new Uint8Array(0),
      minedHeight: isSet(object.minedHeight) ? Long.fromValue(object.minedHeight) : Long.UZERO,
      minedInBlock: isSet(object.minedInBlock) ? bytesFromBase64(object.minedInBlock) : new Uint8Array(0),
      features: isSet(object.features) ? OutputFeatures.fromJSON(object.features) : undefined,
      script: isSet(object.script) ? bytesFromBase64(object.script) : new Uint8Array(0),
    };
  },

  toJSON(message: ListAssetRegistrationsResponse): unknown {
    const obj: any = {};
    if (message.assetPublicKey.length !== 0) {
      obj.assetPublicKey = base64FromBytes(message.assetPublicKey);
    }
    if (message.uniqueId.length !== 0) {
      obj.uniqueId = base64FromBytes(message.uniqueId);
    }
    if (message.ownerCommitment.length !== 0) {
      obj.ownerCommitment = base64FromBytes(message.ownerCommitment);
    }
    if (!message.minedHeight.equals(Long.UZERO)) {
      obj.minedHeight = (message.minedHeight || Long.UZERO).toString();
    }
    if (message.minedInBlock.length !== 0) {
      obj.minedInBlock = base64FromBytes(message.minedInBlock);
    }
    if (message.features !== undefined) {
      obj.features = OutputFeatures.toJSON(message.features);
    }
    if (message.script.length !== 0) {
      obj.script = base64FromBytes(message.script);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAssetRegistrationsResponse>, I>>(base?: I): ListAssetRegistrationsResponse {
    return ListAssetRegistrationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAssetRegistrationsResponse>, I>>(
    object: I,
  ): ListAssetRegistrationsResponse {
    const message = createBaseListAssetRegistrationsResponse();
    message.assetPublicKey = object.assetPublicKey ?? new Uint8Array(0);
    message.uniqueId = object.uniqueId ?? new Uint8Array(0);
    message.ownerCommitment = object.ownerCommitment ?? new Uint8Array(0);
    message.minedHeight = (object.minedHeight !== undefined && object.minedHeight !== null)
      ? Long.fromValue(object.minedHeight)
      : Long.UZERO;
    message.minedInBlock = object.minedInBlock ?? new Uint8Array(0);
    message.features = (object.features !== undefined && object.features !== null)
      ? OutputFeatures.fromPartial(object.features)
      : undefined;
    message.script = object.script ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetTokensRequest(): GetTokensRequest {
  return { assetPublicKey: new Uint8Array(0), uniqueIds: [] };
}

export const GetTokensRequest: MessageFns<GetTokensRequest> = {
  encode(message: GetTokensRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.assetPublicKey);
    }
    for (const v of message.uniqueIds) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTokensRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uniqueIds.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokensRequest {
    return {
      assetPublicKey: isSet(object.assetPublicKey) ? bytesFromBase64(object.assetPublicKey) : new Uint8Array(0),
      uniqueIds: globalThis.Array.isArray(object?.uniqueIds)
        ? object.uniqueIds.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: GetTokensRequest): unknown {
    const obj: any = {};
    if (message.assetPublicKey.length !== 0) {
      obj.assetPublicKey = base64FromBytes(message.assetPublicKey);
    }
    if (message.uniqueIds?.length) {
      obj.uniqueIds = message.uniqueIds.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokensRequest>, I>>(base?: I): GetTokensRequest {
    return GetTokensRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokensRequest>, I>>(object: I): GetTokensRequest {
    const message = createBaseGetTokensRequest();
    message.assetPublicKey = object.assetPublicKey ?? new Uint8Array(0);
    message.uniqueIds = object.uniqueIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetTokensResponse(): GetTokensResponse {
  return {
    uniqueId: new Uint8Array(0),
    assetPublicKey: new Uint8Array(0),
    ownerCommitment: new Uint8Array(0),
    minedInBlock: new Uint8Array(0),
    minedHeight: Long.UZERO,
    features: undefined,
    script: new Uint8Array(0),
  };
}

export const GetTokensResponse: MessageFns<GetTokensResponse> = {
  encode(message: GetTokensResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uniqueId.length !== 0) {
      writer.uint32(10).bytes(message.uniqueId);
    }
    if (message.assetPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.assetPublicKey);
    }
    if (message.ownerCommitment.length !== 0) {
      writer.uint32(26).bytes(message.ownerCommitment);
    }
    if (message.minedInBlock.length !== 0) {
      writer.uint32(34).bytes(message.minedInBlock);
    }
    if (!message.minedHeight.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.minedHeight.toString());
    }
    if (message.features !== undefined) {
      OutputFeatures.encode(message.features, writer.uint32(50).fork()).join();
    }
    if (message.script.length !== 0) {
      writer.uint32(58).bytes(message.script);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTokensResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uniqueId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ownerCommitment = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.minedInBlock = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.minedHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.features = OutputFeatures.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.script = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokensResponse {
    return {
      uniqueId: isSet(object.uniqueId) ? bytesFromBase64(object.uniqueId) : new Uint8Array(0),
      assetPublicKey: isSet(object.assetPublicKey) ? bytesFromBase64(object.assetPublicKey) : new Uint8Array(0),
      ownerCommitment: isSet(object.ownerCommitment) ? bytesFromBase64(object.ownerCommitment) : new Uint8Array(0),
      minedInBlock: isSet(object.minedInBlock) ? bytesFromBase64(object.minedInBlock) : new Uint8Array(0),
      minedHeight: isSet(object.minedHeight) ? Long.fromValue(object.minedHeight) : Long.UZERO,
      features: isSet(object.features) ? OutputFeatures.fromJSON(object.features) : undefined,
      script: isSet(object.script) ? bytesFromBase64(object.script) : new Uint8Array(0),
    };
  },

  toJSON(message: GetTokensResponse): unknown {
    const obj: any = {};
    if (message.uniqueId.length !== 0) {
      obj.uniqueId = base64FromBytes(message.uniqueId);
    }
    if (message.assetPublicKey.length !== 0) {
      obj.assetPublicKey = base64FromBytes(message.assetPublicKey);
    }
    if (message.ownerCommitment.length !== 0) {
      obj.ownerCommitment = base64FromBytes(message.ownerCommitment);
    }
    if (message.minedInBlock.length !== 0) {
      obj.minedInBlock = base64FromBytes(message.minedInBlock);
    }
    if (!message.minedHeight.equals(Long.UZERO)) {
      obj.minedHeight = (message.minedHeight || Long.UZERO).toString();
    }
    if (message.features !== undefined) {
      obj.features = OutputFeatures.toJSON(message.features);
    }
    if (message.script.length !== 0) {
      obj.script = base64FromBytes(message.script);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokensResponse>, I>>(base?: I): GetTokensResponse {
    return GetTokensResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokensResponse>, I>>(object: I): GetTokensResponse {
    const message = createBaseGetTokensResponse();
    message.uniqueId = object.uniqueId ?? new Uint8Array(0);
    message.assetPublicKey = object.assetPublicKey ?? new Uint8Array(0);
    message.ownerCommitment = object.ownerCommitment ?? new Uint8Array(0);
    message.minedInBlock = object.minedInBlock ?? new Uint8Array(0);
    message.minedHeight = (object.minedHeight !== undefined && object.minedHeight !== null)
      ? Long.fromValue(object.minedHeight)
      : Long.UZERO;
    message.features = (object.features !== undefined && object.features !== null)
      ? OutputFeatures.fromPartial(object.features)
      : undefined;
    message.script = object.script ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubmitBlockResponse(): SubmitBlockResponse {
  return { blockHash: new Uint8Array(0) };
}

export const SubmitBlockResponse: MessageFns<SubmitBlockResponse> = {
  encode(message: SubmitBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockHash.length !== 0) {
      writer.uint32(10).bytes(message.blockHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitBlockResponse {
    return { blockHash: isSet(object.blockHash) ? bytesFromBase64(object.blockHash) : new Uint8Array(0) };
  },

  toJSON(message: SubmitBlockResponse): unknown {
    const obj: any = {};
    if (message.blockHash.length !== 0) {
      obj.blockHash = base64FromBytes(message.blockHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitBlockResponse>, I>>(base?: I): SubmitBlockResponse {
    return SubmitBlockResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitBlockResponse>, I>>(object: I): SubmitBlockResponse {
    const message = createBaseSubmitBlockResponse();
    message.blockHash = object.blockHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBlockBlobRequest(): BlockBlobRequest {
  return { headerBlob: new Uint8Array(0), bodyBlob: new Uint8Array(0) };
}

export const BlockBlobRequest: MessageFns<BlockBlobRequest> = {
  encode(message: BlockBlobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.headerBlob.length !== 0) {
      writer.uint32(10).bytes(message.headerBlob);
    }
    if (message.bodyBlob.length !== 0) {
      writer.uint32(18).bytes(message.bodyBlob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockBlobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockBlobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.headerBlob = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bodyBlob = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockBlobRequest {
    return {
      headerBlob: isSet(object.headerBlob) ? bytesFromBase64(object.headerBlob) : new Uint8Array(0),
      bodyBlob: isSet(object.bodyBlob) ? bytesFromBase64(object.bodyBlob) : new Uint8Array(0),
    };
  },

  toJSON(message: BlockBlobRequest): unknown {
    const obj: any = {};
    if (message.headerBlob.length !== 0) {
      obj.headerBlob = base64FromBytes(message.headerBlob);
    }
    if (message.bodyBlob.length !== 0) {
      obj.bodyBlob = base64FromBytes(message.bodyBlob);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockBlobRequest>, I>>(base?: I): BlockBlobRequest {
    return BlockBlobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockBlobRequest>, I>>(object: I): BlockBlobRequest {
    const message = createBaseBlockBlobRequest();
    message.headerBlob = object.headerBlob ?? new Uint8Array(0);
    message.bodyBlob = object.bodyBlob ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTipInfoResponse(): TipInfoResponse {
  return { metadata: undefined, initialSyncAchieved: false, baseNodeState: 0, failedCheckpoints: false };
}

export const TipInfoResponse: MessageFns<TipInfoResponse> = {
  encode(message: TipInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      MetaData.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.initialSyncAchieved !== false) {
      writer.uint32(16).bool(message.initialSyncAchieved);
    }
    if (message.baseNodeState !== 0) {
      writer.uint32(24).int32(message.baseNodeState);
    }
    if (message.failedCheckpoints !== false) {
      writer.uint32(32).bool(message.failedCheckpoints);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TipInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTipInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = MetaData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.initialSyncAchieved = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.baseNodeState = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.failedCheckpoints = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TipInfoResponse {
    return {
      metadata: isSet(object.metadata) ? MetaData.fromJSON(object.metadata) : undefined,
      initialSyncAchieved: isSet(object.initialSyncAchieved) ? globalThis.Boolean(object.initialSyncAchieved) : false,
      baseNodeState: isSet(object.baseNodeState) ? baseNodeStateFromJSON(object.baseNodeState) : 0,
      failedCheckpoints: isSet(object.failedCheckpoints) ? globalThis.Boolean(object.failedCheckpoints) : false,
    };
  },

  toJSON(message: TipInfoResponse): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = MetaData.toJSON(message.metadata);
    }
    if (message.initialSyncAchieved !== false) {
      obj.initialSyncAchieved = message.initialSyncAchieved;
    }
    if (message.baseNodeState !== 0) {
      obj.baseNodeState = baseNodeStateToJSON(message.baseNodeState);
    }
    if (message.failedCheckpoints !== false) {
      obj.failedCheckpoints = message.failedCheckpoints;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TipInfoResponse>, I>>(base?: I): TipInfoResponse {
    return TipInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TipInfoResponse>, I>>(object: I): TipInfoResponse {
    const message = createBaseTipInfoResponse();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? MetaData.fromPartial(object.metadata)
      : undefined;
    message.initialSyncAchieved = object.initialSyncAchieved ?? false;
    message.baseNodeState = object.baseNodeState ?? 0;
    message.failedCheckpoints = object.failedCheckpoints ?? false;
    return message;
  },
};

function createBaseReadinessStatus(): ReadinessStatus {
  return { state: undefined, migration: undefined, timestamp: Long.UZERO };
}

export const ReadinessStatus: MessageFns<ReadinessStatus> = {
  encode(message: ReadinessStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== undefined) {
      writer.uint32(8).int32(message.state);
    }
    if (message.migration !== undefined) {
      MigrationProgress.encode(message.migration, writer.uint32(18).fork()).join();
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.timestamp.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadinessStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadinessStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.migration = MigrationProgress.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.timestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadinessStatus {
    return {
      state: isSet(object.state) ? readinessStatus_StateFromJSON(object.state) : undefined,
      migration: isSet(object.migration) ? MigrationProgress.fromJSON(object.migration) : undefined,
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.UZERO,
    };
  },

  toJSON(message: ReadinessStatus): unknown {
    const obj: any = {};
    if (message.state !== undefined) {
      obj.state = readinessStatus_StateToJSON(message.state);
    }
    if (message.migration !== undefined) {
      obj.migration = MigrationProgress.toJSON(message.migration);
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      obj.timestamp = (message.timestamp || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadinessStatus>, I>>(base?: I): ReadinessStatus {
    return ReadinessStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadinessStatus>, I>>(object: I): ReadinessStatus {
    const message = createBaseReadinessStatus();
    message.state = object.state ?? undefined;
    message.migration = (object.migration !== undefined && object.migration !== null)
      ? MigrationProgress.fromPartial(object.migration)
      : undefined;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.UZERO;
    return message;
  },
};

function createBaseMigrationProgress(): MigrationProgress {
  return {
    currentBlock: Long.UZERO,
    totalBlocks: Long.UZERO,
    progressPercentage: 0,
    currentDbVersion: Long.UZERO,
    targetDbVersion: Long.UZERO,
  };
}

export const MigrationProgress: MessageFns<MigrationProgress> = {
  encode(message: MigrationProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.currentBlock.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.currentBlock.toString());
    }
    if (!message.totalBlocks.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.totalBlocks.toString());
    }
    if (message.progressPercentage !== 0) {
      writer.uint32(25).double(message.progressPercentage);
    }
    if (!message.currentDbVersion.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.currentDbVersion.toString());
    }
    if (!message.targetDbVersion.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.targetDbVersion.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.currentBlock = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalBlocks = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.progressPercentage = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.currentDbVersion = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.targetDbVersion = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationProgress {
    return {
      currentBlock: isSet(object.currentBlock) ? Long.fromValue(object.currentBlock) : Long.UZERO,
      totalBlocks: isSet(object.totalBlocks) ? Long.fromValue(object.totalBlocks) : Long.UZERO,
      progressPercentage: isSet(object.progressPercentage) ? globalThis.Number(object.progressPercentage) : 0,
      currentDbVersion: isSet(object.currentDbVersion) ? Long.fromValue(object.currentDbVersion) : Long.UZERO,
      targetDbVersion: isSet(object.targetDbVersion) ? Long.fromValue(object.targetDbVersion) : Long.UZERO,
    };
  },

  toJSON(message: MigrationProgress): unknown {
    const obj: any = {};
    if (!message.currentBlock.equals(Long.UZERO)) {
      obj.currentBlock = (message.currentBlock || Long.UZERO).toString();
    }
    if (!message.totalBlocks.equals(Long.UZERO)) {
      obj.totalBlocks = (message.totalBlocks || Long.UZERO).toString();
    }
    if (message.progressPercentage !== 0) {
      obj.progressPercentage = message.progressPercentage;
    }
    if (!message.currentDbVersion.equals(Long.UZERO)) {
      obj.currentDbVersion = (message.currentDbVersion || Long.UZERO).toString();
    }
    if (!message.targetDbVersion.equals(Long.UZERO)) {
      obj.targetDbVersion = (message.targetDbVersion || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MigrationProgress>, I>>(base?: I): MigrationProgress {
    return MigrationProgress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MigrationProgress>, I>>(object: I): MigrationProgress {
    const message = createBaseMigrationProgress();
    message.currentBlock = (object.currentBlock !== undefined && object.currentBlock !== null)
      ? Long.fromValue(object.currentBlock)
      : Long.UZERO;
    message.totalBlocks = (object.totalBlocks !== undefined && object.totalBlocks !== null)
      ? Long.fromValue(object.totalBlocks)
      : Long.UZERO;
    message.progressPercentage = object.progressPercentage ?? 0;
    message.currentDbVersion = (object.currentDbVersion !== undefined && object.currentDbVersion !== null)
      ? Long.fromValue(object.currentDbVersion)
      : Long.UZERO;
    message.targetDbVersion = (object.targetDbVersion !== undefined && object.targetDbVersion !== null)
      ? Long.fromValue(object.targetDbVersion)
      : Long.UZERO;
    return message;
  },
};

function createBaseNewBlockTemplateResponse(): NewBlockTemplateResponse {
  return { newBlockTemplate: undefined, initialSyncAchieved: false, minerData: undefined };
}

export const NewBlockTemplateResponse: MessageFns<NewBlockTemplateResponse> = {
  encode(message: NewBlockTemplateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newBlockTemplate !== undefined) {
      NewBlockTemplate.encode(message.newBlockTemplate, writer.uint32(10).fork()).join();
    }
    if (message.initialSyncAchieved !== false) {
      writer.uint32(24).bool(message.initialSyncAchieved);
    }
    if (message.minerData !== undefined) {
      MinerData.encode(message.minerData, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewBlockTemplateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewBlockTemplateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newBlockTemplate = NewBlockTemplate.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.initialSyncAchieved = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.minerData = MinerData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewBlockTemplateResponse {
    return {
      newBlockTemplate: isSet(object.newBlockTemplate) ? NewBlockTemplate.fromJSON(object.newBlockTemplate) : undefined,
      initialSyncAchieved: isSet(object.initialSyncAchieved) ? globalThis.Boolean(object.initialSyncAchieved) : false,
      minerData: isSet(object.minerData) ? MinerData.fromJSON(object.minerData) : undefined,
    };
  },

  toJSON(message: NewBlockTemplateResponse): unknown {
    const obj: any = {};
    if (message.newBlockTemplate !== undefined) {
      obj.newBlockTemplate = NewBlockTemplate.toJSON(message.newBlockTemplate);
    }
    if (message.initialSyncAchieved !== false) {
      obj.initialSyncAchieved = message.initialSyncAchieved;
    }
    if (message.minerData !== undefined) {
      obj.minerData = MinerData.toJSON(message.minerData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewBlockTemplateResponse>, I>>(base?: I): NewBlockTemplateResponse {
    return NewBlockTemplateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewBlockTemplateResponse>, I>>(object: I): NewBlockTemplateResponse {
    const message = createBaseNewBlockTemplateResponse();
    message.newBlockTemplate = (object.newBlockTemplate !== undefined && object.newBlockTemplate !== null)
      ? NewBlockTemplate.fromPartial(object.newBlockTemplate)
      : undefined;
    message.initialSyncAchieved = object.initialSyncAchieved ?? false;
    message.minerData = (object.minerData !== undefined && object.minerData !== null)
      ? MinerData.fromPartial(object.minerData)
      : undefined;
    return message;
  },
};

function createBaseNewBlockTemplateRequest(): NewBlockTemplateRequest {
  return { algo: undefined, maxWeight: Long.UZERO };
}

export const NewBlockTemplateRequest: MessageFns<NewBlockTemplateRequest> = {
  encode(message: NewBlockTemplateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algo !== undefined) {
      PowAlgo.encode(message.algo, writer.uint32(10).fork()).join();
    }
    if (!message.maxWeight.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.maxWeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewBlockTemplateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewBlockTemplateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.algo = PowAlgo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxWeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewBlockTemplateRequest {
    return {
      algo: isSet(object.algo) ? PowAlgo.fromJSON(object.algo) : undefined,
      maxWeight: isSet(object.maxWeight) ? Long.fromValue(object.maxWeight) : Long.UZERO,
    };
  },

  toJSON(message: NewBlockTemplateRequest): unknown {
    const obj: any = {};
    if (message.algo !== undefined) {
      obj.algo = PowAlgo.toJSON(message.algo);
    }
    if (!message.maxWeight.equals(Long.UZERO)) {
      obj.maxWeight = (message.maxWeight || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewBlockTemplateRequest>, I>>(base?: I): NewBlockTemplateRequest {
    return NewBlockTemplateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewBlockTemplateRequest>, I>>(object: I): NewBlockTemplateRequest {
    const message = createBaseNewBlockTemplateRequest();
    message.algo = (object.algo !== undefined && object.algo !== null) ? PowAlgo.fromPartial(object.algo) : undefined;
    message.maxWeight = (object.maxWeight !== undefined && object.maxWeight !== null)
      ? Long.fromValue(object.maxWeight)
      : Long.UZERO;
    return message;
  },
};

function createBaseGetNewBlockTemplateWithCoinbasesRequest(): GetNewBlockTemplateWithCoinbasesRequest {
  return { algo: undefined, maxWeight: Long.UZERO, coinbases: [] };
}

export const GetNewBlockTemplateWithCoinbasesRequest: MessageFns<GetNewBlockTemplateWithCoinbasesRequest> = {
  encode(message: GetNewBlockTemplateWithCoinbasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algo !== undefined) {
      PowAlgo.encode(message.algo, writer.uint32(10).fork()).join();
    }
    if (!message.maxWeight.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.maxWeight.toString());
    }
    for (const v of message.coinbases) {
      NewBlockCoinbase.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNewBlockTemplateWithCoinbasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNewBlockTemplateWithCoinbasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.algo = PowAlgo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxWeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.coinbases.push(NewBlockCoinbase.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNewBlockTemplateWithCoinbasesRequest {
    return {
      algo: isSet(object.algo) ? PowAlgo.fromJSON(object.algo) : undefined,
      maxWeight: isSet(object.maxWeight) ? Long.fromValue(object.maxWeight) : Long.UZERO,
      coinbases: globalThis.Array.isArray(object?.coinbases)
        ? object.coinbases.map((e: any) => NewBlockCoinbase.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetNewBlockTemplateWithCoinbasesRequest): unknown {
    const obj: any = {};
    if (message.algo !== undefined) {
      obj.algo = PowAlgo.toJSON(message.algo);
    }
    if (!message.maxWeight.equals(Long.UZERO)) {
      obj.maxWeight = (message.maxWeight || Long.UZERO).toString();
    }
    if (message.coinbases?.length) {
      obj.coinbases = message.coinbases.map((e) => NewBlockCoinbase.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNewBlockTemplateWithCoinbasesRequest>, I>>(
    base?: I,
  ): GetNewBlockTemplateWithCoinbasesRequest {
    return GetNewBlockTemplateWithCoinbasesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNewBlockTemplateWithCoinbasesRequest>, I>>(
    object: I,
  ): GetNewBlockTemplateWithCoinbasesRequest {
    const message = createBaseGetNewBlockTemplateWithCoinbasesRequest();
    message.algo = (object.algo !== undefined && object.algo !== null) ? PowAlgo.fromPartial(object.algo) : undefined;
    message.maxWeight = (object.maxWeight !== undefined && object.maxWeight !== null)
      ? Long.fromValue(object.maxWeight)
      : Long.UZERO;
    message.coinbases = object.coinbases?.map((e) => NewBlockCoinbase.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetNewBlockWithCoinbasesRequest(): GetNewBlockWithCoinbasesRequest {
  return { newTemplate: undefined, coinbases: [] };
}

export const GetNewBlockWithCoinbasesRequest: MessageFns<GetNewBlockWithCoinbasesRequest> = {
  encode(message: GetNewBlockWithCoinbasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newTemplate !== undefined) {
      NewBlockTemplate.encode(message.newTemplate, writer.uint32(10).fork()).join();
    }
    for (const v of message.coinbases) {
      NewBlockCoinbase.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNewBlockWithCoinbasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNewBlockWithCoinbasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newTemplate = NewBlockTemplate.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.coinbases.push(NewBlockCoinbase.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNewBlockWithCoinbasesRequest {
    return {
      newTemplate: isSet(object.newTemplate) ? NewBlockTemplate.fromJSON(object.newTemplate) : undefined,
      coinbases: globalThis.Array.isArray(object?.coinbases)
        ? object.coinbases.map((e: any) => NewBlockCoinbase.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetNewBlockWithCoinbasesRequest): unknown {
    const obj: any = {};
    if (message.newTemplate !== undefined) {
      obj.newTemplate = NewBlockTemplate.toJSON(message.newTemplate);
    }
    if (message.coinbases?.length) {
      obj.coinbases = message.coinbases.map((e) => NewBlockCoinbase.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNewBlockWithCoinbasesRequest>, I>>(base?: I): GetNewBlockWithCoinbasesRequest {
    return GetNewBlockWithCoinbasesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNewBlockWithCoinbasesRequest>, I>>(
    object: I,
  ): GetNewBlockWithCoinbasesRequest {
    const message = createBaseGetNewBlockWithCoinbasesRequest();
    message.newTemplate = (object.newTemplate !== undefined && object.newTemplate !== null)
      ? NewBlockTemplate.fromPartial(object.newTemplate)
      : undefined;
    message.coinbases = object.coinbases?.map((e) => NewBlockCoinbase.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNewBlockCoinbase(): NewBlockCoinbase {
  return {
    address: "",
    value: Long.UZERO,
    stealthPayment: false,
    revealedValueProof: false,
    coinbaseExtra: new Uint8Array(0),
  };
}

export const NewBlockCoinbase: MessageFns<NewBlockCoinbase> = {
  encode(message: NewBlockCoinbase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (!message.value.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.value.toString());
    }
    if (message.stealthPayment !== false) {
      writer.uint32(24).bool(message.stealthPayment);
    }
    if (message.revealedValueProof !== false) {
      writer.uint32(32).bool(message.revealedValueProof);
    }
    if (message.coinbaseExtra.length !== 0) {
      writer.uint32(42).bytes(message.coinbaseExtra);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewBlockCoinbase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewBlockCoinbase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.stealthPayment = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.revealedValueProof = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.coinbaseExtra = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewBlockCoinbase {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.UZERO,
      stealthPayment: isSet(object.stealthPayment) ? globalThis.Boolean(object.stealthPayment) : false,
      revealedValueProof: isSet(object.revealedValueProof) ? globalThis.Boolean(object.revealedValueProof) : false,
      coinbaseExtra: isSet(object.coinbaseExtra) ? bytesFromBase64(object.coinbaseExtra) : new Uint8Array(0),
    };
  },

  toJSON(message: NewBlockCoinbase): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (!message.value.equals(Long.UZERO)) {
      obj.value = (message.value || Long.UZERO).toString();
    }
    if (message.stealthPayment !== false) {
      obj.stealthPayment = message.stealthPayment;
    }
    if (message.revealedValueProof !== false) {
      obj.revealedValueProof = message.revealedValueProof;
    }
    if (message.coinbaseExtra.length !== 0) {
      obj.coinbaseExtra = base64FromBytes(message.coinbaseExtra);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewBlockCoinbase>, I>>(base?: I): NewBlockCoinbase {
    return NewBlockCoinbase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewBlockCoinbase>, I>>(object: I): NewBlockCoinbase {
    const message = createBaseNewBlockCoinbase();
    message.address = object.address ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.UZERO;
    message.stealthPayment = object.stealthPayment ?? false;
    message.revealedValueProof = object.revealedValueProof ?? false;
    message.coinbaseExtra = object.coinbaseExtra ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNetworkDifficultyResponse(): NetworkDifficultyResponse {
  return {
    difficulty: Long.UZERO,
    estimatedHashRate: Long.UZERO,
    height: Long.UZERO,
    timestamp: Long.UZERO,
    powAlgo: Long.UZERO,
    sha3xEstimatedHashRate: Long.UZERO,
    moneroRandomxEstimatedHashRate: Long.UZERO,
    tariRandomxEstimatedHashRate: Long.UZERO,
    numCoinbases: Long.UZERO,
    coinbaseExtras: [],
  };
}

export const NetworkDifficultyResponse: MessageFns<NetworkDifficultyResponse> = {
  encode(message: NetworkDifficultyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.difficulty.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.difficulty.toString());
    }
    if (!message.estimatedHashRate.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.estimatedHashRate.toString());
    }
    if (!message.height.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.height.toString());
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.timestamp.toString());
    }
    if (!message.powAlgo.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.powAlgo.toString());
    }
    if (!message.sha3xEstimatedHashRate.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.sha3xEstimatedHashRate.toString());
    }
    if (!message.moneroRandomxEstimatedHashRate.equals(Long.UZERO)) {
      writer.uint32(56).uint64(message.moneroRandomxEstimatedHashRate.toString());
    }
    if (!message.tariRandomxEstimatedHashRate.equals(Long.UZERO)) {
      writer.uint32(80).uint64(message.tariRandomxEstimatedHashRate.toString());
    }
    if (!message.numCoinbases.equals(Long.UZERO)) {
      writer.uint32(64).uint64(message.numCoinbases.toString());
    }
    for (const v of message.coinbaseExtras) {
      writer.uint32(74).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkDifficultyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkDifficultyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.difficulty = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.estimatedHashRate = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.powAlgo = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sha3xEstimatedHashRate = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.moneroRandomxEstimatedHashRate = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.tariRandomxEstimatedHashRate = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.numCoinbases = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.coinbaseExtras.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkDifficultyResponse {
    return {
      difficulty: isSet(object.difficulty) ? Long.fromValue(object.difficulty) : Long.UZERO,
      estimatedHashRate: isSet(object.estimatedHashRate) ? Long.fromValue(object.estimatedHashRate) : Long.UZERO,
      height: isSet(object.height) ? Long.fromValue(object.height) : Long.UZERO,
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.UZERO,
      powAlgo: isSet(object.powAlgo) ? Long.fromValue(object.powAlgo) : Long.UZERO,
      sha3xEstimatedHashRate: isSet(object.sha3xEstimatedHashRate)
        ? Long.fromValue(object.sha3xEstimatedHashRate)
        : Long.UZERO,
      moneroRandomxEstimatedHashRate: isSet(object.moneroRandomxEstimatedHashRate)
        ? Long.fromValue(object.moneroRandomxEstimatedHashRate)
        : Long.UZERO,
      tariRandomxEstimatedHashRate: isSet(object.tariRandomxEstimatedHashRate)
        ? Long.fromValue(object.tariRandomxEstimatedHashRate)
        : Long.UZERO,
      numCoinbases: isSet(object.numCoinbases) ? Long.fromValue(object.numCoinbases) : Long.UZERO,
      coinbaseExtras: globalThis.Array.isArray(object?.coinbaseExtras)
        ? object.coinbaseExtras.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: NetworkDifficultyResponse): unknown {
    const obj: any = {};
    if (!message.difficulty.equals(Long.UZERO)) {
      obj.difficulty = (message.difficulty || Long.UZERO).toString();
    }
    if (!message.estimatedHashRate.equals(Long.UZERO)) {
      obj.estimatedHashRate = (message.estimatedHashRate || Long.UZERO).toString();
    }
    if (!message.height.equals(Long.UZERO)) {
      obj.height = (message.height || Long.UZERO).toString();
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      obj.timestamp = (message.timestamp || Long.UZERO).toString();
    }
    if (!message.powAlgo.equals(Long.UZERO)) {
      obj.powAlgo = (message.powAlgo || Long.UZERO).toString();
    }
    if (!message.sha3xEstimatedHashRate.equals(Long.UZERO)) {
      obj.sha3xEstimatedHashRate = (message.sha3xEstimatedHashRate || Long.UZERO).toString();
    }
    if (!message.moneroRandomxEstimatedHashRate.equals(Long.UZERO)) {
      obj.moneroRandomxEstimatedHashRate = (message.moneroRandomxEstimatedHashRate || Long.UZERO).toString();
    }
    if (!message.tariRandomxEstimatedHashRate.equals(Long.UZERO)) {
      obj.tariRandomxEstimatedHashRate = (message.tariRandomxEstimatedHashRate || Long.UZERO).toString();
    }
    if (!message.numCoinbases.equals(Long.UZERO)) {
      obj.numCoinbases = (message.numCoinbases || Long.UZERO).toString();
    }
    if (message.coinbaseExtras?.length) {
      obj.coinbaseExtras = message.coinbaseExtras.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NetworkDifficultyResponse>, I>>(base?: I): NetworkDifficultyResponse {
    return NetworkDifficultyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NetworkDifficultyResponse>, I>>(object: I): NetworkDifficultyResponse {
    const message = createBaseNetworkDifficultyResponse();
    message.difficulty = (object.difficulty !== undefined && object.difficulty !== null)
      ? Long.fromValue(object.difficulty)
      : Long.UZERO;
    message.estimatedHashRate = (object.estimatedHashRate !== undefined && object.estimatedHashRate !== null)
      ? Long.fromValue(object.estimatedHashRate)
      : Long.UZERO;
    message.height = (object.height !== undefined && object.height !== null)
      ? Long.fromValue(object.height)
      : Long.UZERO;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.UZERO;
    message.powAlgo = (object.powAlgo !== undefined && object.powAlgo !== null)
      ? Long.fromValue(object.powAlgo)
      : Long.UZERO;
    message.sha3xEstimatedHashRate =
      (object.sha3xEstimatedHashRate !== undefined && object.sha3xEstimatedHashRate !== null)
        ? Long.fromValue(object.sha3xEstimatedHashRate)
        : Long.UZERO;
    message.moneroRandomxEstimatedHashRate =
      (object.moneroRandomxEstimatedHashRate !== undefined && object.moneroRandomxEstimatedHashRate !== null)
        ? Long.fromValue(object.moneroRandomxEstimatedHashRate)
        : Long.UZERO;
    message.tariRandomxEstimatedHashRate =
      (object.tariRandomxEstimatedHashRate !== undefined && object.tariRandomxEstimatedHashRate !== null)
        ? Long.fromValue(object.tariRandomxEstimatedHashRate)
        : Long.UZERO;
    message.numCoinbases = (object.numCoinbases !== undefined && object.numCoinbases !== null)
      ? Long.fromValue(object.numCoinbases)
      : Long.UZERO;
    message.coinbaseExtras = object.coinbaseExtras?.map((e) => e) || [];
    return message;
  },
};

function createBaseValueAtHeightResponse(): ValueAtHeightResponse {
  return {
    circulatingSupply: Long.UZERO,
    height: Long.UZERO,
    minedRewards: Long.UZERO,
    spendableRewards: Long.UZERO,
    spendablePreMine: Long.UZERO,
    totalSpendable: Long.UZERO,
    totalPreMine: Long.UZERO,
    timeLockedPreMine: Long.UZERO,
  };
}

export const ValueAtHeightResponse: MessageFns<ValueAtHeightResponse> = {
  encode(message: ValueAtHeightResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.circulatingSupply.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.circulatingSupply.toString());
    }
    if (!message.height.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.height.toString());
    }
    if (!message.minedRewards.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.minedRewards.toString());
    }
    if (!message.spendableRewards.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.spendableRewards.toString());
    }
    if (!message.spendablePreMine.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.spendablePreMine.toString());
    }
    if (!message.totalSpendable.equals(Long.UZERO)) {
      writer.uint32(56).uint64(message.totalSpendable.toString());
    }
    if (!message.totalPreMine.equals(Long.UZERO)) {
      writer.uint32(64).uint64(message.totalPreMine.toString());
    }
    if (!message.timeLockedPreMine.equals(Long.UZERO)) {
      writer.uint32(72).uint64(message.timeLockedPreMine.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValueAtHeightResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValueAtHeightResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.circulatingSupply = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.minedRewards = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.spendableRewards = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.spendablePreMine = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalSpendable = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.totalPreMine = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.timeLockedPreMine = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValueAtHeightResponse {
    return {
      circulatingSupply: isSet(object.circulatingSupply) ? Long.fromValue(object.circulatingSupply) : Long.UZERO,
      height: isSet(object.height) ? Long.fromValue(object.height) : Long.UZERO,
      minedRewards: isSet(object.minedRewards) ? Long.fromValue(object.minedRewards) : Long.UZERO,
      spendableRewards: isSet(object.spendableRewards) ? Long.fromValue(object.spendableRewards) : Long.UZERO,
      spendablePreMine: isSet(object.spendablePreMine) ? Long.fromValue(object.spendablePreMine) : Long.UZERO,
      totalSpendable: isSet(object.totalSpendable) ? Long.fromValue(object.totalSpendable) : Long.UZERO,
      totalPreMine: isSet(object.totalPreMine) ? Long.fromValue(object.totalPreMine) : Long.UZERO,
      timeLockedPreMine: isSet(object.timeLockedPreMine) ? Long.fromValue(object.timeLockedPreMine) : Long.UZERO,
    };
  },

  toJSON(message: ValueAtHeightResponse): unknown {
    const obj: any = {};
    if (!message.circulatingSupply.equals(Long.UZERO)) {
      obj.circulatingSupply = (message.circulatingSupply || Long.UZERO).toString();
    }
    if (!message.height.equals(Long.UZERO)) {
      obj.height = (message.height || Long.UZERO).toString();
    }
    if (!message.minedRewards.equals(Long.UZERO)) {
      obj.minedRewards = (message.minedRewards || Long.UZERO).toString();
    }
    if (!message.spendableRewards.equals(Long.UZERO)) {
      obj.spendableRewards = (message.spendableRewards || Long.UZERO).toString();
    }
    if (!message.spendablePreMine.equals(Long.UZERO)) {
      obj.spendablePreMine = (message.spendablePreMine || Long.UZERO).toString();
    }
    if (!message.totalSpendable.equals(Long.UZERO)) {
      obj.totalSpendable = (message.totalSpendable || Long.UZERO).toString();
    }
    if (!message.totalPreMine.equals(Long.UZERO)) {
      obj.totalPreMine = (message.totalPreMine || Long.UZERO).toString();
    }
    if (!message.timeLockedPreMine.equals(Long.UZERO)) {
      obj.timeLockedPreMine = (message.timeLockedPreMine || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValueAtHeightResponse>, I>>(base?: I): ValueAtHeightResponse {
    return ValueAtHeightResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValueAtHeightResponse>, I>>(object: I): ValueAtHeightResponse {
    const message = createBaseValueAtHeightResponse();
    message.circulatingSupply = (object.circulatingSupply !== undefined && object.circulatingSupply !== null)
      ? Long.fromValue(object.circulatingSupply)
      : Long.UZERO;
    message.height = (object.height !== undefined && object.height !== null)
      ? Long.fromValue(object.height)
      : Long.UZERO;
    message.minedRewards = (object.minedRewards !== undefined && object.minedRewards !== null)
      ? Long.fromValue(object.minedRewards)
      : Long.UZERO;
    message.spendableRewards = (object.spendableRewards !== undefined && object.spendableRewards !== null)
      ? Long.fromValue(object.spendableRewards)
      : Long.UZERO;
    message.spendablePreMine = (object.spendablePreMine !== undefined && object.spendablePreMine !== null)
      ? Long.fromValue(object.spendablePreMine)
      : Long.UZERO;
    message.totalSpendable = (object.totalSpendable !== undefined && object.totalSpendable !== null)
      ? Long.fromValue(object.totalSpendable)
      : Long.UZERO;
    message.totalPreMine = (object.totalPreMine !== undefined && object.totalPreMine !== null)
      ? Long.fromValue(object.totalPreMine)
      : Long.UZERO;
    message.timeLockedPreMine = (object.timeLockedPreMine !== undefined && object.timeLockedPreMine !== null)
      ? Long.fromValue(object.timeLockedPreMine)
      : Long.UZERO;
    return message;
  },
};

function createBaseIntegerValue(): IntegerValue {
  return { value: Long.UZERO };
}

export const IntegerValue: MessageFns<IntegerValue> = {
  encode(message: IntegerValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.value.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.value.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntegerValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntegerValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntegerValue {
    return { value: isSet(object.value) ? Long.fromValue(object.value) : Long.UZERO };
  },

  toJSON(message: IntegerValue): unknown {
    const obj: any = {};
    if (!message.value.equals(Long.UZERO)) {
      obj.value = (message.value || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntegerValue>, I>>(base?: I): IntegerValue {
    return IntegerValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntegerValue>, I>>(object: I): IntegerValue {
    const message = createBaseIntegerValue();
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.UZERO;
    return message;
  },
};

function createBaseBaseNodeGetVersionResponse(): BaseNodeGetVersionResponse {
  return { version: "", network: 0 };
}

export const BaseNodeGetVersionResponse: MessageFns<BaseNodeGetVersionResponse> = {
  encode(message: BaseNodeGetVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.network !== 0) {
      writer.uint32(16).uint32(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BaseNodeGetVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaseNodeGetVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.network = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaseNodeGetVersionResponse {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      network: isSet(object.network) ? globalThis.Number(object.network) : 0,
    };
  },

  toJSON(message: BaseNodeGetVersionResponse): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.network !== 0) {
      obj.network = Math.round(message.network);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaseNodeGetVersionResponse>, I>>(base?: I): BaseNodeGetVersionResponse {
    return BaseNodeGetVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaseNodeGetVersionResponse>, I>>(object: I): BaseNodeGetVersionResponse {
    const message = createBaseBaseNodeGetVersionResponse();
    message.version = object.version ?? "";
    message.network = object.network ?? 0;
    return message;
  },
};

function createBaseBlockGroupRequest(): BlockGroupRequest {
  return { fromTip: Long.UZERO, startHeight: Long.UZERO, endHeight: Long.UZERO, calcType: 0 };
}

export const BlockGroupRequest: MessageFns<BlockGroupRequest> = {
  encode(message: BlockGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.fromTip.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.fromTip.toString());
    }
    if (!message.startHeight.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.startHeight.toString());
    }
    if (!message.endHeight.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.endHeight.toString());
    }
    if (message.calcType !== 0) {
      writer.uint32(32).int32(message.calcType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromTip = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.endHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.calcType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockGroupRequest {
    return {
      fromTip: isSet(object.fromTip) ? Long.fromValue(object.fromTip) : Long.UZERO,
      startHeight: isSet(object.startHeight) ? Long.fromValue(object.startHeight) : Long.UZERO,
      endHeight: isSet(object.endHeight) ? Long.fromValue(object.endHeight) : Long.UZERO,
      calcType: isSet(object.calcType) ? calcTypeFromJSON(object.calcType) : 0,
    };
  },

  toJSON(message: BlockGroupRequest): unknown {
    const obj: any = {};
    if (!message.fromTip.equals(Long.UZERO)) {
      obj.fromTip = (message.fromTip || Long.UZERO).toString();
    }
    if (!message.startHeight.equals(Long.UZERO)) {
      obj.startHeight = (message.startHeight || Long.UZERO).toString();
    }
    if (!message.endHeight.equals(Long.UZERO)) {
      obj.endHeight = (message.endHeight || Long.UZERO).toString();
    }
    if (message.calcType !== 0) {
      obj.calcType = calcTypeToJSON(message.calcType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockGroupRequest>, I>>(base?: I): BlockGroupRequest {
    return BlockGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockGroupRequest>, I>>(object: I): BlockGroupRequest {
    const message = createBaseBlockGroupRequest();
    message.fromTip = (object.fromTip !== undefined && object.fromTip !== null)
      ? Long.fromValue(object.fromTip)
      : Long.UZERO;
    message.startHeight = (object.startHeight !== undefined && object.startHeight !== null)
      ? Long.fromValue(object.startHeight)
      : Long.UZERO;
    message.endHeight = (object.endHeight !== undefined && object.endHeight !== null)
      ? Long.fromValue(object.endHeight)
      : Long.UZERO;
    message.calcType = object.calcType ?? 0;
    return message;
  },
};

function createBaseBlockGroupResponse(): BlockGroupResponse {
  return { value: [], calcType: 0 };
}

export const BlockGroupResponse: MessageFns<BlockGroupResponse> = {
  encode(message: BlockGroupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.value) {
      writer.double(v);
    }
    writer.join();
    if (message.calcType !== 0) {
      writer.uint32(16).int32(message.calcType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockGroupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 9) {
            message.value.push(reader.double());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.value.push(reader.double());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.calcType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockGroupResponse {
    return {
      value: globalThis.Array.isArray(object?.value) ? object.value.map((e: any) => globalThis.Number(e)) : [],
      calcType: isSet(object.calcType) ? calcTypeFromJSON(object.calcType) : 0,
    };
  },

  toJSON(message: BlockGroupResponse): unknown {
    const obj: any = {};
    if (message.value?.length) {
      obj.value = message.value;
    }
    if (message.calcType !== 0) {
      obj.calcType = calcTypeToJSON(message.calcType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockGroupResponse>, I>>(base?: I): BlockGroupResponse {
    return BlockGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockGroupResponse>, I>>(object: I): BlockGroupResponse {
    const message = createBaseBlockGroupResponse();
    message.value = object.value?.map((e) => e) || [];
    message.calcType = object.calcType ?? 0;
    return message;
  },
};

function createBaseHeightRequest(): HeightRequest {
  return { fromTip: Long.UZERO, startHeight: Long.UZERO, endHeight: Long.UZERO };
}

export const HeightRequest: MessageFns<HeightRequest> = {
  encode(message: HeightRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.fromTip.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.fromTip.toString());
    }
    if (!message.startHeight.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.startHeight.toString());
    }
    if (!message.endHeight.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.endHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeightRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeightRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromTip = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.endHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeightRequest {
    return {
      fromTip: isSet(object.fromTip) ? Long.fromValue(object.fromTip) : Long.UZERO,
      startHeight: isSet(object.startHeight) ? Long.fromValue(object.startHeight) : Long.UZERO,
      endHeight: isSet(object.endHeight) ? Long.fromValue(object.endHeight) : Long.UZERO,
    };
  },

  toJSON(message: HeightRequest): unknown {
    const obj: any = {};
    if (!message.fromTip.equals(Long.UZERO)) {
      obj.fromTip = (message.fromTip || Long.UZERO).toString();
    }
    if (!message.startHeight.equals(Long.UZERO)) {
      obj.startHeight = (message.startHeight || Long.UZERO).toString();
    }
    if (!message.endHeight.equals(Long.UZERO)) {
      obj.endHeight = (message.endHeight || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeightRequest>, I>>(base?: I): HeightRequest {
    return HeightRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeightRequest>, I>>(object: I): HeightRequest {
    const message = createBaseHeightRequest();
    message.fromTip = (object.fromTip !== undefined && object.fromTip !== null)
      ? Long.fromValue(object.fromTip)
      : Long.UZERO;
    message.startHeight = (object.startHeight !== undefined && object.startHeight !== null)
      ? Long.fromValue(object.startHeight)
      : Long.UZERO;
    message.endHeight = (object.endHeight !== undefined && object.endHeight !== null)
      ? Long.fromValue(object.endHeight)
      : Long.UZERO;
    return message;
  },
};

function createBaseBlockTimingResponse(): BlockTimingResponse {
  return { max: Long.UZERO, min: Long.UZERO, avg: 0 };
}

export const BlockTimingResponse: MessageFns<BlockTimingResponse> = {
  encode(message: BlockTimingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.max.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.max.toString());
    }
    if (!message.min.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.min.toString());
    }
    if (message.avg !== 0) {
      writer.uint32(25).double(message.avg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockTimingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockTimingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.max = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.min = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.avg = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockTimingResponse {
    return {
      max: isSet(object.max) ? Long.fromValue(object.max) : Long.UZERO,
      min: isSet(object.min) ? Long.fromValue(object.min) : Long.UZERO,
      avg: isSet(object.avg) ? globalThis.Number(object.avg) : 0,
    };
  },

  toJSON(message: BlockTimingResponse): unknown {
    const obj: any = {};
    if (!message.max.equals(Long.UZERO)) {
      obj.max = (message.max || Long.UZERO).toString();
    }
    if (!message.min.equals(Long.UZERO)) {
      obj.min = (message.min || Long.UZERO).toString();
    }
    if (message.avg !== 0) {
      obj.avg = message.avg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockTimingResponse>, I>>(base?: I): BlockTimingResponse {
    return BlockTimingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockTimingResponse>, I>>(object: I): BlockTimingResponse {
    const message = createBaseBlockTimingResponse();
    message.max = (object.max !== undefined && object.max !== null) ? Long.fromValue(object.max) : Long.UZERO;
    message.min = (object.min !== undefined && object.min !== null) ? Long.fromValue(object.min) : Long.UZERO;
    message.avg = object.avg ?? 0;
    return message;
  },
};

function createBaseGetHeaderByHashRequest(): GetHeaderByHashRequest {
  return { hash: new Uint8Array(0) };
}

export const GetHeaderByHashRequest: MessageFns<GetHeaderByHashRequest> = {
  encode(message: GetHeaderByHashRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHeaderByHashRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHeaderByHashRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHeaderByHashRequest {
    return { hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0) };
  },

  toJSON(message: GetHeaderByHashRequest): unknown {
    const obj: any = {};
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetHeaderByHashRequest>, I>>(base?: I): GetHeaderByHashRequest {
    return GetHeaderByHashRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetHeaderByHashRequest>, I>>(object: I): GetHeaderByHashRequest {
    const message = createBaseGetHeaderByHashRequest();
    message.hash = object.hash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBlockHeaderResponse(): BlockHeaderResponse {
  return {
    header: undefined,
    confirmations: Long.UZERO,
    reward: Long.UZERO,
    difficulty: Long.UZERO,
    numTransactions: 0,
  };
}

export const BlockHeaderResponse: MessageFns<BlockHeaderResponse> = {
  encode(message: BlockHeaderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      BlockHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (!message.confirmations.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.confirmations.toString());
    }
    if (!message.reward.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.reward.toString());
    }
    if (!message.difficulty.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.difficulty.toString());
    }
    if (message.numTransactions !== 0) {
      writer.uint32(40).uint32(message.numTransactions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeaderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeaderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = BlockHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.confirmations = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reward = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.difficulty = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.numTransactions = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeaderResponse {
    return {
      header: isSet(object.header) ? BlockHeader.fromJSON(object.header) : undefined,
      confirmations: isSet(object.confirmations) ? Long.fromValue(object.confirmations) : Long.UZERO,
      reward: isSet(object.reward) ? Long.fromValue(object.reward) : Long.UZERO,
      difficulty: isSet(object.difficulty) ? Long.fromValue(object.difficulty) : Long.UZERO,
      numTransactions: isSet(object.numTransactions) ? globalThis.Number(object.numTransactions) : 0,
    };
  },

  toJSON(message: BlockHeaderResponse): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = BlockHeader.toJSON(message.header);
    }
    if (!message.confirmations.equals(Long.UZERO)) {
      obj.confirmations = (message.confirmations || Long.UZERO).toString();
    }
    if (!message.reward.equals(Long.UZERO)) {
      obj.reward = (message.reward || Long.UZERO).toString();
    }
    if (!message.difficulty.equals(Long.UZERO)) {
      obj.difficulty = (message.difficulty || Long.UZERO).toString();
    }
    if (message.numTransactions !== 0) {
      obj.numTransactions = Math.round(message.numTransactions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockHeaderResponse>, I>>(base?: I): BlockHeaderResponse {
    return BlockHeaderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockHeaderResponse>, I>>(object: I): BlockHeaderResponse {
    const message = createBaseBlockHeaderResponse();
    message.header = (object.header !== undefined && object.header !== null)
      ? BlockHeader.fromPartial(object.header)
      : undefined;
    message.confirmations = (object.confirmations !== undefined && object.confirmations !== null)
      ? Long.fromValue(object.confirmations)
      : Long.UZERO;
    message.reward = (object.reward !== undefined && object.reward !== null)
      ? Long.fromValue(object.reward)
      : Long.UZERO;
    message.difficulty = (object.difficulty !== undefined && object.difficulty !== null)
      ? Long.fromValue(object.difficulty)
      : Long.UZERO;
    message.numTransactions = object.numTransactions ?? 0;
    return message;
  },
};

function createBaseListHeadersRequest(): ListHeadersRequest {
  return { fromHeight: Long.UZERO, numHeaders: Long.UZERO, sorting: 0 };
}

export const ListHeadersRequest: MessageFns<ListHeadersRequest> = {
  encode(message: ListHeadersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.fromHeight.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.fromHeight.toString());
    }
    if (!message.numHeaders.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.numHeaders.toString());
    }
    if (message.sorting !== 0) {
      writer.uint32(24).int32(message.sorting);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHeadersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHeadersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numHeaders = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sorting = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListHeadersRequest {
    return {
      fromHeight: isSet(object.fromHeight) ? Long.fromValue(object.fromHeight) : Long.UZERO,
      numHeaders: isSet(object.numHeaders) ? Long.fromValue(object.numHeaders) : Long.UZERO,
      sorting: isSet(object.sorting) ? sortingFromJSON(object.sorting) : 0,
    };
  },

  toJSON(message: ListHeadersRequest): unknown {
    const obj: any = {};
    if (!message.fromHeight.equals(Long.UZERO)) {
      obj.fromHeight = (message.fromHeight || Long.UZERO).toString();
    }
    if (!message.numHeaders.equals(Long.UZERO)) {
      obj.numHeaders = (message.numHeaders || Long.UZERO).toString();
    }
    if (message.sorting !== 0) {
      obj.sorting = sortingToJSON(message.sorting);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListHeadersRequest>, I>>(base?: I): ListHeadersRequest {
    return ListHeadersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListHeadersRequest>, I>>(object: I): ListHeadersRequest {
    const message = createBaseListHeadersRequest();
    message.fromHeight = (object.fromHeight !== undefined && object.fromHeight !== null)
      ? Long.fromValue(object.fromHeight)
      : Long.UZERO;
    message.numHeaders = (object.numHeaders !== undefined && object.numHeaders !== null)
      ? Long.fromValue(object.numHeaders)
      : Long.UZERO;
    message.sorting = object.sorting ?? 0;
    return message;
  },
};

function createBaseGetBlocksRequest(): GetBlocksRequest {
  return { heights: [] };
}

export const GetBlocksRequest: MessageFns<GetBlocksRequest> = {
  encode(message: GetBlocksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.heights) {
      writer.uint64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlocksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlocksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.heights.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.heights.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlocksRequest {
    return {
      heights: globalThis.Array.isArray(object?.heights) ? object.heights.map((e: any) => Long.fromValue(e)) : [],
    };
  },

  toJSON(message: GetBlocksRequest): unknown {
    const obj: any = {};
    if (message.heights?.length) {
      obj.heights = message.heights.map((e) => (e || Long.UZERO).toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBlocksRequest>, I>>(base?: I): GetBlocksRequest {
    return GetBlocksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBlocksRequest>, I>>(object: I): GetBlocksRequest {
    const message = createBaseGetBlocksRequest();
    message.heights = object.heights?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseGetBlocksResponse(): GetBlocksResponse {
  return { blocks: [] };
}

export const GetBlocksResponse: MessageFns<GetBlocksResponse> = {
  encode(message: GetBlocksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.blocks) {
      HistoricalBlock.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlocksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlocksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blocks.push(HistoricalBlock.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlocksResponse {
    return {
      blocks: globalThis.Array.isArray(object?.blocks)
        ? object.blocks.map((e: any) => HistoricalBlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetBlocksResponse): unknown {
    const obj: any = {};
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => HistoricalBlock.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBlocksResponse>, I>>(base?: I): GetBlocksResponse {
    return GetBlocksResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBlocksResponse>, I>>(object: I): GetBlocksResponse {
    const message = createBaseGetBlocksResponse();
    message.blocks = object.blocks?.map((e) => HistoricalBlock.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMetaData(): MetaData {
  return {
    bestBlockHeight: Long.UZERO,
    bestBlockHash: new Uint8Array(0),
    accumulatedDifficulty: new Uint8Array(0),
    prunedHeight: Long.UZERO,
    timestamp: Long.UZERO,
  };
}

export const MetaData: MessageFns<MetaData> = {
  encode(message: MetaData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.bestBlockHeight.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.bestBlockHeight.toString());
    }
    if (message.bestBlockHash.length !== 0) {
      writer.uint32(18).bytes(message.bestBlockHash);
    }
    if (message.accumulatedDifficulty.length !== 0) {
      writer.uint32(42).bytes(message.accumulatedDifficulty);
    }
    if (!message.prunedHeight.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.prunedHeight.toString());
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      writer.uint32(56).uint64(message.timestamp.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetaData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetaData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bestBlockHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bestBlockHash = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.accumulatedDifficulty = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.prunedHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.timestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetaData {
    return {
      bestBlockHeight: isSet(object.bestBlockHeight) ? Long.fromValue(object.bestBlockHeight) : Long.UZERO,
      bestBlockHash: isSet(object.bestBlockHash) ? bytesFromBase64(object.bestBlockHash) : new Uint8Array(0),
      accumulatedDifficulty: isSet(object.accumulatedDifficulty)
        ? bytesFromBase64(object.accumulatedDifficulty)
        : new Uint8Array(0),
      prunedHeight: isSet(object.prunedHeight) ? Long.fromValue(object.prunedHeight) : Long.UZERO,
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.UZERO,
    };
  },

  toJSON(message: MetaData): unknown {
    const obj: any = {};
    if (!message.bestBlockHeight.equals(Long.UZERO)) {
      obj.bestBlockHeight = (message.bestBlockHeight || Long.UZERO).toString();
    }
    if (message.bestBlockHash.length !== 0) {
      obj.bestBlockHash = base64FromBytes(message.bestBlockHash);
    }
    if (message.accumulatedDifficulty.length !== 0) {
      obj.accumulatedDifficulty = base64FromBytes(message.accumulatedDifficulty);
    }
    if (!message.prunedHeight.equals(Long.UZERO)) {
      obj.prunedHeight = (message.prunedHeight || Long.UZERO).toString();
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      obj.timestamp = (message.timestamp || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetaData>, I>>(base?: I): MetaData {
    return MetaData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetaData>, I>>(object: I): MetaData {
    const message = createBaseMetaData();
    message.bestBlockHeight = (object.bestBlockHeight !== undefined && object.bestBlockHeight !== null)
      ? Long.fromValue(object.bestBlockHeight)
      : Long.UZERO;
    message.bestBlockHash = object.bestBlockHash ?? new Uint8Array(0);
    message.accumulatedDifficulty = object.accumulatedDifficulty ?? new Uint8Array(0);
    message.prunedHeight = (object.prunedHeight !== undefined && object.prunedHeight !== null)
      ? Long.fromValue(object.prunedHeight)
      : Long.UZERO;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.UZERO;
    return message;
  },
};

function createBaseSyncInfoResponse(): SyncInfoResponse {
  return { tipHeight: Long.UZERO, localHeight: Long.UZERO, peerNodeId: [] };
}

export const SyncInfoResponse: MessageFns<SyncInfoResponse> = {
  encode(message: SyncInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.tipHeight.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.tipHeight.toString());
    }
    if (!message.localHeight.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.localHeight.toString());
    }
    for (const v of message.peerNodeId) {
      writer.uint32(26).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tipHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.localHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.peerNodeId.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncInfoResponse {
    return {
      tipHeight: isSet(object.tipHeight) ? Long.fromValue(object.tipHeight) : Long.UZERO,
      localHeight: isSet(object.localHeight) ? Long.fromValue(object.localHeight) : Long.UZERO,
      peerNodeId: globalThis.Array.isArray(object?.peerNodeId)
        ? object.peerNodeId.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: SyncInfoResponse): unknown {
    const obj: any = {};
    if (!message.tipHeight.equals(Long.UZERO)) {
      obj.tipHeight = (message.tipHeight || Long.UZERO).toString();
    }
    if (!message.localHeight.equals(Long.UZERO)) {
      obj.localHeight = (message.localHeight || Long.UZERO).toString();
    }
    if (message.peerNodeId?.length) {
      obj.peerNodeId = message.peerNodeId.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncInfoResponse>, I>>(base?: I): SyncInfoResponse {
    return SyncInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncInfoResponse>, I>>(object: I): SyncInfoResponse {
    const message = createBaseSyncInfoResponse();
    message.tipHeight = (object.tipHeight !== undefined && object.tipHeight !== null)
      ? Long.fromValue(object.tipHeight)
      : Long.UZERO;
    message.localHeight = (object.localHeight !== undefined && object.localHeight !== null)
      ? Long.fromValue(object.localHeight)
      : Long.UZERO;
    message.peerNodeId = object.peerNodeId?.map((e) => e) || [];
    return message;
  },
};

function createBaseSyncProgressResponse(): SyncProgressResponse {
  return { tipHeight: Long.UZERO, localHeight: Long.UZERO, state: 0, shortDesc: "", initialConnectedPeers: Long.UZERO };
}

export const SyncProgressResponse: MessageFns<SyncProgressResponse> = {
  encode(message: SyncProgressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.tipHeight.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.tipHeight.toString());
    }
    if (!message.localHeight.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.localHeight.toString());
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.shortDesc !== "") {
      writer.uint32(34).string(message.shortDesc);
    }
    if (!message.initialConnectedPeers.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.initialConnectedPeers.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncProgressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncProgressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tipHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.localHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shortDesc = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.initialConnectedPeers = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncProgressResponse {
    return {
      tipHeight: isSet(object.tipHeight) ? Long.fromValue(object.tipHeight) : Long.UZERO,
      localHeight: isSet(object.localHeight) ? Long.fromValue(object.localHeight) : Long.UZERO,
      state: isSet(object.state) ? syncStateFromJSON(object.state) : 0,
      shortDesc: isSet(object.shortDesc) ? globalThis.String(object.shortDesc) : "",
      initialConnectedPeers: isSet(object.initialConnectedPeers)
        ? Long.fromValue(object.initialConnectedPeers)
        : Long.UZERO,
    };
  },

  toJSON(message: SyncProgressResponse): unknown {
    const obj: any = {};
    if (!message.tipHeight.equals(Long.UZERO)) {
      obj.tipHeight = (message.tipHeight || Long.UZERO).toString();
    }
    if (!message.localHeight.equals(Long.UZERO)) {
      obj.localHeight = (message.localHeight || Long.UZERO).toString();
    }
    if (message.state !== 0) {
      obj.state = syncStateToJSON(message.state);
    }
    if (message.shortDesc !== "") {
      obj.shortDesc = message.shortDesc;
    }
    if (!message.initialConnectedPeers.equals(Long.UZERO)) {
      obj.initialConnectedPeers = (message.initialConnectedPeers || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncProgressResponse>, I>>(base?: I): SyncProgressResponse {
    return SyncProgressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncProgressResponse>, I>>(object: I): SyncProgressResponse {
    const message = createBaseSyncProgressResponse();
    message.tipHeight = (object.tipHeight !== undefined && object.tipHeight !== null)
      ? Long.fromValue(object.tipHeight)
      : Long.UZERO;
    message.localHeight = (object.localHeight !== undefined && object.localHeight !== null)
      ? Long.fromValue(object.localHeight)
      : Long.UZERO;
    message.state = object.state ?? 0;
    message.shortDesc = object.shortDesc ?? "";
    message.initialConnectedPeers =
      (object.initialConnectedPeers !== undefined && object.initialConnectedPeers !== null)
        ? Long.fromValue(object.initialConnectedPeers)
        : Long.UZERO;
    return message;
  },
};

function createBaseGetNewBlockResult(): GetNewBlockResult {
  return {
    blockHash: new Uint8Array(0),
    block: undefined,
    mergeMiningHash: new Uint8Array(0),
    tariUniqueId: new Uint8Array(0),
    minerData: undefined,
    vmKey: new Uint8Array(0),
  };
}

export const GetNewBlockResult: MessageFns<GetNewBlockResult> = {
  encode(message: GetNewBlockResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockHash.length !== 0) {
      writer.uint32(10).bytes(message.blockHash);
    }
    if (message.block !== undefined) {
      Block.encode(message.block, writer.uint32(18).fork()).join();
    }
    if (message.mergeMiningHash.length !== 0) {
      writer.uint32(26).bytes(message.mergeMiningHash);
    }
    if (message.tariUniqueId.length !== 0) {
      writer.uint32(34).bytes(message.tariUniqueId);
    }
    if (message.minerData !== undefined) {
      MinerData.encode(message.minerData, writer.uint32(42).fork()).join();
    }
    if (message.vmKey.length !== 0) {
      writer.uint32(50).bytes(message.vmKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNewBlockResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNewBlockResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.block = Block.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mergeMiningHash = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tariUniqueId = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.minerData = MinerData.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.vmKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNewBlockResult {
    return {
      blockHash: isSet(object.blockHash) ? bytesFromBase64(object.blockHash) : new Uint8Array(0),
      block: isSet(object.block) ? Block.fromJSON(object.block) : undefined,
      mergeMiningHash: isSet(object.mergeMiningHash) ? bytesFromBase64(object.mergeMiningHash) : new Uint8Array(0),
      tariUniqueId: isSet(object.tariUniqueId) ? bytesFromBase64(object.tariUniqueId) : new Uint8Array(0),
      minerData: isSet(object.minerData) ? MinerData.fromJSON(object.minerData) : undefined,
      vmKey: isSet(object.vmKey) ? bytesFromBase64(object.vmKey) : new Uint8Array(0),
    };
  },

  toJSON(message: GetNewBlockResult): unknown {
    const obj: any = {};
    if (message.blockHash.length !== 0) {
      obj.blockHash = base64FromBytes(message.blockHash);
    }
    if (message.block !== undefined) {
      obj.block = Block.toJSON(message.block);
    }
    if (message.mergeMiningHash.length !== 0) {
      obj.mergeMiningHash = base64FromBytes(message.mergeMiningHash);
    }
    if (message.tariUniqueId.length !== 0) {
      obj.tariUniqueId = base64FromBytes(message.tariUniqueId);
    }
    if (message.minerData !== undefined) {
      obj.minerData = MinerData.toJSON(message.minerData);
    }
    if (message.vmKey.length !== 0) {
      obj.vmKey = base64FromBytes(message.vmKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNewBlockResult>, I>>(base?: I): GetNewBlockResult {
    return GetNewBlockResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNewBlockResult>, I>>(object: I): GetNewBlockResult {
    const message = createBaseGetNewBlockResult();
    message.blockHash = object.blockHash ?? new Uint8Array(0);
    message.block = (object.block !== undefined && object.block !== null) ? Block.fromPartial(object.block) : undefined;
    message.mergeMiningHash = object.mergeMiningHash ?? new Uint8Array(0);
    message.tariUniqueId = object.tariUniqueId ?? new Uint8Array(0);
    message.minerData = (object.minerData !== undefined && object.minerData !== null)
      ? MinerData.fromPartial(object.minerData)
      : undefined;
    message.vmKey = object.vmKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetNewBlockBlobResult(): GetNewBlockBlobResult {
  return {
    blockHash: new Uint8Array(0),
    header: new Uint8Array(0),
    blockBody: new Uint8Array(0),
    mergeMiningHash: new Uint8Array(0),
    utxoMr: new Uint8Array(0),
    tariUniqueId: new Uint8Array(0),
  };
}

export const GetNewBlockBlobResult: MessageFns<GetNewBlockBlobResult> = {
  encode(message: GetNewBlockBlobResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockHash.length !== 0) {
      writer.uint32(10).bytes(message.blockHash);
    }
    if (message.header.length !== 0) {
      writer.uint32(18).bytes(message.header);
    }
    if (message.blockBody.length !== 0) {
      writer.uint32(26).bytes(message.blockBody);
    }
    if (message.mergeMiningHash.length !== 0) {
      writer.uint32(34).bytes(message.mergeMiningHash);
    }
    if (message.utxoMr.length !== 0) {
      writer.uint32(42).bytes(message.utxoMr);
    }
    if (message.tariUniqueId.length !== 0) {
      writer.uint32(50).bytes(message.tariUniqueId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNewBlockBlobResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNewBlockBlobResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.header = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blockBody = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mergeMiningHash = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.utxoMr = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tariUniqueId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNewBlockBlobResult {
    return {
      blockHash: isSet(object.blockHash) ? bytesFromBase64(object.blockHash) : new Uint8Array(0),
      header: isSet(object.header) ? bytesFromBase64(object.header) : new Uint8Array(0),
      blockBody: isSet(object.blockBody) ? bytesFromBase64(object.blockBody) : new Uint8Array(0),
      mergeMiningHash: isSet(object.mergeMiningHash) ? bytesFromBase64(object.mergeMiningHash) : new Uint8Array(0),
      utxoMr: isSet(object.utxoMr) ? bytesFromBase64(object.utxoMr) : new Uint8Array(0),
      tariUniqueId: isSet(object.tariUniqueId) ? bytesFromBase64(object.tariUniqueId) : new Uint8Array(0),
    };
  },

  toJSON(message: GetNewBlockBlobResult): unknown {
    const obj: any = {};
    if (message.blockHash.length !== 0) {
      obj.blockHash = base64FromBytes(message.blockHash);
    }
    if (message.header.length !== 0) {
      obj.header = base64FromBytes(message.header);
    }
    if (message.blockBody.length !== 0) {
      obj.blockBody = base64FromBytes(message.blockBody);
    }
    if (message.mergeMiningHash.length !== 0) {
      obj.mergeMiningHash = base64FromBytes(message.mergeMiningHash);
    }
    if (message.utxoMr.length !== 0) {
      obj.utxoMr = base64FromBytes(message.utxoMr);
    }
    if (message.tariUniqueId.length !== 0) {
      obj.tariUniqueId = base64FromBytes(message.tariUniqueId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNewBlockBlobResult>, I>>(base?: I): GetNewBlockBlobResult {
    return GetNewBlockBlobResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNewBlockBlobResult>, I>>(object: I): GetNewBlockBlobResult {
    const message = createBaseGetNewBlockBlobResult();
    message.blockHash = object.blockHash ?? new Uint8Array(0);
    message.header = object.header ?? new Uint8Array(0);
    message.blockBody = object.blockBody ?? new Uint8Array(0);
    message.mergeMiningHash = object.mergeMiningHash ?? new Uint8Array(0);
    message.utxoMr = object.utxoMr ?? new Uint8Array(0);
    message.tariUniqueId = object.tariUniqueId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMinerData(): MinerData {
  return { algo: undefined, targetDifficulty: Long.UZERO, reward: Long.UZERO, totalFees: Long.UZERO };
}

export const MinerData: MessageFns<MinerData> = {
  encode(message: MinerData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algo !== undefined) {
      PowAlgo.encode(message.algo, writer.uint32(10).fork()).join();
    }
    if (!message.targetDifficulty.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.targetDifficulty.toString());
    }
    if (!message.reward.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.reward.toString());
    }
    if (!message.totalFees.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.totalFees.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MinerData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMinerData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.algo = PowAlgo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.targetDifficulty = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reward = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalFees = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MinerData {
    return {
      algo: isSet(object.algo) ? PowAlgo.fromJSON(object.algo) : undefined,
      targetDifficulty: isSet(object.targetDifficulty) ? Long.fromValue(object.targetDifficulty) : Long.UZERO,
      reward: isSet(object.reward) ? Long.fromValue(object.reward) : Long.UZERO,
      totalFees: isSet(object.totalFees) ? Long.fromValue(object.totalFees) : Long.UZERO,
    };
  },

  toJSON(message: MinerData): unknown {
    const obj: any = {};
    if (message.algo !== undefined) {
      obj.algo = PowAlgo.toJSON(message.algo);
    }
    if (!message.targetDifficulty.equals(Long.UZERO)) {
      obj.targetDifficulty = (message.targetDifficulty || Long.UZERO).toString();
    }
    if (!message.reward.equals(Long.UZERO)) {
      obj.reward = (message.reward || Long.UZERO).toString();
    }
    if (!message.totalFees.equals(Long.UZERO)) {
      obj.totalFees = (message.totalFees || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MinerData>, I>>(base?: I): MinerData {
    return MinerData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MinerData>, I>>(object: I): MinerData {
    const message = createBaseMinerData();
    message.algo = (object.algo !== undefined && object.algo !== null) ? PowAlgo.fromPartial(object.algo) : undefined;
    message.targetDifficulty = (object.targetDifficulty !== undefined && object.targetDifficulty !== null)
      ? Long.fromValue(object.targetDifficulty)
      : Long.UZERO;
    message.reward = (object.reward !== undefined && object.reward !== null)
      ? Long.fromValue(object.reward)
      : Long.UZERO;
    message.totalFees = (object.totalFees !== undefined && object.totalFees !== null)
      ? Long.fromValue(object.totalFees)
      : Long.UZERO;
    return message;
  },
};

function createBaseSearchKernelsRequest(): SearchKernelsRequest {
  return { signatures: [] };
}

export const SearchKernelsRequest: MessageFns<SearchKernelsRequest> = {
  encode(message: SearchKernelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signatures) {
      Signature.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchKernelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchKernelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signatures.push(Signature.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchKernelsRequest {
    return {
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => Signature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchKernelsRequest): unknown {
    const obj: any = {};
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => Signature.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchKernelsRequest>, I>>(base?: I): SearchKernelsRequest {
    return SearchKernelsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchKernelsRequest>, I>>(object: I): SearchKernelsRequest {
    const message = createBaseSearchKernelsRequest();
    message.signatures = object.signatures?.map((e) => Signature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchUtxosRequest(): SearchUtxosRequest {
  return { commitments: [] };
}

export const SearchUtxosRequest: MessageFns<SearchUtxosRequest> = {
  encode(message: SearchUtxosRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.commitments) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchUtxosRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchUtxosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commitments.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchUtxosRequest {
    return {
      commitments: globalThis.Array.isArray(object?.commitments)
        ? object.commitments.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: SearchUtxosRequest): unknown {
    const obj: any = {};
    if (message.commitments?.length) {
      obj.commitments = message.commitments.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchUtxosRequest>, I>>(base?: I): SearchUtxosRequest {
    return SearchUtxosRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchUtxosRequest>, I>>(object: I): SearchUtxosRequest {
    const message = createBaseSearchUtxosRequest();
    message.commitments = object.commitments?.map((e) => e) || [];
    return message;
  },
};

function createBaseFetchMatchingUtxosRequest(): FetchMatchingUtxosRequest {
  return { hashes: [] };
}

export const FetchMatchingUtxosRequest: MessageFns<FetchMatchingUtxosRequest> = {
  encode(message: FetchMatchingUtxosRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.hashes) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchMatchingUtxosRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchMatchingUtxosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hashes.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchMatchingUtxosRequest {
    return {
      hashes: globalThis.Array.isArray(object?.hashes) ? object.hashes.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: FetchMatchingUtxosRequest): unknown {
    const obj: any = {};
    if (message.hashes?.length) {
      obj.hashes = message.hashes.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FetchMatchingUtxosRequest>, I>>(base?: I): FetchMatchingUtxosRequest {
    return FetchMatchingUtxosRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FetchMatchingUtxosRequest>, I>>(object: I): FetchMatchingUtxosRequest {
    const message = createBaseFetchMatchingUtxosRequest();
    message.hashes = object.hashes?.map((e) => e) || [];
    return message;
  },
};

function createBaseFetchMatchingUtxosResponse(): FetchMatchingUtxosResponse {
  return { output: undefined };
}

export const FetchMatchingUtxosResponse: MessageFns<FetchMatchingUtxosResponse> = {
  encode(message: FetchMatchingUtxosResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.output !== undefined) {
      TransactionOutput.encode(message.output, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchMatchingUtxosResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchMatchingUtxosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.output = TransactionOutput.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchMatchingUtxosResponse {
    return { output: isSet(object.output) ? TransactionOutput.fromJSON(object.output) : undefined };
  },

  toJSON(message: FetchMatchingUtxosResponse): unknown {
    const obj: any = {};
    if (message.output !== undefined) {
      obj.output = TransactionOutput.toJSON(message.output);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FetchMatchingUtxosResponse>, I>>(base?: I): FetchMatchingUtxosResponse {
    return FetchMatchingUtxosResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FetchMatchingUtxosResponse>, I>>(object: I): FetchMatchingUtxosResponse {
    const message = createBaseFetchMatchingUtxosResponse();
    message.output = (object.output !== undefined && object.output !== null)
      ? TransactionOutput.fromPartial(object.output)
      : undefined;
    return message;
  },
};

function createBaseGetPeersResponse(): GetPeersResponse {
  return { peer: undefined };
}

export const GetPeersResponse: MessageFns<GetPeersResponse> = {
  encode(message: GetPeersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peer !== undefined) {
      Peer.encode(message.peer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPeersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPeersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peer = Peer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPeersResponse {
    return { peer: isSet(object.peer) ? Peer.fromJSON(object.peer) : undefined };
  },

  toJSON(message: GetPeersResponse): unknown {
    const obj: any = {};
    if (message.peer !== undefined) {
      obj.peer = Peer.toJSON(message.peer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPeersResponse>, I>>(base?: I): GetPeersResponse {
    return GetPeersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPeersResponse>, I>>(object: I): GetPeersResponse {
    const message = createBaseGetPeersResponse();
    message.peer = (object.peer !== undefined && object.peer !== null) ? Peer.fromPartial(object.peer) : undefined;
    return message;
  },
};

function createBaseGetPeersRequest(): GetPeersRequest {
  return {};
}

export const GetPeersRequest: MessageFns<GetPeersRequest> = {
  encode(_: GetPeersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPeersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPeersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetPeersRequest {
    return {};
  },

  toJSON(_: GetPeersRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPeersRequest>, I>>(base?: I): GetPeersRequest {
    return GetPeersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPeersRequest>, I>>(_: I): GetPeersRequest {
    const message = createBaseGetPeersRequest();
    return message;
  },
};

function createBaseSubmitTransactionRequest(): SubmitTransactionRequest {
  return { transaction: undefined };
}

export const SubmitTransactionRequest: MessageFns<SubmitTransactionRequest> = {
  encode(message: SubmitTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTransactionRequest {
    return { transaction: isSet(object.transaction) ? Transaction.fromJSON(object.transaction) : undefined };
  },

  toJSON(message: SubmitTransactionRequest): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTransactionRequest>, I>>(base?: I): SubmitTransactionRequest {
    return SubmitTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTransactionRequest>, I>>(object: I): SubmitTransactionRequest {
    const message = createBaseSubmitTransactionRequest();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? Transaction.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseSubmitTransactionResponse(): SubmitTransactionResponse {
  return { result: 0 };
}

export const SubmitTransactionResponse: MessageFns<SubmitTransactionResponse> = {
  encode(message: SubmitTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTransactionResponse {
    return { result: isSet(object.result) ? submitTransactionResultFromJSON(object.result) : 0 };
  },

  toJSON(message: SubmitTransactionResponse): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = submitTransactionResultToJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTransactionResponse>, I>>(base?: I): SubmitTransactionResponse {
    return SubmitTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTransactionResponse>, I>>(object: I): SubmitTransactionResponse {
    const message = createBaseSubmitTransactionResponse();
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseGetMempoolTransactionsRequest(): GetMempoolTransactionsRequest {
  return {};
}

export const GetMempoolTransactionsRequest: MessageFns<GetMempoolTransactionsRequest> = {
  encode(_: GetMempoolTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMempoolTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMempoolTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetMempoolTransactionsRequest {
    return {};
  },

  toJSON(_: GetMempoolTransactionsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMempoolTransactionsRequest>, I>>(base?: I): GetMempoolTransactionsRequest {
    return GetMempoolTransactionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMempoolTransactionsRequest>, I>>(_: I): GetMempoolTransactionsRequest {
    const message = createBaseGetMempoolTransactionsRequest();
    return message;
  },
};

function createBaseGetMempoolTransactionsResponse(): GetMempoolTransactionsResponse {
  return { transaction: undefined };
}

export const GetMempoolTransactionsResponse: MessageFns<GetMempoolTransactionsResponse> = {
  encode(message: GetMempoolTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMempoolTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMempoolTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMempoolTransactionsResponse {
    return { transaction: isSet(object.transaction) ? Transaction.fromJSON(object.transaction) : undefined };
  },

  toJSON(message: GetMempoolTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMempoolTransactionsResponse>, I>>(base?: I): GetMempoolTransactionsResponse {
    return GetMempoolTransactionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMempoolTransactionsResponse>, I>>(
    object: I,
  ): GetMempoolTransactionsResponse {
    const message = createBaseGetMempoolTransactionsResponse();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? Transaction.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseTransactionStateRequest(): TransactionStateRequest {
  return { excessSig: undefined };
}

export const TransactionStateRequest: MessageFns<TransactionStateRequest> = {
  encode(message: TransactionStateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.excessSig !== undefined) {
      Signature.encode(message.excessSig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionStateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.excessSig = Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionStateRequest {
    return { excessSig: isSet(object.excessSig) ? Signature.fromJSON(object.excessSig) : undefined };
  },

  toJSON(message: TransactionStateRequest): unknown {
    const obj: any = {};
    if (message.excessSig !== undefined) {
      obj.excessSig = Signature.toJSON(message.excessSig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionStateRequest>, I>>(base?: I): TransactionStateRequest {
    return TransactionStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionStateRequest>, I>>(object: I): TransactionStateRequest {
    const message = createBaseTransactionStateRequest();
    message.excessSig = (object.excessSig !== undefined && object.excessSig !== null)
      ? Signature.fromPartial(object.excessSig)
      : undefined;
    return message;
  },
};

function createBaseTransactionStateResponse(): TransactionStateResponse {
  return { result: 0 };
}

export const TransactionStateResponse: MessageFns<TransactionStateResponse> = {
  encode(message: TransactionStateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionStateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionStateResponse {
    return { result: isSet(object.result) ? transactionLocationFromJSON(object.result) : 0 };
  },

  toJSON(message: TransactionStateResponse): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = transactionLocationToJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionStateResponse>, I>>(base?: I): TransactionStateResponse {
    return TransactionStateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionStateResponse>, I>>(object: I): TransactionStateResponse {
    const message = createBaseTransactionStateResponse();
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseMempoolStatsResponse(): MempoolStatsResponse {
  return { unconfirmedTxs: Long.UZERO, reorgTxs: Long.UZERO, unconfirmedWeight: Long.UZERO };
}

export const MempoolStatsResponse: MessageFns<MempoolStatsResponse> = {
  encode(message: MempoolStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.unconfirmedTxs.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.unconfirmedTxs.toString());
    }
    if (!message.reorgTxs.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.reorgTxs.toString());
    }
    if (!message.unconfirmedWeight.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.unconfirmedWeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MempoolStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMempoolStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.unconfirmedTxs = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reorgTxs = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.unconfirmedWeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MempoolStatsResponse {
    return {
      unconfirmedTxs: isSet(object.unconfirmedTxs) ? Long.fromValue(object.unconfirmedTxs) : Long.UZERO,
      reorgTxs: isSet(object.reorgTxs) ? Long.fromValue(object.reorgTxs) : Long.UZERO,
      unconfirmedWeight: isSet(object.unconfirmedWeight) ? Long.fromValue(object.unconfirmedWeight) : Long.UZERO,
    };
  },

  toJSON(message: MempoolStatsResponse): unknown {
    const obj: any = {};
    if (!message.unconfirmedTxs.equals(Long.UZERO)) {
      obj.unconfirmedTxs = (message.unconfirmedTxs || Long.UZERO).toString();
    }
    if (!message.reorgTxs.equals(Long.UZERO)) {
      obj.reorgTxs = (message.reorgTxs || Long.UZERO).toString();
    }
    if (!message.unconfirmedWeight.equals(Long.UZERO)) {
      obj.unconfirmedWeight = (message.unconfirmedWeight || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MempoolStatsResponse>, I>>(base?: I): MempoolStatsResponse {
    return MempoolStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MempoolStatsResponse>, I>>(object: I): MempoolStatsResponse {
    const message = createBaseMempoolStatsResponse();
    message.unconfirmedTxs = (object.unconfirmedTxs !== undefined && object.unconfirmedTxs !== null)
      ? Long.fromValue(object.unconfirmedTxs)
      : Long.UZERO;
    message.reorgTxs = (object.reorgTxs !== undefined && object.reorgTxs !== null)
      ? Long.fromValue(object.reorgTxs)
      : Long.UZERO;
    message.unconfirmedWeight = (object.unconfirmedWeight !== undefined && object.unconfirmedWeight !== null)
      ? Long.fromValue(object.unconfirmedWeight)
      : Long.UZERO;
    return message;
  },
};

function createBaseGetActiveValidatorNodesRequest(): GetActiveValidatorNodesRequest {
  return { height: Long.UZERO, sidechainId: new Uint8Array(0) };
}

export const GetActiveValidatorNodesRequest: MessageFns<GetActiveValidatorNodesRequest> = {
  encode(message: GetActiveValidatorNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.height.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.height.toString());
    }
    if (message.sidechainId.length !== 0) {
      writer.uint32(18).bytes(message.sidechainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveValidatorNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveValidatorNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sidechainId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveValidatorNodesRequest {
    return {
      height: isSet(object.height) ? Long.fromValue(object.height) : Long.UZERO,
      sidechainId: isSet(object.sidechainId) ? bytesFromBase64(object.sidechainId) : new Uint8Array(0),
    };
  },

  toJSON(message: GetActiveValidatorNodesRequest): unknown {
    const obj: any = {};
    if (!message.height.equals(Long.UZERO)) {
      obj.height = (message.height || Long.UZERO).toString();
    }
    if (message.sidechainId.length !== 0) {
      obj.sidechainId = base64FromBytes(message.sidechainId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActiveValidatorNodesRequest>, I>>(base?: I): GetActiveValidatorNodesRequest {
    return GetActiveValidatorNodesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActiveValidatorNodesRequest>, I>>(
    object: I,
  ): GetActiveValidatorNodesRequest {
    const message = createBaseGetActiveValidatorNodesRequest();
    message.height = (object.height !== undefined && object.height !== null)
      ? Long.fromValue(object.height)
      : Long.UZERO;
    message.sidechainId = object.sidechainId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetActiveValidatorNodesResponse(): GetActiveValidatorNodesResponse {
  return { shardKey: new Uint8Array(0), publicKey: new Uint8Array(0), sidechainId: new Uint8Array(0) };
}

export const GetActiveValidatorNodesResponse: MessageFns<GetActiveValidatorNodesResponse> = {
  encode(message: GetActiveValidatorNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardKey.length !== 0) {
      writer.uint32(10).bytes(message.shardKey);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(18).bytes(message.publicKey);
    }
    if (message.sidechainId.length !== 0) {
      writer.uint32(26).bytes(message.sidechainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveValidatorNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveValidatorNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shardKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sidechainId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveValidatorNodesResponse {
    return {
      shardKey: isSet(object.shardKey) ? bytesFromBase64(object.shardKey) : new Uint8Array(0),
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      sidechainId: isSet(object.sidechainId) ? bytesFromBase64(object.sidechainId) : new Uint8Array(0),
    };
  },

  toJSON(message: GetActiveValidatorNodesResponse): unknown {
    const obj: any = {};
    if (message.shardKey.length !== 0) {
      obj.shardKey = base64FromBytes(message.shardKey);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.sidechainId.length !== 0) {
      obj.sidechainId = base64FromBytes(message.sidechainId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActiveValidatorNodesResponse>, I>>(base?: I): GetActiveValidatorNodesResponse {
    return GetActiveValidatorNodesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActiveValidatorNodesResponse>, I>>(
    object: I,
  ): GetActiveValidatorNodesResponse {
    const message = createBaseGetActiveValidatorNodesResponse();
    message.shardKey = object.shardKey ?? new Uint8Array(0);
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.sidechainId = object.sidechainId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetValidatorNodeChangesRequest(): GetValidatorNodeChangesRequest {
  return { epoch: Long.UZERO, sidechainId: new Uint8Array(0) };
}

export const GetValidatorNodeChangesRequest: MessageFns<GetValidatorNodeChangesRequest> = {
  encode(message: GetValidatorNodeChangesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.epoch.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.epoch.toString());
    }
    if (message.sidechainId.length !== 0) {
      writer.uint32(18).bytes(message.sidechainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetValidatorNodeChangesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetValidatorNodeChangesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epoch = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sidechainId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetValidatorNodeChangesRequest {
    return {
      epoch: isSet(object.epoch) ? Long.fromValue(object.epoch) : Long.UZERO,
      sidechainId: isSet(object.sidechainId) ? bytesFromBase64(object.sidechainId) : new Uint8Array(0),
    };
  },

  toJSON(message: GetValidatorNodeChangesRequest): unknown {
    const obj: any = {};
    if (!message.epoch.equals(Long.UZERO)) {
      obj.epoch = (message.epoch || Long.UZERO).toString();
    }
    if (message.sidechainId.length !== 0) {
      obj.sidechainId = base64FromBytes(message.sidechainId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetValidatorNodeChangesRequest>, I>>(base?: I): GetValidatorNodeChangesRequest {
    return GetValidatorNodeChangesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetValidatorNodeChangesRequest>, I>>(
    object: I,
  ): GetValidatorNodeChangesRequest {
    const message = createBaseGetValidatorNodeChangesRequest();
    message.epoch = (object.epoch !== undefined && object.epoch !== null) ? Long.fromValue(object.epoch) : Long.UZERO;
    message.sidechainId = object.sidechainId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseValidatorNodeChange(): ValidatorNodeChange {
  return { add: undefined, remove: undefined };
}

export const ValidatorNodeChange: MessageFns<ValidatorNodeChange> = {
  encode(message: ValidatorNodeChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.add !== undefined) {
      ValidatorNodeChangeAdd.encode(message.add, writer.uint32(10).fork()).join();
    }
    if (message.remove !== undefined) {
      ValidatorNodeChangeRemove.encode(message.remove, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatorNodeChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorNodeChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.add = ValidatorNodeChangeAdd.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.remove = ValidatorNodeChangeRemove.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorNodeChange {
    return {
      add: isSet(object.add) ? ValidatorNodeChangeAdd.fromJSON(object.add) : undefined,
      remove: isSet(object.remove) ? ValidatorNodeChangeRemove.fromJSON(object.remove) : undefined,
    };
  },

  toJSON(message: ValidatorNodeChange): unknown {
    const obj: any = {};
    if (message.add !== undefined) {
      obj.add = ValidatorNodeChangeAdd.toJSON(message.add);
    }
    if (message.remove !== undefined) {
      obj.remove = ValidatorNodeChangeRemove.toJSON(message.remove);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidatorNodeChange>, I>>(base?: I): ValidatorNodeChange {
    return ValidatorNodeChange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidatorNodeChange>, I>>(object: I): ValidatorNodeChange {
    const message = createBaseValidatorNodeChange();
    message.add = (object.add !== undefined && object.add !== null)
      ? ValidatorNodeChangeAdd.fromPartial(object.add)
      : undefined;
    message.remove = (object.remove !== undefined && object.remove !== null)
      ? ValidatorNodeChangeRemove.fromPartial(object.remove)
      : undefined;
    return message;
  },
};

function createBaseValidatorNodeChangeAdd(): ValidatorNodeChangeAdd {
  return {
    activationEpoch: Long.UZERO,
    registration: undefined,
    minimumValuePromise: Long.UZERO,
    shardKey: new Uint8Array(0),
  };
}

export const ValidatorNodeChangeAdd: MessageFns<ValidatorNodeChangeAdd> = {
  encode(message: ValidatorNodeChangeAdd, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.activationEpoch.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.activationEpoch.toString());
    }
    if (message.registration !== undefined) {
      ValidatorNodeRegistration.encode(message.registration, writer.uint32(18).fork()).join();
    }
    if (!message.minimumValuePromise.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.minimumValuePromise.toString());
    }
    if (message.shardKey.length !== 0) {
      writer.uint32(34).bytes(message.shardKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatorNodeChangeAdd {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorNodeChangeAdd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.activationEpoch = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.registration = ValidatorNodeRegistration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.minimumValuePromise = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shardKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorNodeChangeAdd {
    return {
      activationEpoch: isSet(object.activationEpoch) ? Long.fromValue(object.activationEpoch) : Long.UZERO,
      registration: isSet(object.registration) ? ValidatorNodeRegistration.fromJSON(object.registration) : undefined,
      minimumValuePromise: isSet(object.minimumValuePromise) ? Long.fromValue(object.minimumValuePromise) : Long.UZERO,
      shardKey: isSet(object.shardKey) ? bytesFromBase64(object.shardKey) : new Uint8Array(0),
    };
  },

  toJSON(message: ValidatorNodeChangeAdd): unknown {
    const obj: any = {};
    if (!message.activationEpoch.equals(Long.UZERO)) {
      obj.activationEpoch = (message.activationEpoch || Long.UZERO).toString();
    }
    if (message.registration !== undefined) {
      obj.registration = ValidatorNodeRegistration.toJSON(message.registration);
    }
    if (!message.minimumValuePromise.equals(Long.UZERO)) {
      obj.minimumValuePromise = (message.minimumValuePromise || Long.UZERO).toString();
    }
    if (message.shardKey.length !== 0) {
      obj.shardKey = base64FromBytes(message.shardKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidatorNodeChangeAdd>, I>>(base?: I): ValidatorNodeChangeAdd {
    return ValidatorNodeChangeAdd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidatorNodeChangeAdd>, I>>(object: I): ValidatorNodeChangeAdd {
    const message = createBaseValidatorNodeChangeAdd();
    message.activationEpoch = (object.activationEpoch !== undefined && object.activationEpoch !== null)
      ? Long.fromValue(object.activationEpoch)
      : Long.UZERO;
    message.registration = (object.registration !== undefined && object.registration !== null)
      ? ValidatorNodeRegistration.fromPartial(object.registration)
      : undefined;
    message.minimumValuePromise = (object.minimumValuePromise !== undefined && object.minimumValuePromise !== null)
      ? Long.fromValue(object.minimumValuePromise)
      : Long.UZERO;
    message.shardKey = object.shardKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseValidatorNodeChangeRemove(): ValidatorNodeChangeRemove {
  return { publicKey: new Uint8Array(0) };
}

export const ValidatorNodeChangeRemove: MessageFns<ValidatorNodeChangeRemove> = {
  encode(message: ValidatorNodeChangeRemove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey.length !== 0) {
      writer.uint32(10).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatorNodeChangeRemove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorNodeChangeRemove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorNodeChangeRemove {
    return { publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0) };
  },

  toJSON(message: ValidatorNodeChangeRemove): unknown {
    const obj: any = {};
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidatorNodeChangeRemove>, I>>(base?: I): ValidatorNodeChangeRemove {
    return ValidatorNodeChangeRemove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidatorNodeChangeRemove>, I>>(object: I): ValidatorNodeChangeRemove {
    const message = createBaseValidatorNodeChangeRemove();
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetValidatorNodeChangesResponse(): GetValidatorNodeChangesResponse {
  return { changes: [] };
}

export const GetValidatorNodeChangesResponse: MessageFns<GetValidatorNodeChangesResponse> = {
  encode(message: GetValidatorNodeChangesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.changes) {
      ValidatorNodeChange.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetValidatorNodeChangesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetValidatorNodeChangesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.changes.push(ValidatorNodeChange.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetValidatorNodeChangesResponse {
    return {
      changes: globalThis.Array.isArray(object?.changes)
        ? object.changes.map((e: any) => ValidatorNodeChange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetValidatorNodeChangesResponse): unknown {
    const obj: any = {};
    if (message.changes?.length) {
      obj.changes = message.changes.map((e) => ValidatorNodeChange.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetValidatorNodeChangesResponse>, I>>(base?: I): GetValidatorNodeChangesResponse {
    return GetValidatorNodeChangesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetValidatorNodeChangesResponse>, I>>(
    object: I,
  ): GetValidatorNodeChangesResponse {
    const message = createBaseGetValidatorNodeChangesResponse();
    message.changes = object.changes?.map((e) => ValidatorNodeChange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetShardKeyRequest(): GetShardKeyRequest {
  return { epoch: Long.UZERO, publicKey: new Uint8Array(0) };
}

export const GetShardKeyRequest: MessageFns<GetShardKeyRequest> = {
  encode(message: GetShardKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.epoch.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.epoch.toString());
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(18).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetShardKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetShardKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epoch = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetShardKeyRequest {
    return {
      epoch: isSet(object.epoch) ? Long.fromValue(object.epoch) : Long.UZERO,
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: GetShardKeyRequest): unknown {
    const obj: any = {};
    if (!message.epoch.equals(Long.UZERO)) {
      obj.epoch = (message.epoch || Long.UZERO).toString();
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetShardKeyRequest>, I>>(base?: I): GetShardKeyRequest {
    return GetShardKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetShardKeyRequest>, I>>(object: I): GetShardKeyRequest {
    const message = createBaseGetShardKeyRequest();
    message.epoch = (object.epoch !== undefined && object.epoch !== null) ? Long.fromValue(object.epoch) : Long.UZERO;
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetShardKeyResponse(): GetShardKeyResponse {
  return { shardKey: new Uint8Array(0) };
}

export const GetShardKeyResponse: MessageFns<GetShardKeyResponse> = {
  encode(message: GetShardKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardKey.length !== 0) {
      writer.uint32(10).bytes(message.shardKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetShardKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetShardKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shardKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetShardKeyResponse {
    return { shardKey: isSet(object.shardKey) ? bytesFromBase64(object.shardKey) : new Uint8Array(0) };
  },

  toJSON(message: GetShardKeyResponse): unknown {
    const obj: any = {};
    if (message.shardKey.length !== 0) {
      obj.shardKey = base64FromBytes(message.shardKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetShardKeyResponse>, I>>(base?: I): GetShardKeyResponse {
    return GetShardKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetShardKeyResponse>, I>>(object: I): GetShardKeyResponse {
    const message = createBaseGetShardKeyResponse();
    message.shardKey = object.shardKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetTemplateRegistrationsRequest(): GetTemplateRegistrationsRequest {
  return { startHash: new Uint8Array(0), count: Long.UZERO };
}

export const GetTemplateRegistrationsRequest: MessageFns<GetTemplateRegistrationsRequest> = {
  encode(message: GetTemplateRegistrationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startHash.length !== 0) {
      writer.uint32(10).bytes(message.startHash);
    }
    if (!message.count.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.count.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTemplateRegistrationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTemplateRegistrationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTemplateRegistrationsRequest {
    return {
      startHash: isSet(object.startHash) ? bytesFromBase64(object.startHash) : new Uint8Array(0),
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.UZERO,
    };
  },

  toJSON(message: GetTemplateRegistrationsRequest): unknown {
    const obj: any = {};
    if (message.startHash.length !== 0) {
      obj.startHash = base64FromBytes(message.startHash);
    }
    if (!message.count.equals(Long.UZERO)) {
      obj.count = (message.count || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTemplateRegistrationsRequest>, I>>(base?: I): GetTemplateRegistrationsRequest {
    return GetTemplateRegistrationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTemplateRegistrationsRequest>, I>>(
    object: I,
  ): GetTemplateRegistrationsRequest {
    const message = createBaseGetTemplateRegistrationsRequest();
    message.startHash = object.startHash ?? new Uint8Array(0);
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.UZERO;
    return message;
  },
};

function createBaseGetTemplateRegistrationResponse(): GetTemplateRegistrationResponse {
  return { utxoHash: new Uint8Array(0), registration: undefined };
}

export const GetTemplateRegistrationResponse: MessageFns<GetTemplateRegistrationResponse> = {
  encode(message: GetTemplateRegistrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.utxoHash.length !== 0) {
      writer.uint32(10).bytes(message.utxoHash);
    }
    if (message.registration !== undefined) {
      TemplateRegistration.encode(message.registration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTemplateRegistrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTemplateRegistrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.utxoHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.registration = TemplateRegistration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTemplateRegistrationResponse {
    return {
      utxoHash: isSet(object.utxoHash) ? bytesFromBase64(object.utxoHash) : new Uint8Array(0),
      registration: isSet(object.registration) ? TemplateRegistration.fromJSON(object.registration) : undefined,
    };
  },

  toJSON(message: GetTemplateRegistrationResponse): unknown {
    const obj: any = {};
    if (message.utxoHash.length !== 0) {
      obj.utxoHash = base64FromBytes(message.utxoHash);
    }
    if (message.registration !== undefined) {
      obj.registration = TemplateRegistration.toJSON(message.registration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTemplateRegistrationResponse>, I>>(base?: I): GetTemplateRegistrationResponse {
    return GetTemplateRegistrationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTemplateRegistrationResponse>, I>>(
    object: I,
  ): GetTemplateRegistrationResponse {
    const message = createBaseGetTemplateRegistrationResponse();
    message.utxoHash = object.utxoHash ?? new Uint8Array(0);
    message.registration = (object.registration !== undefined && object.registration !== null)
      ? TemplateRegistration.fromPartial(object.registration)
      : undefined;
    return message;
  },
};

function createBaseBlockInfo(): BlockInfo {
  return { height: Long.UZERO, hash: new Uint8Array(0), nextBlockHash: new Uint8Array(0) };
}

export const BlockInfo: MessageFns<BlockInfo> = {
  encode(message: BlockInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.height.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.height.toString());
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    if (message.nextBlockHash.length !== 0) {
      writer.uint32(26).bytes(message.nextBlockHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nextBlockHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockInfo {
    return {
      height: isSet(object.height) ? Long.fromValue(object.height) : Long.UZERO,
      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0),
      nextBlockHash: isSet(object.nextBlockHash) ? bytesFromBase64(object.nextBlockHash) : new Uint8Array(0),
    };
  },

  toJSON(message: BlockInfo): unknown {
    const obj: any = {};
    if (!message.height.equals(Long.UZERO)) {
      obj.height = (message.height || Long.UZERO).toString();
    }
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.nextBlockHash.length !== 0) {
      obj.nextBlockHash = base64FromBytes(message.nextBlockHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockInfo>, I>>(base?: I): BlockInfo {
    return BlockInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockInfo>, I>>(object: I): BlockInfo {
    const message = createBaseBlockInfo();
    message.height = (object.height !== undefined && object.height !== null)
      ? Long.fromValue(object.height)
      : Long.UZERO;
    message.hash = object.hash ?? new Uint8Array(0);
    message.nextBlockHash = object.nextBlockHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetSideChainUtxosRequest(): GetSideChainUtxosRequest {
  return { startHash: new Uint8Array(0), count: Long.UZERO };
}

export const GetSideChainUtxosRequest: MessageFns<GetSideChainUtxosRequest> = {
  encode(message: GetSideChainUtxosRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startHash.length !== 0) {
      writer.uint32(10).bytes(message.startHash);
    }
    if (!message.count.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.count.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSideChainUtxosRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSideChainUtxosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSideChainUtxosRequest {
    return {
      startHash: isSet(object.startHash) ? bytesFromBase64(object.startHash) : new Uint8Array(0),
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.UZERO,
    };
  },

  toJSON(message: GetSideChainUtxosRequest): unknown {
    const obj: any = {};
    if (message.startHash.length !== 0) {
      obj.startHash = base64FromBytes(message.startHash);
    }
    if (!message.count.equals(Long.UZERO)) {
      obj.count = (message.count || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSideChainUtxosRequest>, I>>(base?: I): GetSideChainUtxosRequest {
    return GetSideChainUtxosRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSideChainUtxosRequest>, I>>(object: I): GetSideChainUtxosRequest {
    const message = createBaseGetSideChainUtxosRequest();
    message.startHash = object.startHash ?? new Uint8Array(0);
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.UZERO;
    return message;
  },
};

function createBaseGetSideChainUtxosResponse(): GetSideChainUtxosResponse {
  return { blockInfo: undefined, outputs: [] };
}

export const GetSideChainUtxosResponse: MessageFns<GetSideChainUtxosResponse> = {
  encode(message: GetSideChainUtxosResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockInfo !== undefined) {
      BlockInfo.encode(message.blockInfo, writer.uint32(10).fork()).join();
    }
    for (const v of message.outputs) {
      TransactionOutput.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSideChainUtxosResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSideChainUtxosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockInfo = BlockInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outputs.push(TransactionOutput.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSideChainUtxosResponse {
    return {
      blockInfo: isSet(object.blockInfo) ? BlockInfo.fromJSON(object.blockInfo) : undefined,
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => TransactionOutput.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetSideChainUtxosResponse): unknown {
    const obj: any = {};
    if (message.blockInfo !== undefined) {
      obj.blockInfo = BlockInfo.toJSON(message.blockInfo);
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => TransactionOutput.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSideChainUtxosResponse>, I>>(base?: I): GetSideChainUtxosResponse {
    return GetSideChainUtxosResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSideChainUtxosResponse>, I>>(object: I): GetSideChainUtxosResponse {
    const message = createBaseGetSideChainUtxosResponse();
    message.blockInfo = (object.blockInfo !== undefined && object.blockInfo !== null)
      ? BlockInfo.fromPartial(object.blockInfo)
      : undefined;
    message.outputs = object.outputs?.map((e) => TransactionOutput.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetNetworkStateRequest(): GetNetworkStateRequest {
  return {};
}

export const GetNetworkStateRequest: MessageFns<GetNetworkStateRequest> = {
  encode(_: GetNetworkStateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNetworkStateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNetworkStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetNetworkStateRequest {
    return {};
  },

  toJSON(_: GetNetworkStateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNetworkStateRequest>, I>>(base?: I): GetNetworkStateRequest {
    return GetNetworkStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNetworkStateRequest>, I>>(_: I): GetNetworkStateRequest {
    const message = createBaseGetNetworkStateRequest();
    return message;
  },
};

function createBaseGetNetworkStateResponse(): GetNetworkStateResponse {
  return {
    metadata: undefined,
    initialSyncAchieved: false,
    baseNodeState: 0,
    failedCheckpoints: false,
    reward: Long.UZERO,
    sha3xEstimatedHashRate: Long.UZERO,
    moneroRandomxEstimatedHashRate: Long.UZERO,
    tariRandomxEstimatedHashRate: Long.UZERO,
    numConnections: Long.UZERO,
    livenessResults: [],
    readinessStatus: undefined,
  };
}

export const GetNetworkStateResponse: MessageFns<GetNetworkStateResponse> = {
  encode(message: GetNetworkStateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      MetaData.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.initialSyncAchieved !== false) {
      writer.uint32(16).bool(message.initialSyncAchieved);
    }
    if (message.baseNodeState !== 0) {
      writer.uint32(24).int32(message.baseNodeState);
    }
    if (message.failedCheckpoints !== false) {
      writer.uint32(32).bool(message.failedCheckpoints);
    }
    if (!message.reward.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.reward.toString());
    }
    if (!message.sha3xEstimatedHashRate.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.sha3xEstimatedHashRate.toString());
    }
    if (!message.moneroRandomxEstimatedHashRate.equals(Long.UZERO)) {
      writer.uint32(56).uint64(message.moneroRandomxEstimatedHashRate.toString());
    }
    if (!message.tariRandomxEstimatedHashRate.equals(Long.UZERO)) {
      writer.uint32(80).uint64(message.tariRandomxEstimatedHashRate.toString());
    }
    if (!message.numConnections.equals(Long.UZERO)) {
      writer.uint32(64).uint64(message.numConnections.toString());
    }
    for (const v of message.livenessResults) {
      LivenessResult.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.readinessStatus !== undefined) {
      ReadinessStatus.encode(message.readinessStatus, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNetworkStateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNetworkStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = MetaData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.initialSyncAchieved = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.baseNodeState = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.failedCheckpoints = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.reward = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sha3xEstimatedHashRate = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.moneroRandomxEstimatedHashRate = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.tariRandomxEstimatedHashRate = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.numConnections = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.livenessResults.push(LivenessResult.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.readinessStatus = ReadinessStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNetworkStateResponse {
    return {
      metadata: isSet(object.metadata) ? MetaData.fromJSON(object.metadata) : undefined,
      initialSyncAchieved: isSet(object.initialSyncAchieved) ? globalThis.Boolean(object.initialSyncAchieved) : false,
      baseNodeState: isSet(object.baseNodeState) ? baseNodeStateFromJSON(object.baseNodeState) : 0,
      failedCheckpoints: isSet(object.failedCheckpoints) ? globalThis.Boolean(object.failedCheckpoints) : false,
      reward: isSet(object.reward) ? Long.fromValue(object.reward) : Long.UZERO,
      sha3xEstimatedHashRate: isSet(object.sha3xEstimatedHashRate)
        ? Long.fromValue(object.sha3xEstimatedHashRate)
        : Long.UZERO,
      moneroRandomxEstimatedHashRate: isSet(object.moneroRandomxEstimatedHashRate)
        ? Long.fromValue(object.moneroRandomxEstimatedHashRate)
        : Long.UZERO,
      tariRandomxEstimatedHashRate: isSet(object.tariRandomxEstimatedHashRate)
        ? Long.fromValue(object.tariRandomxEstimatedHashRate)
        : Long.UZERO,
      numConnections: isSet(object.numConnections) ? Long.fromValue(object.numConnections) : Long.UZERO,
      livenessResults: globalThis.Array.isArray(object?.livenessResults)
        ? object.livenessResults.map((e: any) => LivenessResult.fromJSON(e))
        : [],
      readinessStatus: isSet(object.readinessStatus) ? ReadinessStatus.fromJSON(object.readinessStatus) : undefined,
    };
  },

  toJSON(message: GetNetworkStateResponse): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = MetaData.toJSON(message.metadata);
    }
    if (message.initialSyncAchieved !== false) {
      obj.initialSyncAchieved = message.initialSyncAchieved;
    }
    if (message.baseNodeState !== 0) {
      obj.baseNodeState = baseNodeStateToJSON(message.baseNodeState);
    }
    if (message.failedCheckpoints !== false) {
      obj.failedCheckpoints = message.failedCheckpoints;
    }
    if (!message.reward.equals(Long.UZERO)) {
      obj.reward = (message.reward || Long.UZERO).toString();
    }
    if (!message.sha3xEstimatedHashRate.equals(Long.UZERO)) {
      obj.sha3xEstimatedHashRate = (message.sha3xEstimatedHashRate || Long.UZERO).toString();
    }
    if (!message.moneroRandomxEstimatedHashRate.equals(Long.UZERO)) {
      obj.moneroRandomxEstimatedHashRate = (message.moneroRandomxEstimatedHashRate || Long.UZERO).toString();
    }
    if (!message.tariRandomxEstimatedHashRate.equals(Long.UZERO)) {
      obj.tariRandomxEstimatedHashRate = (message.tariRandomxEstimatedHashRate || Long.UZERO).toString();
    }
    if (!message.numConnections.equals(Long.UZERO)) {
      obj.numConnections = (message.numConnections || Long.UZERO).toString();
    }
    if (message.livenessResults?.length) {
      obj.livenessResults = message.livenessResults.map((e) => LivenessResult.toJSON(e));
    }
    if (message.readinessStatus !== undefined) {
      obj.readinessStatus = ReadinessStatus.toJSON(message.readinessStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNetworkStateResponse>, I>>(base?: I): GetNetworkStateResponse {
    return GetNetworkStateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNetworkStateResponse>, I>>(object: I): GetNetworkStateResponse {
    const message = createBaseGetNetworkStateResponse();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? MetaData.fromPartial(object.metadata)
      : undefined;
    message.initialSyncAchieved = object.initialSyncAchieved ?? false;
    message.baseNodeState = object.baseNodeState ?? 0;
    message.failedCheckpoints = object.failedCheckpoints ?? false;
    message.reward = (object.reward !== undefined && object.reward !== null)
      ? Long.fromValue(object.reward)
      : Long.UZERO;
    message.sha3xEstimatedHashRate =
      (object.sha3xEstimatedHashRate !== undefined && object.sha3xEstimatedHashRate !== null)
        ? Long.fromValue(object.sha3xEstimatedHashRate)
        : Long.UZERO;
    message.moneroRandomxEstimatedHashRate =
      (object.moneroRandomxEstimatedHashRate !== undefined && object.moneroRandomxEstimatedHashRate !== null)
        ? Long.fromValue(object.moneroRandomxEstimatedHashRate)
        : Long.UZERO;
    message.tariRandomxEstimatedHashRate =
      (object.tariRandomxEstimatedHashRate !== undefined && object.tariRandomxEstimatedHashRate !== null)
        ? Long.fromValue(object.tariRandomxEstimatedHashRate)
        : Long.UZERO;
    message.numConnections = (object.numConnections !== undefined && object.numConnections !== null)
      ? Long.fromValue(object.numConnections)
      : Long.UZERO;
    message.livenessResults = object.livenessResults?.map((e) => LivenessResult.fromPartial(e)) || [];
    message.readinessStatus = (object.readinessStatus !== undefined && object.readinessStatus !== null)
      ? ReadinessStatus.fromPartial(object.readinessStatus)
      : undefined;
    return message;
  },
};

function createBaseLivenessResult(): LivenessResult {
  return { peerNodeId: new Uint8Array(0), discoverLatency: Long.UZERO, pingLatency: Long.UZERO };
}

export const LivenessResult: MessageFns<LivenessResult> = {
  encode(message: LivenessResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peerNodeId.length !== 0) {
      writer.uint32(10).bytes(message.peerNodeId);
    }
    if (!message.discoverLatency.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.discoverLatency.toString());
    }
    if (!message.pingLatency.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.pingLatency.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LivenessResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLivenessResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peerNodeId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.discoverLatency = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pingLatency = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LivenessResult {
    return {
      peerNodeId: isSet(object.peerNodeId) ? bytesFromBase64(object.peerNodeId) : new Uint8Array(0),
      discoverLatency: isSet(object.discoverLatency) ? Long.fromValue(object.discoverLatency) : Long.UZERO,
      pingLatency: isSet(object.pingLatency) ? Long.fromValue(object.pingLatency) : Long.UZERO,
    };
  },

  toJSON(message: LivenessResult): unknown {
    const obj: any = {};
    if (message.peerNodeId.length !== 0) {
      obj.peerNodeId = base64FromBytes(message.peerNodeId);
    }
    if (!message.discoverLatency.equals(Long.UZERO)) {
      obj.discoverLatency = (message.discoverLatency || Long.UZERO).toString();
    }
    if (!message.pingLatency.equals(Long.UZERO)) {
      obj.pingLatency = (message.pingLatency || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LivenessResult>, I>>(base?: I): LivenessResult {
    return LivenessResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LivenessResult>, I>>(object: I): LivenessResult {
    const message = createBaseLivenessResult();
    message.peerNodeId = object.peerNodeId ?? new Uint8Array(0);
    message.discoverLatency = (object.discoverLatency !== undefined && object.discoverLatency !== null)
      ? Long.fromValue(object.discoverLatency)
      : Long.UZERO;
    message.pingLatency = (object.pingLatency !== undefined && object.pingLatency !== null)
      ? Long.fromValue(object.pingLatency)
      : Long.UZERO;
    return message;
  },
};

function createBaseSearchPaymentReferencesRequest(): SearchPaymentReferencesRequest {
  return { paymentReferenceHex: [], paymentReferenceBytes: [], includeSpent: false };
}

export const SearchPaymentReferencesRequest: MessageFns<SearchPaymentReferencesRequest> = {
  encode(message: SearchPaymentReferencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.paymentReferenceHex) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.paymentReferenceBytes) {
      writer.uint32(18).bytes(v!);
    }
    if (message.includeSpent !== false) {
      writer.uint32(24).bool(message.includeSpent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchPaymentReferencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchPaymentReferencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentReferenceHex.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentReferenceBytes.push(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeSpent = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchPaymentReferencesRequest {
    return {
      paymentReferenceHex: globalThis.Array.isArray(object?.paymentReferenceHex)
        ? object.paymentReferenceHex.map((e: any) => globalThis.String(e))
        : [],
      paymentReferenceBytes: globalThis.Array.isArray(object?.paymentReferenceBytes)
        ? object.paymentReferenceBytes.map((e: any) => bytesFromBase64(e))
        : [],
      includeSpent: isSet(object.includeSpent) ? globalThis.Boolean(object.includeSpent) : false,
    };
  },

  toJSON(message: SearchPaymentReferencesRequest): unknown {
    const obj: any = {};
    if (message.paymentReferenceHex?.length) {
      obj.paymentReferenceHex = message.paymentReferenceHex;
    }
    if (message.paymentReferenceBytes?.length) {
      obj.paymentReferenceBytes = message.paymentReferenceBytes.map((e) => base64FromBytes(e));
    }
    if (message.includeSpent !== false) {
      obj.includeSpent = message.includeSpent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchPaymentReferencesRequest>, I>>(base?: I): SearchPaymentReferencesRequest {
    return SearchPaymentReferencesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchPaymentReferencesRequest>, I>>(
    object: I,
  ): SearchPaymentReferencesRequest {
    const message = createBaseSearchPaymentReferencesRequest();
    message.paymentReferenceHex = object.paymentReferenceHex?.map((e) => e) || [];
    message.paymentReferenceBytes = object.paymentReferenceBytes?.map((e) => e) || [];
    message.includeSpent = object.includeSpent ?? false;
    return message;
  },
};

function createBasePaymentReferenceResponse(): PaymentReferenceResponse {
  return {
    paymentReferenceHex: "",
    blockHeight: Long.UZERO,
    blockHash: new Uint8Array(0),
    minedTimestamp: Long.UZERO,
    commitment: new Uint8Array(0),
    isSpent: false,
    spentHeight: Long.UZERO,
    spentBlockHash: new Uint8Array(0),
    minValuePromise: Long.UZERO,
    spentTimestamp: Long.UZERO,
    outputHash: new Uint8Array(0),
  };
}

export const PaymentReferenceResponse: MessageFns<PaymentReferenceResponse> = {
  encode(message: PaymentReferenceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentReferenceHex !== "") {
      writer.uint32(10).string(message.paymentReferenceHex);
    }
    if (!message.blockHeight.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.blockHeight.toString());
    }
    if (message.blockHash.length !== 0) {
      writer.uint32(26).bytes(message.blockHash);
    }
    if (!message.minedTimestamp.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.minedTimestamp.toString());
    }
    if (message.commitment.length !== 0) {
      writer.uint32(42).bytes(message.commitment);
    }
    if (message.isSpent !== false) {
      writer.uint32(48).bool(message.isSpent);
    }
    if (!message.spentHeight.equals(Long.UZERO)) {
      writer.uint32(56).uint64(message.spentHeight.toString());
    }
    if (message.spentBlockHash.length !== 0) {
      writer.uint32(66).bytes(message.spentBlockHash);
    }
    if (!message.minValuePromise.equals(Long.UZERO)) {
      writer.uint32(72).uint64(message.minValuePromise.toString());
    }
    if (!message.spentTimestamp.equals(Long.UZERO)) {
      writer.uint32(80).uint64(message.spentTimestamp.toString());
    }
    if (message.outputHash.length !== 0) {
      writer.uint32(90).bytes(message.outputHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentReferenceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentReferenceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentReferenceHex = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blockHash = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.minedTimestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.commitment = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isSpent = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.spentHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.spentBlockHash = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.minValuePromise = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.spentTimestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.outputHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentReferenceResponse {
    return {
      paymentReferenceHex: isSet(object.paymentReferenceHex) ? globalThis.String(object.paymentReferenceHex) : "",
      blockHeight: isSet(object.blockHeight) ? Long.fromValue(object.blockHeight) : Long.UZERO,
      blockHash: isSet(object.blockHash) ? bytesFromBase64(object.blockHash) : new Uint8Array(0),
      minedTimestamp: isSet(object.minedTimestamp) ? Long.fromValue(object.minedTimestamp) : Long.UZERO,
      commitment: isSet(object.commitment) ? bytesFromBase64(object.commitment) : new Uint8Array(0),
      isSpent: isSet(object.isSpent) ? globalThis.Boolean(object.isSpent) : false,
      spentHeight: isSet(object.spentHeight) ? Long.fromValue(object.spentHeight) : Long.UZERO,
      spentBlockHash: isSet(object.spentBlockHash) ? bytesFromBase64(object.spentBlockHash) : new Uint8Array(0),
      minValuePromise: isSet(object.minValuePromise) ? Long.fromValue(object.minValuePromise) : Long.UZERO,
      spentTimestamp: isSet(object.spentTimestamp) ? Long.fromValue(object.spentTimestamp) : Long.UZERO,
      outputHash: isSet(object.outputHash) ? bytesFromBase64(object.outputHash) : new Uint8Array(0),
    };
  },

  toJSON(message: PaymentReferenceResponse): unknown {
    const obj: any = {};
    if (message.paymentReferenceHex !== "") {
      obj.paymentReferenceHex = message.paymentReferenceHex;
    }
    if (!message.blockHeight.equals(Long.UZERO)) {
      obj.blockHeight = (message.blockHeight || Long.UZERO).toString();
    }
    if (message.blockHash.length !== 0) {
      obj.blockHash = base64FromBytes(message.blockHash);
    }
    if (!message.minedTimestamp.equals(Long.UZERO)) {
      obj.minedTimestamp = (message.minedTimestamp || Long.UZERO).toString();
    }
    if (message.commitment.length !== 0) {
      obj.commitment = base64FromBytes(message.commitment);
    }
    if (message.isSpent !== false) {
      obj.isSpent = message.isSpent;
    }
    if (!message.spentHeight.equals(Long.UZERO)) {
      obj.spentHeight = (message.spentHeight || Long.UZERO).toString();
    }
    if (message.spentBlockHash.length !== 0) {
      obj.spentBlockHash = base64FromBytes(message.spentBlockHash);
    }
    if (!message.minValuePromise.equals(Long.UZERO)) {
      obj.minValuePromise = (message.minValuePromise || Long.UZERO).toString();
    }
    if (!message.spentTimestamp.equals(Long.UZERO)) {
      obj.spentTimestamp = (message.spentTimestamp || Long.UZERO).toString();
    }
    if (message.outputHash.length !== 0) {
      obj.outputHash = base64FromBytes(message.outputHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentReferenceResponse>, I>>(base?: I): PaymentReferenceResponse {
    return PaymentReferenceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentReferenceResponse>, I>>(object: I): PaymentReferenceResponse {
    const message = createBasePaymentReferenceResponse();
    message.paymentReferenceHex = object.paymentReferenceHex ?? "";
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.UZERO;
    message.blockHash = object.blockHash ?? new Uint8Array(0);
    message.minedTimestamp = (object.minedTimestamp !== undefined && object.minedTimestamp !== null)
      ? Long.fromValue(object.minedTimestamp)
      : Long.UZERO;
    message.commitment = object.commitment ?? new Uint8Array(0);
    message.isSpent = object.isSpent ?? false;
    message.spentHeight = (object.spentHeight !== undefined && object.spentHeight !== null)
      ? Long.fromValue(object.spentHeight)
      : Long.UZERO;
    message.spentBlockHash = object.spentBlockHash ?? new Uint8Array(0);
    message.minValuePromise = (object.minValuePromise !== undefined && object.minValuePromise !== null)
      ? Long.fromValue(object.minValuePromise)
      : Long.UZERO;
    message.spentTimestamp = (object.spentTimestamp !== undefined && object.spentTimestamp !== null)
      ? Long.fromValue(object.spentTimestamp)
      : Long.UZERO;
    message.outputHash = object.outputHash ?? new Uint8Array(0);
    return message;
  },
};

/** The gRPC interface for interacting with the base node. */
export type BaseNodeService = typeof BaseNodeService;
export const BaseNodeService = {
  /** Lists headers in the current best chain */
  listHeaders: {
    path: "/tari.rpc.BaseNode/ListHeaders",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ListHeadersRequest) => Buffer.from(ListHeadersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListHeadersRequest.decode(value),
    responseSerialize: (value: BlockHeaderResponse) => Buffer.from(BlockHeaderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockHeaderResponse.decode(value),
  },
  /** Get header by hash */
  getHeaderByHash: {
    path: "/tari.rpc.BaseNode/GetHeaderByHash",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetHeaderByHashRequest) => Buffer.from(GetHeaderByHashRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetHeaderByHashRequest.decode(value),
    responseSerialize: (value: BlockHeaderResponse) => Buffer.from(BlockHeaderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockHeaderResponse.decode(value),
  },
  /** Returns blocks in the current best chain. Currently only supports querying by height */
  getBlocks: {
    path: "/tari.rpc.BaseNode/GetBlocks",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: GetBlocksRequest) => Buffer.from(GetBlocksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetBlocksRequest.decode(value),
    responseSerialize: (value: HistoricalBlock) => Buffer.from(HistoricalBlock.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HistoricalBlock.decode(value),
  },
  /** Returns the block timing for the chain heights */
  getBlockTiming: {
    path: "/tari.rpc.BaseNode/GetBlockTiming",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HeightRequest) => Buffer.from(HeightRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HeightRequest.decode(value),
    responseSerialize: (value: BlockTimingResponse) => Buffer.from(BlockTimingResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockTimingResponse.decode(value),
  },
  /** Returns the network Constants */
  getConstants: {
    path: "/tari.rpc.BaseNode/GetConstants",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BlockHeight) => Buffer.from(BlockHeight.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BlockHeight.decode(value),
    responseSerialize: (value: ConsensusConstants) => Buffer.from(ConsensusConstants.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ConsensusConstants.decode(value),
  },
  /** Returns Block Sizes */
  getBlockSize: {
    path: "/tari.rpc.BaseNode/GetBlockSize",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BlockGroupRequest) => Buffer.from(BlockGroupRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BlockGroupRequest.decode(value),
    responseSerialize: (value: BlockGroupResponse) => Buffer.from(BlockGroupResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockGroupResponse.decode(value),
  },
  /** Returns Block Fees */
  getBlockFees: {
    path: "/tari.rpc.BaseNode/GetBlockFees",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BlockGroupRequest) => Buffer.from(BlockGroupRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BlockGroupRequest.decode(value),
    responseSerialize: (value: BlockGroupResponse) => Buffer.from(BlockGroupResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockGroupResponse.decode(value),
  },
  /** Get Version */
  getVersion: {
    path: "/tari.rpc.BaseNode/GetVersion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: BaseNodeGetVersionResponse) =>
      Buffer.from(BaseNodeGetVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BaseNodeGetVersionResponse.decode(value),
  },
  /** Check for new updates */
  checkForUpdates: {
    path: "/tari.rpc.BaseNode/CheckForUpdates",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: SoftwareUpdate) => Buffer.from(SoftwareUpdate.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SoftwareUpdate.decode(value),
  },
  /** Get coins in circulation */
  getTokensInCirculation: {
    path: "/tari.rpc.BaseNode/GetTokensInCirculation",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: GetBlocksRequest) => Buffer.from(GetBlocksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetBlocksRequest.decode(value),
    responseSerialize: (value: ValueAtHeightResponse) => Buffer.from(ValueAtHeightResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ValueAtHeightResponse.decode(value),
  },
  /** Get network difficulties */
  getNetworkDifficulty: {
    path: "/tari.rpc.BaseNode/GetNetworkDifficulty",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: HeightRequest) => Buffer.from(HeightRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HeightRequest.decode(value),
    responseSerialize: (value: NetworkDifficultyResponse) =>
      Buffer.from(NetworkDifficultyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NetworkDifficultyResponse.decode(value),
  },
  /** Get the block template */
  getNewBlockTemplate: {
    path: "/tari.rpc.BaseNode/GetNewBlockTemplate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NewBlockTemplateRequest) => Buffer.from(NewBlockTemplateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NewBlockTemplateRequest.decode(value),
    responseSerialize: (value: NewBlockTemplateResponse) =>
      Buffer.from(NewBlockTemplateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NewBlockTemplateResponse.decode(value),
  },
  /** Construct a new block from a provided template */
  getNewBlock: {
    path: "/tari.rpc.BaseNode/GetNewBlock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NewBlockTemplate) => Buffer.from(NewBlockTemplate.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NewBlockTemplate.decode(value),
    responseSerialize: (value: GetNewBlockResult) => Buffer.from(GetNewBlockResult.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetNewBlockResult.decode(value),
  },
  /** Construct a new block from a provided template */
  getNewBlockWithCoinbases: {
    path: "/tari.rpc.BaseNode/GetNewBlockWithCoinbases",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNewBlockWithCoinbasesRequest) =>
      Buffer.from(GetNewBlockWithCoinbasesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetNewBlockWithCoinbasesRequest.decode(value),
    responseSerialize: (value: GetNewBlockResult) => Buffer.from(GetNewBlockResult.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetNewBlockResult.decode(value),
  },
  /** Construct a new block from a provided template */
  getNewBlockTemplateWithCoinbases: {
    path: "/tari.rpc.BaseNode/GetNewBlockTemplateWithCoinbases",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNewBlockTemplateWithCoinbasesRequest) =>
      Buffer.from(GetNewBlockTemplateWithCoinbasesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetNewBlockTemplateWithCoinbasesRequest.decode(value),
    responseSerialize: (value: GetNewBlockResult) => Buffer.from(GetNewBlockResult.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetNewBlockResult.decode(value),
  },
  /** Construct a new block and header blob from a provided template */
  getNewBlockBlob: {
    path: "/tari.rpc.BaseNode/GetNewBlockBlob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NewBlockTemplate) => Buffer.from(NewBlockTemplate.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NewBlockTemplate.decode(value),
    responseSerialize: (value: GetNewBlockBlobResult) => Buffer.from(GetNewBlockBlobResult.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetNewBlockBlobResult.decode(value),
  },
  /** Submit a new block for propagation */
  submitBlock: {
    path: "/tari.rpc.BaseNode/SubmitBlock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Block) => Buffer.from(Block.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Block.decode(value),
    responseSerialize: (value: SubmitBlockResponse) => Buffer.from(SubmitBlockResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SubmitBlockResponse.decode(value),
  },
  /** Submit a new mined block blob for propagation */
  submitBlockBlob: {
    path: "/tari.rpc.BaseNode/SubmitBlockBlob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BlockBlobRequest) => Buffer.from(BlockBlobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BlockBlobRequest.decode(value),
    responseSerialize: (value: SubmitBlockResponse) => Buffer.from(SubmitBlockResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SubmitBlockResponse.decode(value),
  },
  /** Submit a transaction for propagation */
  submitTransaction: {
    path: "/tari.rpc.BaseNode/SubmitTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SubmitTransactionRequest) => Buffer.from(SubmitTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SubmitTransactionRequest.decode(value),
    responseSerialize: (value: SubmitTransactionResponse) =>
      Buffer.from(SubmitTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SubmitTransactionResponse.decode(value),
  },
  /** Get the base node sync information */
  getSyncInfo: {
    path: "/tari.rpc.BaseNode/GetSyncInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: SyncInfoResponse) => Buffer.from(SyncInfoResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SyncInfoResponse.decode(value),
  },
  /** Get the base node sync information */
  getSyncProgress: {
    path: "/tari.rpc.BaseNode/GetSyncProgress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: SyncProgressResponse) => Buffer.from(SyncProgressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SyncProgressResponse.decode(value),
  },
  /** Get the base node tip information */
  getTipInfo: {
    path: "/tari.rpc.BaseNode/GetTipInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: TipInfoResponse) => Buffer.from(TipInfoResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TipInfoResponse.decode(value),
  },
  /** Search for blocks containing the specified kernels */
  searchKernels: {
    path: "/tari.rpc.BaseNode/SearchKernels",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SearchKernelsRequest) => Buffer.from(SearchKernelsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SearchKernelsRequest.decode(value),
    responseSerialize: (value: HistoricalBlock) => Buffer.from(HistoricalBlock.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HistoricalBlock.decode(value),
  },
  /** Search for blocks containing the specified commitments */
  searchUtxos: {
    path: "/tari.rpc.BaseNode/SearchUtxos",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SearchUtxosRequest) => Buffer.from(SearchUtxosRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SearchUtxosRequest.decode(value),
    responseSerialize: (value: HistoricalBlock) => Buffer.from(HistoricalBlock.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HistoricalBlock.decode(value),
  },
  /** Fetch any utxos that exist in the main chain */
  fetchMatchingUtxos: {
    path: "/tari.rpc.BaseNode/FetchMatchingUtxos",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: FetchMatchingUtxosRequest) =>
      Buffer.from(FetchMatchingUtxosRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FetchMatchingUtxosRequest.decode(value),
    responseSerialize: (value: FetchMatchingUtxosResponse) =>
      Buffer.from(FetchMatchingUtxosResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => FetchMatchingUtxosResponse.decode(value),
  },
  /** get all peers from the base node */
  getPeers: {
    path: "/tari.rpc.BaseNode/GetPeers",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: GetPeersRequest) => Buffer.from(GetPeersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPeersRequest.decode(value),
    responseSerialize: (value: GetPeersResponse) => Buffer.from(GetPeersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetPeersResponse.decode(value),
  },
  getMempoolTransactions: {
    path: "/tari.rpc.BaseNode/GetMempoolTransactions",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: GetMempoolTransactionsRequest) =>
      Buffer.from(GetMempoolTransactionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetMempoolTransactionsRequest.decode(value),
    responseSerialize: (value: GetMempoolTransactionsResponse) =>
      Buffer.from(GetMempoolTransactionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetMempoolTransactionsResponse.decode(value),
  },
  transactionState: {
    path: "/tari.rpc.BaseNode/TransactionState",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TransactionStateRequest) => Buffer.from(TransactionStateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TransactionStateRequest.decode(value),
    responseSerialize: (value: TransactionStateResponse) =>
      Buffer.from(TransactionStateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionStateResponse.decode(value),
  },
  /** This returns the node's network identity */
  identify: {
    path: "/tari.rpc.BaseNode/Identify",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: NodeIdentity) => Buffer.from(NodeIdentity.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NodeIdentity.decode(value),
  },
  /** Get Base Node network connectivity status */
  getNetworkStatus: {
    path: "/tari.rpc.BaseNode/GetNetworkStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: NetworkStatusResponse) => Buffer.from(NetworkStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NetworkStatusResponse.decode(value),
  },
  /** List currently connected peers */
  listConnectedPeers: {
    path: "/tari.rpc.BaseNode/ListConnectedPeers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: ListConnectedPeersResponse) =>
      Buffer.from(ListConnectedPeersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListConnectedPeersResponse.decode(value),
  },
  /** Get mempool stats */
  getMempoolStats: {
    path: "/tari.rpc.BaseNode/GetMempoolStats",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: MempoolStatsResponse) => Buffer.from(MempoolStatsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MempoolStatsResponse.decode(value),
  },
  /** Get VNs */
  getActiveValidatorNodes: {
    path: "/tari.rpc.BaseNode/GetActiveValidatorNodes",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: GetActiveValidatorNodesRequest) =>
      Buffer.from(GetActiveValidatorNodesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetActiveValidatorNodesRequest.decode(value),
    responseSerialize: (value: GetActiveValidatorNodesResponse) =>
      Buffer.from(GetActiveValidatorNodesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetActiveValidatorNodesResponse.decode(value),
  },
  getValidatorNodeChanges: {
    path: "/tari.rpc.BaseNode/GetValidatorNodeChanges",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetValidatorNodeChangesRequest) =>
      Buffer.from(GetValidatorNodeChangesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetValidatorNodeChangesRequest.decode(value),
    responseSerialize: (value: GetValidatorNodeChangesResponse) =>
      Buffer.from(GetValidatorNodeChangesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetValidatorNodeChangesResponse.decode(value),
  },
  getShardKey: {
    path: "/tari.rpc.BaseNode/GetShardKey",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetShardKeyRequest) => Buffer.from(GetShardKeyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetShardKeyRequest.decode(value),
    responseSerialize: (value: GetShardKeyResponse) => Buffer.from(GetShardKeyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetShardKeyResponse.decode(value),
  },
  /** Get templates */
  getTemplateRegistrations: {
    path: "/tari.rpc.BaseNode/GetTemplateRegistrations",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: GetTemplateRegistrationsRequest) =>
      Buffer.from(GetTemplateRegistrationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTemplateRegistrationsRequest.decode(value),
    responseSerialize: (value: GetTemplateRegistrationResponse) =>
      Buffer.from(GetTemplateRegistrationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTemplateRegistrationResponse.decode(value),
  },
  getSideChainUtxos: {
    path: "/tari.rpc.BaseNode/GetSideChainUtxos",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: GetSideChainUtxosRequest) => Buffer.from(GetSideChainUtxosRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetSideChainUtxosRequest.decode(value),
    responseSerialize: (value: GetSideChainUtxosResponse) =>
      Buffer.from(GetSideChainUtxosResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetSideChainUtxosResponse.decode(value),
  },
  getNetworkState: {
    path: "/tari.rpc.BaseNode/GetNetworkState",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNetworkStateRequest) => Buffer.from(GetNetworkStateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetNetworkStateRequest.decode(value),
    responseSerialize: (value: GetNetworkStateResponse) => Buffer.from(GetNetworkStateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetNetworkStateResponse.decode(value),
  },
  /** PayRef (Payment Reference) lookup for block explorers and external services */
  searchPaymentReferences: {
    path: "/tari.rpc.BaseNode/SearchPaymentReferences",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SearchPaymentReferencesRequest) =>
      Buffer.from(SearchPaymentReferencesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SearchPaymentReferencesRequest.decode(value),
    responseSerialize: (value: PaymentReferenceResponse) =>
      Buffer.from(PaymentReferenceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentReferenceResponse.decode(value),
  },
  /** PayRef (Payment Reference) lookup for block explorers and external services via output hash */
  searchPaymentReferencesViaOutputHash: {
    path: "/tari.rpc.BaseNode/SearchPaymentReferencesViaOutputHash",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: FetchMatchingUtxosRequest) =>
      Buffer.from(FetchMatchingUtxosRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FetchMatchingUtxosRequest.decode(value),
    responseSerialize: (value: PaymentReferenceResponse) =>
      Buffer.from(PaymentReferenceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentReferenceResponse.decode(value),
  },
} as const;

export interface BaseNodeServer extends UntypedServiceImplementation {
  /** Lists headers in the current best chain */
  listHeaders: handleServerStreamingCall<ListHeadersRequest, BlockHeaderResponse>;
  /** Get header by hash */
  getHeaderByHash: handleUnaryCall<GetHeaderByHashRequest, BlockHeaderResponse>;
  /** Returns blocks in the current best chain. Currently only supports querying by height */
  getBlocks: handleServerStreamingCall<GetBlocksRequest, HistoricalBlock>;
  /** Returns the block timing for the chain heights */
  getBlockTiming: handleUnaryCall<HeightRequest, BlockTimingResponse>;
  /** Returns the network Constants */
  getConstants: handleUnaryCall<BlockHeight, ConsensusConstants>;
  /** Returns Block Sizes */
  getBlockSize: handleUnaryCall<BlockGroupRequest, BlockGroupResponse>;
  /** Returns Block Fees */
  getBlockFees: handleUnaryCall<BlockGroupRequest, BlockGroupResponse>;
  /** Get Version */
  getVersion: handleUnaryCall<Empty, BaseNodeGetVersionResponse>;
  /** Check for new updates */
  checkForUpdates: handleUnaryCall<Empty, SoftwareUpdate>;
  /** Get coins in circulation */
  getTokensInCirculation: handleServerStreamingCall<GetBlocksRequest, ValueAtHeightResponse>;
  /** Get network difficulties */
  getNetworkDifficulty: handleServerStreamingCall<HeightRequest, NetworkDifficultyResponse>;
  /** Get the block template */
  getNewBlockTemplate: handleUnaryCall<NewBlockTemplateRequest, NewBlockTemplateResponse>;
  /** Construct a new block from a provided template */
  getNewBlock: handleUnaryCall<NewBlockTemplate, GetNewBlockResult>;
  /** Construct a new block from a provided template */
  getNewBlockWithCoinbases: handleUnaryCall<GetNewBlockWithCoinbasesRequest, GetNewBlockResult>;
  /** Construct a new block from a provided template */
  getNewBlockTemplateWithCoinbases: handleUnaryCall<GetNewBlockTemplateWithCoinbasesRequest, GetNewBlockResult>;
  /** Construct a new block and header blob from a provided template */
  getNewBlockBlob: handleUnaryCall<NewBlockTemplate, GetNewBlockBlobResult>;
  /** Submit a new block for propagation */
  submitBlock: handleUnaryCall<Block, SubmitBlockResponse>;
  /** Submit a new mined block blob for propagation */
  submitBlockBlob: handleUnaryCall<BlockBlobRequest, SubmitBlockResponse>;
  /** Submit a transaction for propagation */
  submitTransaction: handleUnaryCall<SubmitTransactionRequest, SubmitTransactionResponse>;
  /** Get the base node sync information */
  getSyncInfo: handleUnaryCall<Empty, SyncInfoResponse>;
  /** Get the base node sync information */
  getSyncProgress: handleUnaryCall<Empty, SyncProgressResponse>;
  /** Get the base node tip information */
  getTipInfo: handleUnaryCall<Empty, TipInfoResponse>;
  /** Search for blocks containing the specified kernels */
  searchKernels: handleServerStreamingCall<SearchKernelsRequest, HistoricalBlock>;
  /** Search for blocks containing the specified commitments */
  searchUtxos: handleServerStreamingCall<SearchUtxosRequest, HistoricalBlock>;
  /** Fetch any utxos that exist in the main chain */
  fetchMatchingUtxos: handleServerStreamingCall<FetchMatchingUtxosRequest, FetchMatchingUtxosResponse>;
  /** get all peers from the base node */
  getPeers: handleServerStreamingCall<GetPeersRequest, GetPeersResponse>;
  getMempoolTransactions: handleServerStreamingCall<GetMempoolTransactionsRequest, GetMempoolTransactionsResponse>;
  transactionState: handleUnaryCall<TransactionStateRequest, TransactionStateResponse>;
  /** This returns the node's network identity */
  identify: handleUnaryCall<Empty, NodeIdentity>;
  /** Get Base Node network connectivity status */
  getNetworkStatus: handleUnaryCall<Empty, NetworkStatusResponse>;
  /** List currently connected peers */
  listConnectedPeers: handleUnaryCall<Empty, ListConnectedPeersResponse>;
  /** Get mempool stats */
  getMempoolStats: handleUnaryCall<Empty, MempoolStatsResponse>;
  /** Get VNs */
  getActiveValidatorNodes: handleServerStreamingCall<GetActiveValidatorNodesRequest, GetActiveValidatorNodesResponse>;
  getValidatorNodeChanges: handleUnaryCall<GetValidatorNodeChangesRequest, GetValidatorNodeChangesResponse>;
  getShardKey: handleUnaryCall<GetShardKeyRequest, GetShardKeyResponse>;
  /** Get templates */
  getTemplateRegistrations: handleServerStreamingCall<GetTemplateRegistrationsRequest, GetTemplateRegistrationResponse>;
  getSideChainUtxos: handleServerStreamingCall<GetSideChainUtxosRequest, GetSideChainUtxosResponse>;
  getNetworkState: handleUnaryCall<GetNetworkStateRequest, GetNetworkStateResponse>;
  /** PayRef (Payment Reference) lookup for block explorers and external services */
  searchPaymentReferences: handleServerStreamingCall<SearchPaymentReferencesRequest, PaymentReferenceResponse>;
  /** PayRef (Payment Reference) lookup for block explorers and external services via output hash */
  searchPaymentReferencesViaOutputHash: handleServerStreamingCall<FetchMatchingUtxosRequest, PaymentReferenceResponse>;
}

export interface BaseNodeClient extends Client {
  /** Lists headers in the current best chain */
  listHeaders(request: ListHeadersRequest, options?: Partial<CallOptions>): ClientReadableStream<BlockHeaderResponse>;
  listHeaders(
    request: ListHeadersRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<BlockHeaderResponse>;
  /** Get header by hash */
  getHeaderByHash(
    request: GetHeaderByHashRequest,
    callback: (error: ServiceError | null, response: BlockHeaderResponse) => void,
  ): ClientUnaryCall;
  getHeaderByHash(
    request: GetHeaderByHashRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockHeaderResponse) => void,
  ): ClientUnaryCall;
  getHeaderByHash(
    request: GetHeaderByHashRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockHeaderResponse) => void,
  ): ClientUnaryCall;
  /** Returns blocks in the current best chain. Currently only supports querying by height */
  getBlocks(request: GetBlocksRequest, options?: Partial<CallOptions>): ClientReadableStream<HistoricalBlock>;
  getBlocks(
    request: GetBlocksRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<HistoricalBlock>;
  /** Returns the block timing for the chain heights */
  getBlockTiming(
    request: HeightRequest,
    callback: (error: ServiceError | null, response: BlockTimingResponse) => void,
  ): ClientUnaryCall;
  getBlockTiming(
    request: HeightRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockTimingResponse) => void,
  ): ClientUnaryCall;
  getBlockTiming(
    request: HeightRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockTimingResponse) => void,
  ): ClientUnaryCall;
  /** Returns the network Constants */
  getConstants(
    request: BlockHeight,
    callback: (error: ServiceError | null, response: ConsensusConstants) => void,
  ): ClientUnaryCall;
  getConstants(
    request: BlockHeight,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ConsensusConstants) => void,
  ): ClientUnaryCall;
  getConstants(
    request: BlockHeight,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ConsensusConstants) => void,
  ): ClientUnaryCall;
  /** Returns Block Sizes */
  getBlockSize(
    request: BlockGroupRequest,
    callback: (error: ServiceError | null, response: BlockGroupResponse) => void,
  ): ClientUnaryCall;
  getBlockSize(
    request: BlockGroupRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockGroupResponse) => void,
  ): ClientUnaryCall;
  getBlockSize(
    request: BlockGroupRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockGroupResponse) => void,
  ): ClientUnaryCall;
  /** Returns Block Fees */
  getBlockFees(
    request: BlockGroupRequest,
    callback: (error: ServiceError | null, response: BlockGroupResponse) => void,
  ): ClientUnaryCall;
  getBlockFees(
    request: BlockGroupRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockGroupResponse) => void,
  ): ClientUnaryCall;
  getBlockFees(
    request: BlockGroupRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockGroupResponse) => void,
  ): ClientUnaryCall;
  /** Get Version */
  getVersion(
    request: Empty,
    callback: (error: ServiceError | null, response: BaseNodeGetVersionResponse) => void,
  ): ClientUnaryCall;
  getVersion(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseNodeGetVersionResponse) => void,
  ): ClientUnaryCall;
  getVersion(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseNodeGetVersionResponse) => void,
  ): ClientUnaryCall;
  /** Check for new updates */
  checkForUpdates(
    request: Empty,
    callback: (error: ServiceError | null, response: SoftwareUpdate) => void,
  ): ClientUnaryCall;
  checkForUpdates(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SoftwareUpdate) => void,
  ): ClientUnaryCall;
  checkForUpdates(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SoftwareUpdate) => void,
  ): ClientUnaryCall;
  /** Get coins in circulation */
  getTokensInCirculation(
    request: GetBlocksRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ValueAtHeightResponse>;
  getTokensInCirculation(
    request: GetBlocksRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ValueAtHeightResponse>;
  /** Get network difficulties */
  getNetworkDifficulty(
    request: HeightRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<NetworkDifficultyResponse>;
  getNetworkDifficulty(
    request: HeightRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<NetworkDifficultyResponse>;
  /** Get the block template */
  getNewBlockTemplate(
    request: NewBlockTemplateRequest,
    callback: (error: ServiceError | null, response: NewBlockTemplateResponse) => void,
  ): ClientUnaryCall;
  getNewBlockTemplate(
    request: NewBlockTemplateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NewBlockTemplateResponse) => void,
  ): ClientUnaryCall;
  getNewBlockTemplate(
    request: NewBlockTemplateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NewBlockTemplateResponse) => void,
  ): ClientUnaryCall;
  /** Construct a new block from a provided template */
  getNewBlock(
    request: NewBlockTemplate,
    callback: (error: ServiceError | null, response: GetNewBlockResult) => void,
  ): ClientUnaryCall;
  getNewBlock(
    request: NewBlockTemplate,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetNewBlockResult) => void,
  ): ClientUnaryCall;
  getNewBlock(
    request: NewBlockTemplate,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetNewBlockResult) => void,
  ): ClientUnaryCall;
  /** Construct a new block from a provided template */
  getNewBlockWithCoinbases(
    request: GetNewBlockWithCoinbasesRequest,
    callback: (error: ServiceError | null, response: GetNewBlockResult) => void,
  ): ClientUnaryCall;
  getNewBlockWithCoinbases(
    request: GetNewBlockWithCoinbasesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetNewBlockResult) => void,
  ): ClientUnaryCall;
  getNewBlockWithCoinbases(
    request: GetNewBlockWithCoinbasesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetNewBlockResult) => void,
  ): ClientUnaryCall;
  /** Construct a new block from a provided template */
  getNewBlockTemplateWithCoinbases(
    request: GetNewBlockTemplateWithCoinbasesRequest,
    callback: (error: ServiceError | null, response: GetNewBlockResult) => void,
  ): ClientUnaryCall;
  getNewBlockTemplateWithCoinbases(
    request: GetNewBlockTemplateWithCoinbasesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetNewBlockResult) => void,
  ): ClientUnaryCall;
  getNewBlockTemplateWithCoinbases(
    request: GetNewBlockTemplateWithCoinbasesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetNewBlockResult) => void,
  ): ClientUnaryCall;
  /** Construct a new block and header blob from a provided template */
  getNewBlockBlob(
    request: NewBlockTemplate,
    callback: (error: ServiceError | null, response: GetNewBlockBlobResult) => void,
  ): ClientUnaryCall;
  getNewBlockBlob(
    request: NewBlockTemplate,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetNewBlockBlobResult) => void,
  ): ClientUnaryCall;
  getNewBlockBlob(
    request: NewBlockTemplate,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetNewBlockBlobResult) => void,
  ): ClientUnaryCall;
  /** Submit a new block for propagation */
  submitBlock(
    request: Block,
    callback: (error: ServiceError | null, response: SubmitBlockResponse) => void,
  ): ClientUnaryCall;
  submitBlock(
    request: Block,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SubmitBlockResponse) => void,
  ): ClientUnaryCall;
  submitBlock(
    request: Block,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SubmitBlockResponse) => void,
  ): ClientUnaryCall;
  /** Submit a new mined block blob for propagation */
  submitBlockBlob(
    request: BlockBlobRequest,
    callback: (error: ServiceError | null, response: SubmitBlockResponse) => void,
  ): ClientUnaryCall;
  submitBlockBlob(
    request: BlockBlobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SubmitBlockResponse) => void,
  ): ClientUnaryCall;
  submitBlockBlob(
    request: BlockBlobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SubmitBlockResponse) => void,
  ): ClientUnaryCall;
  /** Submit a transaction for propagation */
  submitTransaction(
    request: SubmitTransactionRequest,
    callback: (error: ServiceError | null, response: SubmitTransactionResponse) => void,
  ): ClientUnaryCall;
  submitTransaction(
    request: SubmitTransactionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SubmitTransactionResponse) => void,
  ): ClientUnaryCall;
  submitTransaction(
    request: SubmitTransactionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SubmitTransactionResponse) => void,
  ): ClientUnaryCall;
  /** Get the base node sync information */
  getSyncInfo(
    request: Empty,
    callback: (error: ServiceError | null, response: SyncInfoResponse) => void,
  ): ClientUnaryCall;
  getSyncInfo(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SyncInfoResponse) => void,
  ): ClientUnaryCall;
  getSyncInfo(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SyncInfoResponse) => void,
  ): ClientUnaryCall;
  /** Get the base node sync information */
  getSyncProgress(
    request: Empty,
    callback: (error: ServiceError | null, response: SyncProgressResponse) => void,
  ): ClientUnaryCall;
  getSyncProgress(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SyncProgressResponse) => void,
  ): ClientUnaryCall;
  getSyncProgress(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SyncProgressResponse) => void,
  ): ClientUnaryCall;
  /** Get the base node tip information */
  getTipInfo(
    request: Empty,
    callback: (error: ServiceError | null, response: TipInfoResponse) => void,
  ): ClientUnaryCall;
  getTipInfo(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TipInfoResponse) => void,
  ): ClientUnaryCall;
  getTipInfo(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TipInfoResponse) => void,
  ): ClientUnaryCall;
  /** Search for blocks containing the specified kernels */
  searchKernels(request: SearchKernelsRequest, options?: Partial<CallOptions>): ClientReadableStream<HistoricalBlock>;
  searchKernels(
    request: SearchKernelsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<HistoricalBlock>;
  /** Search for blocks containing the specified commitments */
  searchUtxos(request: SearchUtxosRequest, options?: Partial<CallOptions>): ClientReadableStream<HistoricalBlock>;
  searchUtxos(
    request: SearchUtxosRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<HistoricalBlock>;
  /** Fetch any utxos that exist in the main chain */
  fetchMatchingUtxos(
    request: FetchMatchingUtxosRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<FetchMatchingUtxosResponse>;
  fetchMatchingUtxos(
    request: FetchMatchingUtxosRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<FetchMatchingUtxosResponse>;
  /** get all peers from the base node */
  getPeers(request: GetPeersRequest, options?: Partial<CallOptions>): ClientReadableStream<GetPeersResponse>;
  getPeers(
    request: GetPeersRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetPeersResponse>;
  getMempoolTransactions(
    request: GetMempoolTransactionsRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetMempoolTransactionsResponse>;
  getMempoolTransactions(
    request: GetMempoolTransactionsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetMempoolTransactionsResponse>;
  transactionState(
    request: TransactionStateRequest,
    callback: (error: ServiceError | null, response: TransactionStateResponse) => void,
  ): ClientUnaryCall;
  transactionState(
    request: TransactionStateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionStateResponse) => void,
  ): ClientUnaryCall;
  transactionState(
    request: TransactionStateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionStateResponse) => void,
  ): ClientUnaryCall;
  /** This returns the node's network identity */
  identify(request: Empty, callback: (error: ServiceError | null, response: NodeIdentity) => void): ClientUnaryCall;
  identify(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NodeIdentity) => void,
  ): ClientUnaryCall;
  identify(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NodeIdentity) => void,
  ): ClientUnaryCall;
  /** Get Base Node network connectivity status */
  getNetworkStatus(
    request: Empty,
    callback: (error: ServiceError | null, response: NetworkStatusResponse) => void,
  ): ClientUnaryCall;
  getNetworkStatus(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NetworkStatusResponse) => void,
  ): ClientUnaryCall;
  getNetworkStatus(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NetworkStatusResponse) => void,
  ): ClientUnaryCall;
  /** List currently connected peers */
  listConnectedPeers(
    request: Empty,
    callback: (error: ServiceError | null, response: ListConnectedPeersResponse) => void,
  ): ClientUnaryCall;
  listConnectedPeers(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListConnectedPeersResponse) => void,
  ): ClientUnaryCall;
  listConnectedPeers(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListConnectedPeersResponse) => void,
  ): ClientUnaryCall;
  /** Get mempool stats */
  getMempoolStats(
    request: Empty,
    callback: (error: ServiceError | null, response: MempoolStatsResponse) => void,
  ): ClientUnaryCall;
  getMempoolStats(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MempoolStatsResponse) => void,
  ): ClientUnaryCall;
  getMempoolStats(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MempoolStatsResponse) => void,
  ): ClientUnaryCall;
  /** Get VNs */
  getActiveValidatorNodes(
    request: GetActiveValidatorNodesRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetActiveValidatorNodesResponse>;
  getActiveValidatorNodes(
    request: GetActiveValidatorNodesRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetActiveValidatorNodesResponse>;
  getValidatorNodeChanges(
    request: GetValidatorNodeChangesRequest,
    callback: (error: ServiceError | null, response: GetValidatorNodeChangesResponse) => void,
  ): ClientUnaryCall;
  getValidatorNodeChanges(
    request: GetValidatorNodeChangesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetValidatorNodeChangesResponse) => void,
  ): ClientUnaryCall;
  getValidatorNodeChanges(
    request: GetValidatorNodeChangesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetValidatorNodeChangesResponse) => void,
  ): ClientUnaryCall;
  getShardKey(
    request: GetShardKeyRequest,
    callback: (error: ServiceError | null, response: GetShardKeyResponse) => void,
  ): ClientUnaryCall;
  getShardKey(
    request: GetShardKeyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetShardKeyResponse) => void,
  ): ClientUnaryCall;
  getShardKey(
    request: GetShardKeyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetShardKeyResponse) => void,
  ): ClientUnaryCall;
  /** Get templates */
  getTemplateRegistrations(
    request: GetTemplateRegistrationsRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetTemplateRegistrationResponse>;
  getTemplateRegistrations(
    request: GetTemplateRegistrationsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetTemplateRegistrationResponse>;
  getSideChainUtxos(
    request: GetSideChainUtxosRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetSideChainUtxosResponse>;
  getSideChainUtxos(
    request: GetSideChainUtxosRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<GetSideChainUtxosResponse>;
  getNetworkState(
    request: GetNetworkStateRequest,
    callback: (error: ServiceError | null, response: GetNetworkStateResponse) => void,
  ): ClientUnaryCall;
  getNetworkState(
    request: GetNetworkStateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetNetworkStateResponse) => void,
  ): ClientUnaryCall;
  getNetworkState(
    request: GetNetworkStateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetNetworkStateResponse) => void,
  ): ClientUnaryCall;
  /** PayRef (Payment Reference) lookup for block explorers and external services */
  searchPaymentReferences(
    request: SearchPaymentReferencesRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<PaymentReferenceResponse>;
  searchPaymentReferences(
    request: SearchPaymentReferencesRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<PaymentReferenceResponse>;
  /** PayRef (Payment Reference) lookup for block explorers and external services via output hash */
  searchPaymentReferencesViaOutputHash(
    request: FetchMatchingUtxosRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<PaymentReferenceResponse>;
  searchPaymentReferencesViaOutputHash(
    request: FetchMatchingUtxosRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<PaymentReferenceResponse>;
}

export const BaseNodeClient = makeGenericClientConstructor(BaseNodeService, "tari.rpc.BaseNode") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): BaseNodeClient;
  service: typeof BaseNodeService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
