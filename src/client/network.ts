// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.28.2
// source: network.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "tari.rpc";

/**
 * Copyright 2020. The Tari Project
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 * disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

export enum ConnectivityStatus {
  Initializing = 0,
  Online = 1,
  Degraded = 2,
  Offline = 3,
  UNRECOGNIZED = -1,
}

export function connectivityStatusFromJSON(object: any): ConnectivityStatus {
  switch (object) {
    case 0:
    case "Initializing":
      return ConnectivityStatus.Initializing;
    case 1:
    case "Online":
      return ConnectivityStatus.Online;
    case 2:
    case "Degraded":
      return ConnectivityStatus.Degraded;
    case 3:
    case "Offline":
      return ConnectivityStatus.Offline;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectivityStatus.UNRECOGNIZED;
  }
}

export function connectivityStatusToJSON(object: ConnectivityStatus): string {
  switch (object) {
    case ConnectivityStatus.Initializing:
      return "Initializing";
    case ConnectivityStatus.Online:
      return "Online";
    case ConnectivityStatus.Degraded:
      return "Degraded";
    case ConnectivityStatus.Offline:
      return "Offline";
    case ConnectivityStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface NodeIdentity {
  publicKey: Uint8Array;
  publicAddresses: string[];
  nodeId: Uint8Array;
}

export interface Peer {
  /** / Public key of the peer */
  publicKey: Uint8Array;
  /** / NodeId of the peer */
  nodeId: Uint8Array;
  /** / Peer's addresses */
  addresses: Address[];
  /** / Last connection attempt to peer */
  lastConnection: Long;
  /** / Flags for the peer. */
  flags: number;
  bannedUntil: Long;
  bannedReason: string;
  offlineAt: Long;
  /** / Features supported by the peer */
  features: number;
  /** / used as information for more efficient protocol negotiation. */
  supportedProtocols: Uint8Array[];
  /** / User agent advertised by the peer */
  userAgent: string;
}

export interface NetworkStatusResponse {
  status: ConnectivityStatus;
  avgLatencyMs: number;
  numNodeConnections: number;
}

export interface Address {
  address: Uint8Array;
  lastSeen: string;
  connectionAttempts: number;
  avgLatency: AverageLatency | undefined;
}

export interface AverageLatency {
  latency: Long;
}

export interface ListConnectedPeersResponse {
  connectedPeers: Peer[];
}

export interface SoftwareUpdate {
  hasUpdate: boolean;
  version: string;
  sha: string;
  downloadUrl: string;
}

export interface GetIdentityRequest {}

export interface GetIdentityResponse {
  publicKey: Uint8Array;
  publicAddress: string;
  nodeId: Uint8Array;
}

function createBaseNodeIdentity(): NodeIdentity {
  return { publicKey: new Uint8Array(0), publicAddresses: [], nodeId: new Uint8Array(0) };
}

export const NodeIdentity: MessageFns<NodeIdentity> = {
  encode(message: NodeIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey.length !== 0) {
      writer.uint32(10).bytes(message.publicKey);
    }
    for (const v of message.publicAddresses) {
      writer.uint32(18).string(v!);
    }
    if (message.nodeId.length !== 0) {
      writer.uint32(26).bytes(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicAddresses.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodeId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeIdentity {
    return {
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      publicAddresses: globalThis.Array.isArray(object?.publicAddresses)
        ? object.publicAddresses.map((e: any) => globalThis.String(e))
        : [],
      nodeId: isSet(object.nodeId) ? bytesFromBase64(object.nodeId) : new Uint8Array(0),
    };
  },

  toJSON(message: NodeIdentity): unknown {
    const obj: any = {};
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.publicAddresses?.length) {
      obj.publicAddresses = message.publicAddresses;
    }
    if (message.nodeId.length !== 0) {
      obj.nodeId = base64FromBytes(message.nodeId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeIdentity>, I>>(base?: I): NodeIdentity {
    return NodeIdentity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeIdentity>, I>>(object: I): NodeIdentity {
    const message = createBaseNodeIdentity();
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.publicAddresses = object.publicAddresses?.map((e) => e) || [];
    message.nodeId = object.nodeId ?? new Uint8Array(0);
    return message;
  },
};

function createBasePeer(): Peer {
  return {
    publicKey: new Uint8Array(0),
    nodeId: new Uint8Array(0),
    addresses: [],
    lastConnection: Long.UZERO,
    flags: 0,
    bannedUntil: Long.UZERO,
    bannedReason: "",
    offlineAt: Long.UZERO,
    features: 0,
    supportedProtocols: [],
    userAgent: "",
  };
}

export const Peer: MessageFns<Peer> = {
  encode(message: Peer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey.length !== 0) {
      writer.uint32(10).bytes(message.publicKey);
    }
    if (message.nodeId.length !== 0) {
      writer.uint32(18).bytes(message.nodeId);
    }
    for (const v of message.addresses) {
      Address.encode(v!, writer.uint32(26).fork()).join();
    }
    if (!message.lastConnection.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.lastConnection.toString());
    }
    if (message.flags !== 0) {
      writer.uint32(40).uint32(message.flags);
    }
    if (!message.bannedUntil.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.bannedUntil.toString());
    }
    if (message.bannedReason !== "") {
      writer.uint32(58).string(message.bannedReason);
    }
    if (!message.offlineAt.equals(Long.UZERO)) {
      writer.uint32(64).uint64(message.offlineAt.toString());
    }
    if (message.features !== 0) {
      writer.uint32(72).uint32(message.features);
    }
    for (const v of message.supportedProtocols) {
      writer.uint32(90).bytes(v!);
    }
    if (message.userAgent !== "") {
      writer.uint32(98).string(message.userAgent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Peer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addresses.push(Address.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastConnection = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.bannedUntil = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.bannedReason = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.offlineAt = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.features = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.supportedProtocols.push(reader.bytes());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Peer {
    return {
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      nodeId: isSet(object.nodeId) ? bytesFromBase64(object.nodeId) : new Uint8Array(0),
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => Address.fromJSON(e))
        : [],
      lastConnection: isSet(object.lastConnection) ? Long.fromValue(object.lastConnection) : Long.UZERO,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      bannedUntil: isSet(object.bannedUntil) ? Long.fromValue(object.bannedUntil) : Long.UZERO,
      bannedReason: isSet(object.bannedReason) ? globalThis.String(object.bannedReason) : "",
      offlineAt: isSet(object.offlineAt) ? Long.fromValue(object.offlineAt) : Long.UZERO,
      features: isSet(object.features) ? globalThis.Number(object.features) : 0,
      supportedProtocols: globalThis.Array.isArray(object?.supportedProtocols)
        ? object.supportedProtocols.map((e: any) => bytesFromBase64(e))
        : [],
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
    };
  },

  toJSON(message: Peer): unknown {
    const obj: any = {};
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.nodeId.length !== 0) {
      obj.nodeId = base64FromBytes(message.nodeId);
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => Address.toJSON(e));
    }
    if (!message.lastConnection.equals(Long.UZERO)) {
      obj.lastConnection = (message.lastConnection || Long.UZERO).toString();
    }
    if (message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (!message.bannedUntil.equals(Long.UZERO)) {
      obj.bannedUntil = (message.bannedUntil || Long.UZERO).toString();
    }
    if (message.bannedReason !== "") {
      obj.bannedReason = message.bannedReason;
    }
    if (!message.offlineAt.equals(Long.UZERO)) {
      obj.offlineAt = (message.offlineAt || Long.UZERO).toString();
    }
    if (message.features !== 0) {
      obj.features = Math.round(message.features);
    }
    if (message.supportedProtocols?.length) {
      obj.supportedProtocols = message.supportedProtocols.map((e) => base64FromBytes(e));
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Peer>, I>>(base?: I): Peer {
    return Peer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Peer>, I>>(object: I): Peer {
    const message = createBasePeer();
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.nodeId = object.nodeId ?? new Uint8Array(0);
    message.addresses = object.addresses?.map((e) => Address.fromPartial(e)) || [];
    message.lastConnection =
      object.lastConnection !== undefined && object.lastConnection !== null
        ? Long.fromValue(object.lastConnection)
        : Long.UZERO;
    message.flags = object.flags ?? 0;
    message.bannedUntil =
      object.bannedUntil !== undefined && object.bannedUntil !== null ? Long.fromValue(object.bannedUntil) : Long.UZERO;
    message.bannedReason = object.bannedReason ?? "";
    message.offlineAt =
      object.offlineAt !== undefined && object.offlineAt !== null ? Long.fromValue(object.offlineAt) : Long.UZERO;
    message.features = object.features ?? 0;
    message.supportedProtocols = object.supportedProtocols?.map((e) => e) || [];
    message.userAgent = object.userAgent ?? "";
    return message;
  },
};

function createBaseNetworkStatusResponse(): NetworkStatusResponse {
  return { status: 0, avgLatencyMs: 0, numNodeConnections: 0 };
}

export const NetworkStatusResponse: MessageFns<NetworkStatusResponse> = {
  encode(message: NetworkStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.avgLatencyMs !== 0) {
      writer.uint32(16).uint32(message.avgLatencyMs);
    }
    if (message.numNodeConnections !== 0) {
      writer.uint32(24).uint32(message.numNodeConnections);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.avgLatencyMs = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.numNodeConnections = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkStatusResponse {
    return {
      status: isSet(object.status) ? connectivityStatusFromJSON(object.status) : 0,
      avgLatencyMs: isSet(object.avgLatencyMs) ? globalThis.Number(object.avgLatencyMs) : 0,
      numNodeConnections: isSet(object.numNodeConnections) ? globalThis.Number(object.numNodeConnections) : 0,
    };
  },

  toJSON(message: NetworkStatusResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = connectivityStatusToJSON(message.status);
    }
    if (message.avgLatencyMs !== 0) {
      obj.avgLatencyMs = Math.round(message.avgLatencyMs);
    }
    if (message.numNodeConnections !== 0) {
      obj.numNodeConnections = Math.round(message.numNodeConnections);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NetworkStatusResponse>, I>>(base?: I): NetworkStatusResponse {
    return NetworkStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NetworkStatusResponse>, I>>(object: I): NetworkStatusResponse {
    const message = createBaseNetworkStatusResponse();
    message.status = object.status ?? 0;
    message.avgLatencyMs = object.avgLatencyMs ?? 0;
    message.numNodeConnections = object.numNodeConnections ?? 0;
    return message;
  },
};

function createBaseAddress(): Address {
  return { address: new Uint8Array(0), lastSeen: "", connectionAttempts: 0, avgLatency: undefined };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (message.lastSeen !== "") {
      writer.uint32(18).string(message.lastSeen);
    }
    if (message.connectionAttempts !== 0) {
      writer.uint32(24).uint32(message.connectionAttempts);
    }
    if (message.avgLatency !== undefined) {
      AverageLatency.encode(message.avgLatency, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastSeen = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.connectionAttempts = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avgLatency = AverageLatency.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0),
      lastSeen: isSet(object.lastSeen) ? globalThis.String(object.lastSeen) : "",
      connectionAttempts: isSet(object.connectionAttempts) ? globalThis.Number(object.connectionAttempts) : 0,
      avgLatency: isSet(object.avgLatency) ? AverageLatency.fromJSON(object.avgLatency) : undefined,
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.lastSeen !== "") {
      obj.lastSeen = message.lastSeen;
    }
    if (message.connectionAttempts !== 0) {
      obj.connectionAttempts = Math.round(message.connectionAttempts);
    }
    if (message.avgLatency !== undefined) {
      obj.avgLatency = AverageLatency.toJSON(message.avgLatency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Address>, I>>(base?: I): Address {
    return Address.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Address>, I>>(object: I): Address {
    const message = createBaseAddress();
    message.address = object.address ?? new Uint8Array(0);
    message.lastSeen = object.lastSeen ?? "";
    message.connectionAttempts = object.connectionAttempts ?? 0;
    message.avgLatency =
      object.avgLatency !== undefined && object.avgLatency !== null
        ? AverageLatency.fromPartial(object.avgLatency)
        : undefined;
    return message;
  },
};

function createBaseAverageLatency(): AverageLatency {
  return { latency: Long.UZERO };
}

export const AverageLatency: MessageFns<AverageLatency> = {
  encode(message: AverageLatency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.latency.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.latency.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AverageLatency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAverageLatency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.latency = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AverageLatency {
    return { latency: isSet(object.latency) ? Long.fromValue(object.latency) : Long.UZERO };
  },

  toJSON(message: AverageLatency): unknown {
    const obj: any = {};
    if (!message.latency.equals(Long.UZERO)) {
      obj.latency = (message.latency || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AverageLatency>, I>>(base?: I): AverageLatency {
    return AverageLatency.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AverageLatency>, I>>(object: I): AverageLatency {
    const message = createBaseAverageLatency();
    message.latency =
      object.latency !== undefined && object.latency !== null ? Long.fromValue(object.latency) : Long.UZERO;
    return message;
  },
};

function createBaseListConnectedPeersResponse(): ListConnectedPeersResponse {
  return { connectedPeers: [] };
}

export const ListConnectedPeersResponse: MessageFns<ListConnectedPeersResponse> = {
  encode(message: ListConnectedPeersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connectedPeers) {
      Peer.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectedPeersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectedPeersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectedPeers.push(Peer.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectedPeersResponse {
    return {
      connectedPeers: globalThis.Array.isArray(object?.connectedPeers)
        ? object.connectedPeers.map((e: any) => Peer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListConnectedPeersResponse): unknown {
    const obj: any = {};
    if (message.connectedPeers?.length) {
      obj.connectedPeers = message.connectedPeers.map((e) => Peer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListConnectedPeersResponse>, I>>(base?: I): ListConnectedPeersResponse {
    return ListConnectedPeersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListConnectedPeersResponse>, I>>(object: I): ListConnectedPeersResponse {
    const message = createBaseListConnectedPeersResponse();
    message.connectedPeers = object.connectedPeers?.map((e) => Peer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSoftwareUpdate(): SoftwareUpdate {
  return { hasUpdate: false, version: "", sha: "", downloadUrl: "" };
}

export const SoftwareUpdate: MessageFns<SoftwareUpdate> = {
  encode(message: SoftwareUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasUpdate !== false) {
      writer.uint32(8).bool(message.hasUpdate);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.sha !== "") {
      writer.uint32(26).string(message.sha);
    }
    if (message.downloadUrl !== "") {
      writer.uint32(34).string(message.downloadUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasUpdate = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sha = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.downloadUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareUpdate {
    return {
      hasUpdate: isSet(object.hasUpdate) ? globalThis.Boolean(object.hasUpdate) : false,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      sha: isSet(object.sha) ? globalThis.String(object.sha) : "",
      downloadUrl: isSet(object.downloadUrl) ? globalThis.String(object.downloadUrl) : "",
    };
  },

  toJSON(message: SoftwareUpdate): unknown {
    const obj: any = {};
    if (message.hasUpdate !== false) {
      obj.hasUpdate = message.hasUpdate;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.sha !== "") {
      obj.sha = message.sha;
    }
    if (message.downloadUrl !== "") {
      obj.downloadUrl = message.downloadUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SoftwareUpdate>, I>>(base?: I): SoftwareUpdate {
    return SoftwareUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SoftwareUpdate>, I>>(object: I): SoftwareUpdate {
    const message = createBaseSoftwareUpdate();
    message.hasUpdate = object.hasUpdate ?? false;
    message.version = object.version ?? "";
    message.sha = object.sha ?? "";
    message.downloadUrl = object.downloadUrl ?? "";
    return message;
  },
};

function createBaseGetIdentityRequest(): GetIdentityRequest {
  return {};
}

export const GetIdentityRequest: MessageFns<GetIdentityRequest> = {
  encode(_: GetIdentityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIdentityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIdentityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetIdentityRequest {
    return {};
  },

  toJSON(_: GetIdentityRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetIdentityRequest>, I>>(base?: I): GetIdentityRequest {
    return GetIdentityRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetIdentityRequest>, I>>(_: I): GetIdentityRequest {
    const message = createBaseGetIdentityRequest();
    return message;
  },
};

function createBaseGetIdentityResponse(): GetIdentityResponse {
  return { publicKey: new Uint8Array(0), publicAddress: "", nodeId: new Uint8Array(0) };
}

export const GetIdentityResponse: MessageFns<GetIdentityResponse> = {
  encode(message: GetIdentityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey.length !== 0) {
      writer.uint32(10).bytes(message.publicKey);
    }
    if (message.publicAddress !== "") {
      writer.uint32(18).string(message.publicAddress);
    }
    if (message.nodeId.length !== 0) {
      writer.uint32(26).bytes(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIdentityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIdentityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodeId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIdentityResponse {
    return {
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      publicAddress: isSet(object.publicAddress) ? globalThis.String(object.publicAddress) : "",
      nodeId: isSet(object.nodeId) ? bytesFromBase64(object.nodeId) : new Uint8Array(0),
    };
  },

  toJSON(message: GetIdentityResponse): unknown {
    const obj: any = {};
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.publicAddress !== "") {
      obj.publicAddress = message.publicAddress;
    }
    if (message.nodeId.length !== 0) {
      obj.nodeId = base64FromBytes(message.nodeId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetIdentityResponse>, I>>(base?: I): GetIdentityResponse {
    return GetIdentityResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetIdentityResponse>, I>>(object: I): GetIdentityResponse {
    const message = createBaseGetIdentityResponse();
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.publicAddress = object.publicAddress ?? "";
    message.nodeId = object.nodeId ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
    ? string | number | Long
    : T extends globalThis.Array<infer U>
      ? globalThis.Array<DeepPartial<U>>
      : T extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : T extends {}
          ? { [K in keyof T]?: DeepPartial<T[K]> }
          : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
