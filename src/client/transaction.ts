// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.28.2
// source: transaction.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { SideChainFeature } from "./sidechain_types";
import { ComAndPubSignature, RangeProof, Signature } from "./types";

export const protobufPackage = "tari.rpc";

/**
 * Copyright 2020. The Tari Project
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 * disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * The transaction kernel tracks the excess for a given transaction. For an explanation of what the excess is, and
 * why it is necessary, refer to the
 * [Mimblewimble TLU post](https://tlu.tarilabs.com/protocols/mimblewimble-1/sources/PITCHME.link.html?highlight=mimblewimble#mimblewimble).
 * The kernel also tracks other transaction metadata, such as the lock height for the transaction (i.e. the earliest
 * this transaction can be mined) and the transaction fee, in cleartext.
 */
export interface TransactionKernel {
  /** Options for a kernel's structure or use */
  features: number;
  /** / Fee originally included in the transaction this proof is for (in MicroMinotari) */
  fee: Long;
  /**
   * This kernel is not valid earlier than lock_height blocks
   * The max lock_height of all *inputs* to this transaction
   */
  lockHeight: Long;
  /**
   * Remainder of the sum of all transaction commitments. If the transaction
   * is well formed, amounts components should sum to zero and the excess
   * is hence a valid public key.
   */
  excess: Uint8Array;
  /**
   * The signature proving the excess is a valid public key, which signs
   * the transaction fee.
   */
  excessSig: Signature | undefined;
  /** The hash of the kernel, as it appears in the MMR */
  hash: Uint8Array;
  /** Version */
  version: number;
  /** Optional burned commitment */
  burnCommitment: Uint8Array;
}

/**
 * A transaction input.
 *
 * Primarily a reference to an output being spent by the transaction.
 */
export interface TransactionInput {
  /** The features of the output being spent. We will check maturity for all outputs. */
  features: OutputFeatures | undefined;
  /** The commitment referencing the output being spent. */
  commitment: Uint8Array;
  /** Hash of the input, as it appears in the MMR */
  hash: Uint8Array;
  /** The serialised script */
  script: Uint8Array;
  /** The script input data, if any */
  inputData: Uint8Array;
  /** A signature with k_s, signing the script, input data, and mined height */
  scriptSignature: ComAndPubSignature | undefined;
  /** The offset public key, K_O */
  senderOffsetPublicKey: Uint8Array;
  /** The hash of the output this input is spending */
  outputHash: Uint8Array;
  /** Covenant */
  covenant: Uint8Array;
  /** Version */
  version: number;
  /** The encrypted data */
  encryptedData: Uint8Array;
  /** The minimum value of the commitment that is proven by the range proof (in MicroMinotari) */
  minimumValuePromise: Long;
  /** The metadata signature for output this input is spending */
  metadataSignature: ComAndPubSignature | undefined;
  /** The rangeproof hash for output this input is spending */
  rangeproofHash: Uint8Array;
}

/**
 * Output for a transaction, defining the new ownership of coins that are being transferred. The commitment is a
 * blinded value for the output while the range proof guarantees the commitment includes a positive value without
 * overflow and the ownership of the private key.
 */
export interface TransactionOutput {
  /** Options for an output's structure or use */
  features: OutputFeatures | undefined;
  /** The homomorphic commitment representing the output amount */
  commitment: Uint8Array;
  /** A proof that the commitment is in the right range */
  rangeProof: RangeProof | undefined;
  /** The hash of the output, as it appears in the MMR */
  hash: Uint8Array;
  /** Tari script serialised script */
  script: Uint8Array;
  /** Tari script offset public key, K_O */
  senderOffsetPublicKey: Uint8Array;
  /**
   * Metadata signature with the homomorphic commitment private values (amount and blinding factor) and the sender
   * offset private key
   */
  metadataSignature: ComAndPubSignature | undefined;
  /** Covenant */
  covenant: Uint8Array;
  /** Version */
  version: number;
  /** Encrypted Pedersen commitment openings (value and mask) for the output */
  encryptedData: Uint8Array;
  /** The minimum value of the commitment that is proven by the range proof (in MicroMinotari) */
  minimumValuePromise: Long;
}

/** Options for UTXOs */
export interface OutputFeatures {
  /** Version */
  version: number;
  /** The type of output, eg Coinbase, all of which have different consensus rules */
  outputType: number;
  /**
   * The maturity of the specific UTXO. This is the min lock height at which an UTXO can be spend. Coinbase UTXO
   * require a min maturity of the Coinbase_lock_height, this should be checked on receiving new blocks.
   */
  maturity: Long;
  /** Additional arbitrary info in coinbase transactions supplied by miners */
  coinbaseExtra: Uint8Array;
  /** Features that are specific to a side chain */
  sidechainFeature: SideChainFeature | undefined;
  /** The type of range proof used in the output */
  rangeProofType: number;
}

/**
 * The components of the block or transaction. The same struct can be used for either, since in Mimblewimble,
 * cut-through means that blocks and transactions have the same structure. The inputs, outputs and kernels should
 * be sorted by their Blake2b-256bit digest hash
 */
export interface AggregateBody {
  /** List of inputs spent by the transaction. */
  inputs: TransactionInput[];
  /** List of outputs the transaction produces. */
  outputs: TransactionOutput[];
  /** Kernels contain the excesses and their signatures for transaction */
  kernels: TransactionKernel[];
}

/** A transaction which consists of a kernel offset and an aggregate body made up of inputs, outputs and kernels. */
export interface Transaction {
  offset: Uint8Array;
  body: AggregateBody | undefined;
  scriptOffset: Uint8Array;
}

export interface UnblindedOutput {
  /** Value of the output */
  value: Long;
  /** Spending key of the output */
  spendingKey: Uint8Array;
  /** Options for an output's structure or use */
  features: OutputFeatures | undefined;
  /** Tari script serialised script */
  script: Uint8Array;
  /** Tari script input data for spending */
  inputData: Uint8Array;
  /** Tari script private key */
  scriptPrivateKey: Uint8Array;
  /** Tari script offset pubkey, K_O */
  senderOffsetPublicKey: Uint8Array;
  /** UTXO signature with the script offset private key, k_O */
  metadataSignature: ComAndPubSignature | undefined;
  /** The minimum height the script allows this output to be spent */
  scriptLockHeight: Long;
  /** Covenant */
  covenant: Uint8Array;
  /** Encrypted data */
  encryptedData: Uint8Array;
  /** The minimum value of the commitment that is proven by the range proof (in MicroMinotari) */
  minimumValuePromise: Long;
  /** The range proof */
  rangeProof: RangeProof | undefined;
}

function createBaseTransactionKernel(): TransactionKernel {
  return {
    features: 0,
    fee: Long.UZERO,
    lockHeight: Long.UZERO,
    excess: new Uint8Array(0),
    excessSig: undefined,
    hash: new Uint8Array(0),
    version: 0,
    burnCommitment: new Uint8Array(0),
  };
}

export const TransactionKernel: MessageFns<TransactionKernel> = {
  encode(message: TransactionKernel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.features !== 0) {
      writer.uint32(8).uint32(message.features);
    }
    if (!message.fee.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.fee.toString());
    }
    if (!message.lockHeight.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.lockHeight.toString());
    }
    if (message.excess.length !== 0) {
      writer.uint32(50).bytes(message.excess);
    }
    if (message.excessSig !== undefined) {
      Signature.encode(message.excessSig, writer.uint32(58).fork()).join();
    }
    if (message.hash.length !== 0) {
      writer.uint32(66).bytes(message.hash);
    }
    if (message.version !== 0) {
      writer.uint32(72).uint32(message.version);
    }
    if (message.burnCommitment.length !== 0) {
      writer.uint32(82).bytes(message.burnCommitment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionKernel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionKernel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.features = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fee = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lockHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.excess = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.excessSig = Signature.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.burnCommitment = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionKernel {
    return {
      features: isSet(object.features) ? globalThis.Number(object.features) : 0,
      fee: isSet(object.fee) ? Long.fromValue(object.fee) : Long.UZERO,
      lockHeight: isSet(object.lockHeight) ? Long.fromValue(object.lockHeight) : Long.UZERO,
      excess: isSet(object.excess) ? bytesFromBase64(object.excess) : new Uint8Array(0),
      excessSig: isSet(object.excessSig) ? Signature.fromJSON(object.excessSig) : undefined,
      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0),
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      burnCommitment: isSet(object.burnCommitment) ? bytesFromBase64(object.burnCommitment) : new Uint8Array(0),
    };
  },

  toJSON(message: TransactionKernel): unknown {
    const obj: any = {};
    if (message.features !== 0) {
      obj.features = Math.round(message.features);
    }
    if (!message.fee.equals(Long.UZERO)) {
      obj.fee = (message.fee || Long.UZERO).toString();
    }
    if (!message.lockHeight.equals(Long.UZERO)) {
      obj.lockHeight = (message.lockHeight || Long.UZERO).toString();
    }
    if (message.excess.length !== 0) {
      obj.excess = base64FromBytes(message.excess);
    }
    if (message.excessSig !== undefined) {
      obj.excessSig = Signature.toJSON(message.excessSig);
    }
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.burnCommitment.length !== 0) {
      obj.burnCommitment = base64FromBytes(message.burnCommitment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionKernel>, I>>(base?: I): TransactionKernel {
    return TransactionKernel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionKernel>, I>>(object: I): TransactionKernel {
    const message = createBaseTransactionKernel();
    message.features = object.features ?? 0;
    message.fee = object.fee !== undefined && object.fee !== null ? Long.fromValue(object.fee) : Long.UZERO;
    message.lockHeight =
      object.lockHeight !== undefined && object.lockHeight !== null ? Long.fromValue(object.lockHeight) : Long.UZERO;
    message.excess = object.excess ?? new Uint8Array(0);
    message.excessSig =
      object.excessSig !== undefined && object.excessSig !== null ? Signature.fromPartial(object.excessSig) : undefined;
    message.hash = object.hash ?? new Uint8Array(0);
    message.version = object.version ?? 0;
    message.burnCommitment = object.burnCommitment ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransactionInput(): TransactionInput {
  return {
    features: undefined,
    commitment: new Uint8Array(0),
    hash: new Uint8Array(0),
    script: new Uint8Array(0),
    inputData: new Uint8Array(0),
    scriptSignature: undefined,
    senderOffsetPublicKey: new Uint8Array(0),
    outputHash: new Uint8Array(0),
    covenant: new Uint8Array(0),
    version: 0,
    encryptedData: new Uint8Array(0),
    minimumValuePromise: Long.UZERO,
    metadataSignature: undefined,
    rangeproofHash: new Uint8Array(0),
  };
}

export const TransactionInput: MessageFns<TransactionInput> = {
  encode(message: TransactionInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.features !== undefined) {
      OutputFeatures.encode(message.features, writer.uint32(10).fork()).join();
    }
    if (message.commitment.length !== 0) {
      writer.uint32(18).bytes(message.commitment);
    }
    if (message.hash.length !== 0) {
      writer.uint32(26).bytes(message.hash);
    }
    if (message.script.length !== 0) {
      writer.uint32(34).bytes(message.script);
    }
    if (message.inputData.length !== 0) {
      writer.uint32(42).bytes(message.inputData);
    }
    if (message.scriptSignature !== undefined) {
      ComAndPubSignature.encode(message.scriptSignature, writer.uint32(58).fork()).join();
    }
    if (message.senderOffsetPublicKey.length !== 0) {
      writer.uint32(66).bytes(message.senderOffsetPublicKey);
    }
    if (message.outputHash.length !== 0) {
      writer.uint32(74).bytes(message.outputHash);
    }
    if (message.covenant.length !== 0) {
      writer.uint32(82).bytes(message.covenant);
    }
    if (message.version !== 0) {
      writer.uint32(88).uint32(message.version);
    }
    if (message.encryptedData.length !== 0) {
      writer.uint32(98).bytes(message.encryptedData);
    }
    if (!message.minimumValuePromise.equals(Long.UZERO)) {
      writer.uint32(104).uint64(message.minimumValuePromise.toString());
    }
    if (message.metadataSignature !== undefined) {
      ComAndPubSignature.encode(message.metadataSignature, writer.uint32(114).fork()).join();
    }
    if (message.rangeproofHash.length !== 0) {
      writer.uint32(122).bytes(message.rangeproofHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.features = OutputFeatures.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commitment = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.script = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inputData = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.scriptSignature = ComAndPubSignature.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.senderOffsetPublicKey = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.outputHash = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.covenant = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.encryptedData = reader.bytes();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.minimumValuePromise = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.metadataSignature = ComAndPubSignature.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.rangeproofHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInput {
    return {
      features: isSet(object.features) ? OutputFeatures.fromJSON(object.features) : undefined,
      commitment: isSet(object.commitment) ? bytesFromBase64(object.commitment) : new Uint8Array(0),
      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0),
      script: isSet(object.script) ? bytesFromBase64(object.script) : new Uint8Array(0),
      inputData: isSet(object.inputData) ? bytesFromBase64(object.inputData) : new Uint8Array(0),
      scriptSignature: isSet(object.scriptSignature) ? ComAndPubSignature.fromJSON(object.scriptSignature) : undefined,
      senderOffsetPublicKey: isSet(object.senderOffsetPublicKey)
        ? bytesFromBase64(object.senderOffsetPublicKey)
        : new Uint8Array(0),
      outputHash: isSet(object.outputHash) ? bytesFromBase64(object.outputHash) : new Uint8Array(0),
      covenant: isSet(object.covenant) ? bytesFromBase64(object.covenant) : new Uint8Array(0),
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      encryptedData: isSet(object.encryptedData) ? bytesFromBase64(object.encryptedData) : new Uint8Array(0),
      minimumValuePromise: isSet(object.minimumValuePromise) ? Long.fromValue(object.minimumValuePromise) : Long.UZERO,
      metadataSignature: isSet(object.metadataSignature)
        ? ComAndPubSignature.fromJSON(object.metadataSignature)
        : undefined,
      rangeproofHash: isSet(object.rangeproofHash) ? bytesFromBase64(object.rangeproofHash) : new Uint8Array(0),
    };
  },

  toJSON(message: TransactionInput): unknown {
    const obj: any = {};
    if (message.features !== undefined) {
      obj.features = OutputFeatures.toJSON(message.features);
    }
    if (message.commitment.length !== 0) {
      obj.commitment = base64FromBytes(message.commitment);
    }
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.script.length !== 0) {
      obj.script = base64FromBytes(message.script);
    }
    if (message.inputData.length !== 0) {
      obj.inputData = base64FromBytes(message.inputData);
    }
    if (message.scriptSignature !== undefined) {
      obj.scriptSignature = ComAndPubSignature.toJSON(message.scriptSignature);
    }
    if (message.senderOffsetPublicKey.length !== 0) {
      obj.senderOffsetPublicKey = base64FromBytes(message.senderOffsetPublicKey);
    }
    if (message.outputHash.length !== 0) {
      obj.outputHash = base64FromBytes(message.outputHash);
    }
    if (message.covenant.length !== 0) {
      obj.covenant = base64FromBytes(message.covenant);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.encryptedData.length !== 0) {
      obj.encryptedData = base64FromBytes(message.encryptedData);
    }
    if (!message.minimumValuePromise.equals(Long.UZERO)) {
      obj.minimumValuePromise = (message.minimumValuePromise || Long.UZERO).toString();
    }
    if (message.metadataSignature !== undefined) {
      obj.metadataSignature = ComAndPubSignature.toJSON(message.metadataSignature);
    }
    if (message.rangeproofHash.length !== 0) {
      obj.rangeproofHash = base64FromBytes(message.rangeproofHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionInput>, I>>(base?: I): TransactionInput {
    return TransactionInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionInput>, I>>(object: I): TransactionInput {
    const message = createBaseTransactionInput();
    message.features =
      object.features !== undefined && object.features !== null
        ? OutputFeatures.fromPartial(object.features)
        : undefined;
    message.commitment = object.commitment ?? new Uint8Array(0);
    message.hash = object.hash ?? new Uint8Array(0);
    message.script = object.script ?? new Uint8Array(0);
    message.inputData = object.inputData ?? new Uint8Array(0);
    message.scriptSignature =
      object.scriptSignature !== undefined && object.scriptSignature !== null
        ? ComAndPubSignature.fromPartial(object.scriptSignature)
        : undefined;
    message.senderOffsetPublicKey = object.senderOffsetPublicKey ?? new Uint8Array(0);
    message.outputHash = object.outputHash ?? new Uint8Array(0);
    message.covenant = object.covenant ?? new Uint8Array(0);
    message.version = object.version ?? 0;
    message.encryptedData = object.encryptedData ?? new Uint8Array(0);
    message.minimumValuePromise =
      object.minimumValuePromise !== undefined && object.minimumValuePromise !== null
        ? Long.fromValue(object.minimumValuePromise)
        : Long.UZERO;
    message.metadataSignature =
      object.metadataSignature !== undefined && object.metadataSignature !== null
        ? ComAndPubSignature.fromPartial(object.metadataSignature)
        : undefined;
    message.rangeproofHash = object.rangeproofHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransactionOutput(): TransactionOutput {
  return {
    features: undefined,
    commitment: new Uint8Array(0),
    rangeProof: undefined,
    hash: new Uint8Array(0),
    script: new Uint8Array(0),
    senderOffsetPublicKey: new Uint8Array(0),
    metadataSignature: undefined,
    covenant: new Uint8Array(0),
    version: 0,
    encryptedData: new Uint8Array(0),
    minimumValuePromise: Long.UZERO,
  };
}

export const TransactionOutput: MessageFns<TransactionOutput> = {
  encode(message: TransactionOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.features !== undefined) {
      OutputFeatures.encode(message.features, writer.uint32(10).fork()).join();
    }
    if (message.commitment.length !== 0) {
      writer.uint32(18).bytes(message.commitment);
    }
    if (message.rangeProof !== undefined) {
      RangeProof.encode(message.rangeProof, writer.uint32(26).fork()).join();
    }
    if (message.hash.length !== 0) {
      writer.uint32(34).bytes(message.hash);
    }
    if (message.script.length !== 0) {
      writer.uint32(42).bytes(message.script);
    }
    if (message.senderOffsetPublicKey.length !== 0) {
      writer.uint32(50).bytes(message.senderOffsetPublicKey);
    }
    if (message.metadataSignature !== undefined) {
      ComAndPubSignature.encode(message.metadataSignature, writer.uint32(58).fork()).join();
    }
    if (message.covenant.length !== 0) {
      writer.uint32(66).bytes(message.covenant);
    }
    if (message.version !== 0) {
      writer.uint32(72).uint32(message.version);
    }
    if (message.encryptedData.length !== 0) {
      writer.uint32(82).bytes(message.encryptedData);
    }
    if (!message.minimumValuePromise.equals(Long.UZERO)) {
      writer.uint32(88).uint64(message.minimumValuePromise.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.features = OutputFeatures.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commitment = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rangeProof = RangeProof.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.script = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.senderOffsetPublicKey = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadataSignature = ComAndPubSignature.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.covenant = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.encryptedData = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.minimumValuePromise = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionOutput {
    return {
      features: isSet(object.features) ? OutputFeatures.fromJSON(object.features) : undefined,
      commitment: isSet(object.commitment) ? bytesFromBase64(object.commitment) : new Uint8Array(0),
      rangeProof: isSet(object.rangeProof) ? RangeProof.fromJSON(object.rangeProof) : undefined,
      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0),
      script: isSet(object.script) ? bytesFromBase64(object.script) : new Uint8Array(0),
      senderOffsetPublicKey: isSet(object.senderOffsetPublicKey)
        ? bytesFromBase64(object.senderOffsetPublicKey)
        : new Uint8Array(0),
      metadataSignature: isSet(object.metadataSignature)
        ? ComAndPubSignature.fromJSON(object.metadataSignature)
        : undefined,
      covenant: isSet(object.covenant) ? bytesFromBase64(object.covenant) : new Uint8Array(0),
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      encryptedData: isSet(object.encryptedData) ? bytesFromBase64(object.encryptedData) : new Uint8Array(0),
      minimumValuePromise: isSet(object.minimumValuePromise) ? Long.fromValue(object.minimumValuePromise) : Long.UZERO,
    };
  },

  toJSON(message: TransactionOutput): unknown {
    const obj: any = {};
    if (message.features !== undefined) {
      obj.features = OutputFeatures.toJSON(message.features);
    }
    if (message.commitment.length !== 0) {
      obj.commitment = base64FromBytes(message.commitment);
    }
    if (message.rangeProof !== undefined) {
      obj.rangeProof = RangeProof.toJSON(message.rangeProof);
    }
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.script.length !== 0) {
      obj.script = base64FromBytes(message.script);
    }
    if (message.senderOffsetPublicKey.length !== 0) {
      obj.senderOffsetPublicKey = base64FromBytes(message.senderOffsetPublicKey);
    }
    if (message.metadataSignature !== undefined) {
      obj.metadataSignature = ComAndPubSignature.toJSON(message.metadataSignature);
    }
    if (message.covenant.length !== 0) {
      obj.covenant = base64FromBytes(message.covenant);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.encryptedData.length !== 0) {
      obj.encryptedData = base64FromBytes(message.encryptedData);
    }
    if (!message.minimumValuePromise.equals(Long.UZERO)) {
      obj.minimumValuePromise = (message.minimumValuePromise || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionOutput>, I>>(base?: I): TransactionOutput {
    return TransactionOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionOutput>, I>>(object: I): TransactionOutput {
    const message = createBaseTransactionOutput();
    message.features =
      object.features !== undefined && object.features !== null
        ? OutputFeatures.fromPartial(object.features)
        : undefined;
    message.commitment = object.commitment ?? new Uint8Array(0);
    message.rangeProof =
      object.rangeProof !== undefined && object.rangeProof !== null
        ? RangeProof.fromPartial(object.rangeProof)
        : undefined;
    message.hash = object.hash ?? new Uint8Array(0);
    message.script = object.script ?? new Uint8Array(0);
    message.senderOffsetPublicKey = object.senderOffsetPublicKey ?? new Uint8Array(0);
    message.metadataSignature =
      object.metadataSignature !== undefined && object.metadataSignature !== null
        ? ComAndPubSignature.fromPartial(object.metadataSignature)
        : undefined;
    message.covenant = object.covenant ?? new Uint8Array(0);
    message.version = object.version ?? 0;
    message.encryptedData = object.encryptedData ?? new Uint8Array(0);
    message.minimumValuePromise =
      object.minimumValuePromise !== undefined && object.minimumValuePromise !== null
        ? Long.fromValue(object.minimumValuePromise)
        : Long.UZERO;
    return message;
  },
};

function createBaseOutputFeatures(): OutputFeatures {
  return {
    version: 0,
    outputType: 0,
    maturity: Long.UZERO,
    coinbaseExtra: new Uint8Array(0),
    sidechainFeature: undefined,
    rangeProofType: 0,
  };
}

export const OutputFeatures: MessageFns<OutputFeatures> = {
  encode(message: OutputFeatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.outputType !== 0) {
      writer.uint32(16).uint32(message.outputType);
    }
    if (!message.maturity.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.maturity.toString());
    }
    if (message.coinbaseExtra.length !== 0) {
      writer.uint32(34).bytes(message.coinbaseExtra);
    }
    if (message.sidechainFeature !== undefined) {
      SideChainFeature.encode(message.sidechainFeature, writer.uint32(42).fork()).join();
    }
    if (message.rangeProofType !== 0) {
      writer.uint32(48).uint32(message.rangeProofType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputFeatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputFeatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.outputType = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maturity = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.coinbaseExtra = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sidechainFeature = SideChainFeature.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rangeProofType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputFeatures {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      outputType: isSet(object.outputType) ? globalThis.Number(object.outputType) : 0,
      maturity: isSet(object.maturity) ? Long.fromValue(object.maturity) : Long.UZERO,
      coinbaseExtra: isSet(object.coinbaseExtra) ? bytesFromBase64(object.coinbaseExtra) : new Uint8Array(0),
      sidechainFeature: isSet(object.sidechainFeature) ? SideChainFeature.fromJSON(object.sidechainFeature) : undefined,
      rangeProofType: isSet(object.rangeProofType) ? globalThis.Number(object.rangeProofType) : 0,
    };
  },

  toJSON(message: OutputFeatures): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.outputType !== 0) {
      obj.outputType = Math.round(message.outputType);
    }
    if (!message.maturity.equals(Long.UZERO)) {
      obj.maturity = (message.maturity || Long.UZERO).toString();
    }
    if (message.coinbaseExtra.length !== 0) {
      obj.coinbaseExtra = base64FromBytes(message.coinbaseExtra);
    }
    if (message.sidechainFeature !== undefined) {
      obj.sidechainFeature = SideChainFeature.toJSON(message.sidechainFeature);
    }
    if (message.rangeProofType !== 0) {
      obj.rangeProofType = Math.round(message.rangeProofType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputFeatures>, I>>(base?: I): OutputFeatures {
    return OutputFeatures.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputFeatures>, I>>(object: I): OutputFeatures {
    const message = createBaseOutputFeatures();
    message.version = object.version ?? 0;
    message.outputType = object.outputType ?? 0;
    message.maturity =
      object.maturity !== undefined && object.maturity !== null ? Long.fromValue(object.maturity) : Long.UZERO;
    message.coinbaseExtra = object.coinbaseExtra ?? new Uint8Array(0);
    message.sidechainFeature =
      object.sidechainFeature !== undefined && object.sidechainFeature !== null
        ? SideChainFeature.fromPartial(object.sidechainFeature)
        : undefined;
    message.rangeProofType = object.rangeProofType ?? 0;
    return message;
  },
};

function createBaseAggregateBody(): AggregateBody {
  return { inputs: [], outputs: [], kernels: [] };
}

export const AggregateBody: MessageFns<AggregateBody> = {
  encode(message: AggregateBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inputs) {
      TransactionInput.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.outputs) {
      TransactionOutput.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.kernels) {
      TransactionKernel.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregateBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputs.push(TransactionInput.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outputs.push(TransactionOutput.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.kernels.push(TransactionKernel.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateBody {
    return {
      inputs: globalThis.Array.isArray(object?.inputs)
        ? object.inputs.map((e: any) => TransactionInput.fromJSON(e))
        : [],
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => TransactionOutput.fromJSON(e))
        : [],
      kernels: globalThis.Array.isArray(object?.kernels)
        ? object.kernels.map((e: any) => TransactionKernel.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AggregateBody): unknown {
    const obj: any = {};
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => TransactionInput.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => TransactionOutput.toJSON(e));
    }
    if (message.kernels?.length) {
      obj.kernels = message.kernels.map((e) => TransactionKernel.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AggregateBody>, I>>(base?: I): AggregateBody {
    return AggregateBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AggregateBody>, I>>(object: I): AggregateBody {
    const message = createBaseAggregateBody();
    message.inputs = object.inputs?.map((e) => TransactionInput.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => TransactionOutput.fromPartial(e)) || [];
    message.kernels = object.kernels?.map((e) => TransactionKernel.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return { offset: new Uint8Array(0), body: undefined, scriptOffset: new Uint8Array(0) };
}

export const Transaction: MessageFns<Transaction> = {
  encode(message: Transaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset.length !== 0) {
      writer.uint32(10).bytes(message.offset);
    }
    if (message.body !== undefined) {
      AggregateBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    if (message.scriptOffset.length !== 0) {
      writer.uint32(26).bytes(message.scriptOffset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.offset = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = AggregateBody.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scriptOffset = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      offset: isSet(object.offset) ? bytesFromBase64(object.offset) : new Uint8Array(0),
      body: isSet(object.body) ? AggregateBody.fromJSON(object.body) : undefined,
      scriptOffset: isSet(object.scriptOffset) ? bytesFromBase64(object.scriptOffset) : new Uint8Array(0),
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.offset.length !== 0) {
      obj.offset = base64FromBytes(message.offset);
    }
    if (message.body !== undefined) {
      obj.body = AggregateBody.toJSON(message.body);
    }
    if (message.scriptOffset.length !== 0) {
      obj.scriptOffset = base64FromBytes(message.scriptOffset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction {
    return Transaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(object: I): Transaction {
    const message = createBaseTransaction();
    message.offset = object.offset ?? new Uint8Array(0);
    message.body =
      object.body !== undefined && object.body !== null ? AggregateBody.fromPartial(object.body) : undefined;
    message.scriptOffset = object.scriptOffset ?? new Uint8Array(0);
    return message;
  },
};

function createBaseUnblindedOutput(): UnblindedOutput {
  return {
    value: Long.UZERO,
    spendingKey: new Uint8Array(0),
    features: undefined,
    script: new Uint8Array(0),
    inputData: new Uint8Array(0),
    scriptPrivateKey: new Uint8Array(0),
    senderOffsetPublicKey: new Uint8Array(0),
    metadataSignature: undefined,
    scriptLockHeight: Long.UZERO,
    covenant: new Uint8Array(0),
    encryptedData: new Uint8Array(0),
    minimumValuePromise: Long.UZERO,
    rangeProof: undefined,
  };
}

export const UnblindedOutput: MessageFns<UnblindedOutput> = {
  encode(message: UnblindedOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.value.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.value.toString());
    }
    if (message.spendingKey.length !== 0) {
      writer.uint32(18).bytes(message.spendingKey);
    }
    if (message.features !== undefined) {
      OutputFeatures.encode(message.features, writer.uint32(26).fork()).join();
    }
    if (message.script.length !== 0) {
      writer.uint32(34).bytes(message.script);
    }
    if (message.inputData.length !== 0) {
      writer.uint32(42).bytes(message.inputData);
    }
    if (message.scriptPrivateKey.length !== 0) {
      writer.uint32(58).bytes(message.scriptPrivateKey);
    }
    if (message.senderOffsetPublicKey.length !== 0) {
      writer.uint32(66).bytes(message.senderOffsetPublicKey);
    }
    if (message.metadataSignature !== undefined) {
      ComAndPubSignature.encode(message.metadataSignature, writer.uint32(74).fork()).join();
    }
    if (!message.scriptLockHeight.equals(Long.UZERO)) {
      writer.uint32(80).uint64(message.scriptLockHeight.toString());
    }
    if (message.covenant.length !== 0) {
      writer.uint32(90).bytes(message.covenant);
    }
    if (message.encryptedData.length !== 0) {
      writer.uint32(98).bytes(message.encryptedData);
    }
    if (!message.minimumValuePromise.equals(Long.UZERO)) {
      writer.uint32(104).uint64(message.minimumValuePromise.toString());
    }
    if (message.rangeProof !== undefined) {
      RangeProof.encode(message.rangeProof, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnblindedOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnblindedOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.spendingKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.features = OutputFeatures.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.script = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inputData = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.scriptPrivateKey = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.senderOffsetPublicKey = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadataSignature = ComAndPubSignature.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.scriptLockHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.covenant = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.encryptedData = reader.bytes();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.minimumValuePromise = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.rangeProof = RangeProof.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnblindedOutput {
    return {
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.UZERO,
      spendingKey: isSet(object.spendingKey) ? bytesFromBase64(object.spendingKey) : new Uint8Array(0),
      features: isSet(object.features) ? OutputFeatures.fromJSON(object.features) : undefined,
      script: isSet(object.script) ? bytesFromBase64(object.script) : new Uint8Array(0),
      inputData: isSet(object.inputData) ? bytesFromBase64(object.inputData) : new Uint8Array(0),
      scriptPrivateKey: isSet(object.scriptPrivateKey) ? bytesFromBase64(object.scriptPrivateKey) : new Uint8Array(0),
      senderOffsetPublicKey: isSet(object.senderOffsetPublicKey)
        ? bytesFromBase64(object.senderOffsetPublicKey)
        : new Uint8Array(0),
      metadataSignature: isSet(object.metadataSignature)
        ? ComAndPubSignature.fromJSON(object.metadataSignature)
        : undefined,
      scriptLockHeight: isSet(object.scriptLockHeight) ? Long.fromValue(object.scriptLockHeight) : Long.UZERO,
      covenant: isSet(object.covenant) ? bytesFromBase64(object.covenant) : new Uint8Array(0),
      encryptedData: isSet(object.encryptedData) ? bytesFromBase64(object.encryptedData) : new Uint8Array(0),
      minimumValuePromise: isSet(object.minimumValuePromise) ? Long.fromValue(object.minimumValuePromise) : Long.UZERO,
      rangeProof: isSet(object.rangeProof) ? RangeProof.fromJSON(object.rangeProof) : undefined,
    };
  },

  toJSON(message: UnblindedOutput): unknown {
    const obj: any = {};
    if (!message.value.equals(Long.UZERO)) {
      obj.value = (message.value || Long.UZERO).toString();
    }
    if (message.spendingKey.length !== 0) {
      obj.spendingKey = base64FromBytes(message.spendingKey);
    }
    if (message.features !== undefined) {
      obj.features = OutputFeatures.toJSON(message.features);
    }
    if (message.script.length !== 0) {
      obj.script = base64FromBytes(message.script);
    }
    if (message.inputData.length !== 0) {
      obj.inputData = base64FromBytes(message.inputData);
    }
    if (message.scriptPrivateKey.length !== 0) {
      obj.scriptPrivateKey = base64FromBytes(message.scriptPrivateKey);
    }
    if (message.senderOffsetPublicKey.length !== 0) {
      obj.senderOffsetPublicKey = base64FromBytes(message.senderOffsetPublicKey);
    }
    if (message.metadataSignature !== undefined) {
      obj.metadataSignature = ComAndPubSignature.toJSON(message.metadataSignature);
    }
    if (!message.scriptLockHeight.equals(Long.UZERO)) {
      obj.scriptLockHeight = (message.scriptLockHeight || Long.UZERO).toString();
    }
    if (message.covenant.length !== 0) {
      obj.covenant = base64FromBytes(message.covenant);
    }
    if (message.encryptedData.length !== 0) {
      obj.encryptedData = base64FromBytes(message.encryptedData);
    }
    if (!message.minimumValuePromise.equals(Long.UZERO)) {
      obj.minimumValuePromise = (message.minimumValuePromise || Long.UZERO).toString();
    }
    if (message.rangeProof !== undefined) {
      obj.rangeProof = RangeProof.toJSON(message.rangeProof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnblindedOutput>, I>>(base?: I): UnblindedOutput {
    return UnblindedOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnblindedOutput>, I>>(object: I): UnblindedOutput {
    const message = createBaseUnblindedOutput();
    message.value = object.value !== undefined && object.value !== null ? Long.fromValue(object.value) : Long.UZERO;
    message.spendingKey = object.spendingKey ?? new Uint8Array(0);
    message.features =
      object.features !== undefined && object.features !== null
        ? OutputFeatures.fromPartial(object.features)
        : undefined;
    message.script = object.script ?? new Uint8Array(0);
    message.inputData = object.inputData ?? new Uint8Array(0);
    message.scriptPrivateKey = object.scriptPrivateKey ?? new Uint8Array(0);
    message.senderOffsetPublicKey = object.senderOffsetPublicKey ?? new Uint8Array(0);
    message.metadataSignature =
      object.metadataSignature !== undefined && object.metadataSignature !== null
        ? ComAndPubSignature.fromPartial(object.metadataSignature)
        : undefined;
    message.scriptLockHeight =
      object.scriptLockHeight !== undefined && object.scriptLockHeight !== null
        ? Long.fromValue(object.scriptLockHeight)
        : Long.UZERO;
    message.covenant = object.covenant ?? new Uint8Array(0);
    message.encryptedData = object.encryptedData ?? new Uint8Array(0);
    message.minimumValuePromise =
      object.minimumValuePromise !== undefined && object.minimumValuePromise !== null
        ? Long.fromValue(object.minimumValuePromise)
        : Long.UZERO;
    message.rangeProof =
      object.rangeProof !== undefined && object.rangeProof !== null
        ? RangeProof.fromPartial(object.rangeProof)
        : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
    ? string | number | Long
    : T extends globalThis.Array<infer U>
      ? globalThis.Array<DeepPartial<U>>
      : T extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : T extends {}
          ? { [K in keyof T]?: DeepPartial<T[K]> }
          : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
