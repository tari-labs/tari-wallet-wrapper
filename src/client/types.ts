// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "tari.rpc";

/**
 * Copyright 2020. The Tari Project
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 * disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/** / Output types */
export enum OutputType {
  STANDARD = 0,
  COINBASE = 1,
  BURN = 2,
  VALIDATOR_NODE_REGISTRATION = 3,
  CODE_TEMPLATE_REGISTRATION = 4,
  UNRECOGNIZED = -1,
}

export function outputTypeFromJSON(object: any): OutputType {
  switch (object) {
    case 0:
    case "STANDARD":
      return OutputType.STANDARD;
    case 1:
    case "COINBASE":
      return OutputType.COINBASE;
    case 2:
    case "BURN":
      return OutputType.BURN;
    case 3:
    case "VALIDATOR_NODE_REGISTRATION":
      return OutputType.VALIDATOR_NODE_REGISTRATION;
    case 4:
    case "CODE_TEMPLATE_REGISTRATION":
      return OutputType.CODE_TEMPLATE_REGISTRATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OutputType.UNRECOGNIZED;
  }
}

export function outputTypeToJSON(object: OutputType): string {
  switch (object) {
    case OutputType.STANDARD:
      return "STANDARD";
    case OutputType.COINBASE:
      return "COINBASE";
    case OutputType.BURN:
      return "BURN";
    case OutputType.VALIDATOR_NODE_REGISTRATION:
      return "VALIDATOR_NODE_REGISTRATION";
    case OutputType.CODE_TEMPLATE_REGISTRATION:
      return "CODE_TEMPLATE_REGISTRATION";
    case OutputType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** / Range proof types */
export enum RangeProofType {
  BULLETPROOF_PLUS = 0,
  REVEALED_VALUE = 1,
  UNRECOGNIZED = -1,
}

export function rangeProofTypeFromJSON(object: any): RangeProofType {
  switch (object) {
    case 0:
    case "BULLETPROOF_PLUS":
      return RangeProofType.BULLETPROOF_PLUS;
    case 1:
    case "REVEALED_VALUE":
      return RangeProofType.REVEALED_VALUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RangeProofType.UNRECOGNIZED;
  }
}

export function rangeProofTypeToJSON(object: RangeProofType): string {
  switch (object) {
    case RangeProofType.BULLETPROOF_PLUS:
      return "BULLETPROOF_PLUS";
    case RangeProofType.REVEALED_VALUE:
      return "REVEALED_VALUE";
    case RangeProofType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** / An unsigned range interface to more accurately represent Rust native Range's */
export interface Range {
  min: Long;
  max: Long;
}

/** / An Empty placeholder for endpoints without request parameters */
export interface Empty {}

/** / Define an interface for block height */
export interface BlockHeight {
  blockHeight: Long;
}

/**
 * Define the explicit Signature implementation for the Minotari base layer. A different signature scheme can be
 * employed by redefining this type.
 */
export interface Signature {
  publicNonce: Uint8Array;
  signature: Uint8Array;
}

/**
 * Define the explicit ComAndPubSignature implementation for the Minotari base layer. A different signature scheme can be
 * employed by redefining this type.
 */
export interface ComAndPubSignature {
  ephemeralCommitment: Uint8Array;
  ephemeralPubkey: Uint8Array;
  uA: Uint8Array;
  uX: Uint8Array;
  uY: Uint8Array;
}

/**
 * Define the explicit CommitmentSignature implementation for the Minotari base layer. A different signature scheme can be
 * employed by redefining this type
 */
export interface CommitmentSignature {
  publicNonce: Uint8Array;
  u: Uint8Array;
  v: Uint8Array;
}

/** / PoW Algorithm constants */
export interface PowAlgorithmConstants {
  minDifficulty: Long;
  maxDifficulty: Long;
  targetTime: Long;
}

/** / Weight params */
export interface WeightParams {
  kernelWeight: Long;
  inputWeight: Long;
  outputWeight: Long;
  featuresAndScriptsBytesPerGram: Long;
}

/** / Output version */
export interface OutputsVersion {
  outputs: Range | undefined;
  features: Range | undefined;
}

export interface PermittedRangeProofs {
  outputType: OutputType;
  rangeProofTypes: RangeProofType[];
}

/** / Range proof */
export interface RangeProof {
  proofBytes: Uint8Array;
}

/** / Consensus Constants response */
export interface ConsensusConstants {
  coinbaseMinMaturity: Long;
  blockchainVersion: number;
  futureTimeLimit: Long;
  difficultyBlockWindow: Long;
  maxBlockTransactionWeight: Long;
  powAlgoCount: Long;
  medianTimestampCount: Long;
  emissionInitial: Long;
  emissionDecay: Long[];
  /** @deprecated */
  emissionTail: Long;
  minSha3xPowDifficulty: Long;
  blockWeightInputs: Long;
  blockWeightOutputs: Long;
  blockWeightKernels: Long;
  preMineValue: Long;
  maxScriptByteSize: Long;
  effectiveFromHeight: Long;
  validBlockchainVersionRange: Range | undefined;
  maxRandomxSeedHeight: Long;
  proofOfWork: { [key: number]: PowAlgorithmConstants };
  transactionWeight: WeightParams | undefined;
  inputVersionRange: Range | undefined;
  outputVersionRange: OutputsVersion | undefined;
  kernelVersionRange: Range | undefined;
  permittedOutputTypes: OutputType[];
  epochLength: Long;
  validatorNodeRegistrationMinDepositAmount: Long;
  validatorNodeRegistrationMinLockHeight: Long;
  validatorNodeRegistrationShuffleIntervalEpoch: Long;
  permittedRangeProofTypes: PermittedRangeProofs[];
  inflationBips: Long;
  tailEpochLength: Long;
  maxBlockCoinbaseCount: Long;
  vnRegistrationMaxVnsInitialEpoch: number;
  vnRegistrationMaxVnsPerEpoch: number;
}

export interface ConsensusConstants_ProofOfWorkEntry {
  key: number;
  value: PowAlgorithmConstants | undefined;
}

/**
 * Unsigned decimal value, examples:
 *   12345.6789 -> { units = 12345, nanos = 678900000 }
 *   12345.0006789 -> { units = 12345, nanos = 678900 }
 */
export interface UDecimalValue {
  /** Whole units part of the amount */
  units: Long;
  /** Nano units of the amount (10^-9) */
  nanos: number;
}

function createBaseRange(): Range {
  return { min: Long.UZERO, max: Long.UZERO };
}

export const Range: MessageFns<Range> = {
  encode(message: Range, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.min.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.min.toString());
    }
    if (!message.max.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.max.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Range {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.min = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.max = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Range {
    return {
      min: isSet(object.min) ? Long.fromValue(object.min) : Long.UZERO,
      max: isSet(object.max) ? Long.fromValue(object.max) : Long.UZERO,
    };
  },

  toJSON(message: Range): unknown {
    const obj: any = {};
    if (!message.min.equals(Long.UZERO)) {
      obj.min = (message.min || Long.UZERO).toString();
    }
    if (!message.max.equals(Long.UZERO)) {
      obj.max = (message.max || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Range>, I>>(base?: I): Range {
    return Range.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Range>, I>>(object: I): Range {
    const message = createBaseRange();
    message.min = object.min !== undefined && object.min !== null ? Long.fromValue(object.min) : Long.UZERO;
    message.max = object.max !== undefined && object.max !== null ? Long.fromValue(object.max) : Long.UZERO;
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseBlockHeight(): BlockHeight {
  return { blockHeight: Long.UZERO };
}

export const BlockHeight: MessageFns<BlockHeight> = {
  encode(message: BlockHeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.blockHeight.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.blockHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeight {
    return { blockHeight: isSet(object.blockHeight) ? Long.fromValue(object.blockHeight) : Long.UZERO };
  },

  toJSON(message: BlockHeight): unknown {
    const obj: any = {};
    if (!message.blockHeight.equals(Long.UZERO)) {
      obj.blockHeight = (message.blockHeight || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockHeight>, I>>(base?: I): BlockHeight {
    return BlockHeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockHeight>, I>>(object: I): BlockHeight {
    const message = createBaseBlockHeight();
    message.blockHeight =
      object.blockHeight !== undefined && object.blockHeight !== null ? Long.fromValue(object.blockHeight) : Long.UZERO;
    return message;
  },
};

function createBaseSignature(): Signature {
  return { publicNonce: new Uint8Array(0), signature: new Uint8Array(0) };
}

export const Signature: MessageFns<Signature> = {
  encode(message: Signature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicNonce.length !== 0) {
      writer.uint32(10).bytes(message.publicNonce);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Signature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicNonce = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Signature {
    return {
      publicNonce: isSet(object.publicNonce) ? bytesFromBase64(object.publicNonce) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: Signature): unknown {
    const obj: any = {};
    if (message.publicNonce.length !== 0) {
      obj.publicNonce = base64FromBytes(message.publicNonce);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Signature>, I>>(base?: I): Signature {
    return Signature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Signature>, I>>(object: I): Signature {
    const message = createBaseSignature();
    message.publicNonce = object.publicNonce ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseComAndPubSignature(): ComAndPubSignature {
  return {
    ephemeralCommitment: new Uint8Array(0),
    ephemeralPubkey: new Uint8Array(0),
    uA: new Uint8Array(0),
    uX: new Uint8Array(0),
    uY: new Uint8Array(0),
  };
}

export const ComAndPubSignature: MessageFns<ComAndPubSignature> = {
  encode(message: ComAndPubSignature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ephemeralCommitment.length !== 0) {
      writer.uint32(10).bytes(message.ephemeralCommitment);
    }
    if (message.ephemeralPubkey.length !== 0) {
      writer.uint32(18).bytes(message.ephemeralPubkey);
    }
    if (message.uA.length !== 0) {
      writer.uint32(26).bytes(message.uA);
    }
    if (message.uX.length !== 0) {
      writer.uint32(34).bytes(message.uX);
    }
    if (message.uY.length !== 0) {
      writer.uint32(42).bytes(message.uY);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComAndPubSignature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComAndPubSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ephemeralCommitment = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ephemeralPubkey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uA = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uX = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.uY = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComAndPubSignature {
    return {
      ephemeralCommitment: isSet(object.ephemeralCommitment)
        ? bytesFromBase64(object.ephemeralCommitment)
        : new Uint8Array(0),
      ephemeralPubkey: isSet(object.ephemeralPubkey) ? bytesFromBase64(object.ephemeralPubkey) : new Uint8Array(0),
      uA: isSet(object.uA) ? bytesFromBase64(object.uA) : new Uint8Array(0),
      uX: isSet(object.uX) ? bytesFromBase64(object.uX) : new Uint8Array(0),
      uY: isSet(object.uY) ? bytesFromBase64(object.uY) : new Uint8Array(0),
    };
  },

  toJSON(message: ComAndPubSignature): unknown {
    const obj: any = {};
    if (message.ephemeralCommitment.length !== 0) {
      obj.ephemeralCommitment = base64FromBytes(message.ephemeralCommitment);
    }
    if (message.ephemeralPubkey.length !== 0) {
      obj.ephemeralPubkey = base64FromBytes(message.ephemeralPubkey);
    }
    if (message.uA.length !== 0) {
      obj.uA = base64FromBytes(message.uA);
    }
    if (message.uX.length !== 0) {
      obj.uX = base64FromBytes(message.uX);
    }
    if (message.uY.length !== 0) {
      obj.uY = base64FromBytes(message.uY);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComAndPubSignature>, I>>(base?: I): ComAndPubSignature {
    return ComAndPubSignature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComAndPubSignature>, I>>(object: I): ComAndPubSignature {
    const message = createBaseComAndPubSignature();
    message.ephemeralCommitment = object.ephemeralCommitment ?? new Uint8Array(0);
    message.ephemeralPubkey = object.ephemeralPubkey ?? new Uint8Array(0);
    message.uA = object.uA ?? new Uint8Array(0);
    message.uX = object.uX ?? new Uint8Array(0);
    message.uY = object.uY ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCommitmentSignature(): CommitmentSignature {
  return { publicNonce: new Uint8Array(0), u: new Uint8Array(0), v: new Uint8Array(0) };
}

export const CommitmentSignature: MessageFns<CommitmentSignature> = {
  encode(message: CommitmentSignature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicNonce.length !== 0) {
      writer.uint32(10).bytes(message.publicNonce);
    }
    if (message.u.length !== 0) {
      writer.uint32(18).bytes(message.u);
    }
    if (message.v.length !== 0) {
      writer.uint32(26).bytes(message.v);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitmentSignature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitmentSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicNonce = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.u = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.v = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitmentSignature {
    return {
      publicNonce: isSet(object.publicNonce) ? bytesFromBase64(object.publicNonce) : new Uint8Array(0),
      u: isSet(object.u) ? bytesFromBase64(object.u) : new Uint8Array(0),
      v: isSet(object.v) ? bytesFromBase64(object.v) : new Uint8Array(0),
    };
  },

  toJSON(message: CommitmentSignature): unknown {
    const obj: any = {};
    if (message.publicNonce.length !== 0) {
      obj.publicNonce = base64FromBytes(message.publicNonce);
    }
    if (message.u.length !== 0) {
      obj.u = base64FromBytes(message.u);
    }
    if (message.v.length !== 0) {
      obj.v = base64FromBytes(message.v);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitmentSignature>, I>>(base?: I): CommitmentSignature {
    return CommitmentSignature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitmentSignature>, I>>(object: I): CommitmentSignature {
    const message = createBaseCommitmentSignature();
    message.publicNonce = object.publicNonce ?? new Uint8Array(0);
    message.u = object.u ?? new Uint8Array(0);
    message.v = object.v ?? new Uint8Array(0);
    return message;
  },
};

function createBasePowAlgorithmConstants(): PowAlgorithmConstants {
  return { minDifficulty: Long.UZERO, maxDifficulty: Long.UZERO, targetTime: Long.UZERO };
}

export const PowAlgorithmConstants: MessageFns<PowAlgorithmConstants> = {
  encode(message: PowAlgorithmConstants, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.minDifficulty.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.minDifficulty.toString());
    }
    if (!message.maxDifficulty.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.maxDifficulty.toString());
    }
    if (!message.targetTime.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.targetTime.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PowAlgorithmConstants {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePowAlgorithmConstants();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.minDifficulty = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxDifficulty = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.targetTime = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PowAlgorithmConstants {
    return {
      minDifficulty: isSet(object.minDifficulty) ? Long.fromValue(object.minDifficulty) : Long.UZERO,
      maxDifficulty: isSet(object.maxDifficulty) ? Long.fromValue(object.maxDifficulty) : Long.UZERO,
      targetTime: isSet(object.targetTime) ? Long.fromValue(object.targetTime) : Long.UZERO,
    };
  },

  toJSON(message: PowAlgorithmConstants): unknown {
    const obj: any = {};
    if (!message.minDifficulty.equals(Long.UZERO)) {
      obj.minDifficulty = (message.minDifficulty || Long.UZERO).toString();
    }
    if (!message.maxDifficulty.equals(Long.UZERO)) {
      obj.maxDifficulty = (message.maxDifficulty || Long.UZERO).toString();
    }
    if (!message.targetTime.equals(Long.UZERO)) {
      obj.targetTime = (message.targetTime || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PowAlgorithmConstants>, I>>(base?: I): PowAlgorithmConstants {
    return PowAlgorithmConstants.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PowAlgorithmConstants>, I>>(object: I): PowAlgorithmConstants {
    const message = createBasePowAlgorithmConstants();
    message.minDifficulty =
      object.minDifficulty !== undefined && object.minDifficulty !== null
        ? Long.fromValue(object.minDifficulty)
        : Long.UZERO;
    message.maxDifficulty =
      object.maxDifficulty !== undefined && object.maxDifficulty !== null
        ? Long.fromValue(object.maxDifficulty)
        : Long.UZERO;
    message.targetTime =
      object.targetTime !== undefined && object.targetTime !== null ? Long.fromValue(object.targetTime) : Long.UZERO;
    return message;
  },
};

function createBaseWeightParams(): WeightParams {
  return {
    kernelWeight: Long.UZERO,
    inputWeight: Long.UZERO,
    outputWeight: Long.UZERO,
    featuresAndScriptsBytesPerGram: Long.UZERO,
  };
}

export const WeightParams: MessageFns<WeightParams> = {
  encode(message: WeightParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.kernelWeight.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.kernelWeight.toString());
    }
    if (!message.inputWeight.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.inputWeight.toString());
    }
    if (!message.outputWeight.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.outputWeight.toString());
    }
    if (!message.featuresAndScriptsBytesPerGram.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.featuresAndScriptsBytesPerGram.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeightParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeightParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.kernelWeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inputWeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.outputWeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.featuresAndScriptsBytesPerGram = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeightParams {
    return {
      kernelWeight: isSet(object.kernelWeight) ? Long.fromValue(object.kernelWeight) : Long.UZERO,
      inputWeight: isSet(object.inputWeight) ? Long.fromValue(object.inputWeight) : Long.UZERO,
      outputWeight: isSet(object.outputWeight) ? Long.fromValue(object.outputWeight) : Long.UZERO,
      featuresAndScriptsBytesPerGram: isSet(object.featuresAndScriptsBytesPerGram)
        ? Long.fromValue(object.featuresAndScriptsBytesPerGram)
        : Long.UZERO,
    };
  },

  toJSON(message: WeightParams): unknown {
    const obj: any = {};
    if (!message.kernelWeight.equals(Long.UZERO)) {
      obj.kernelWeight = (message.kernelWeight || Long.UZERO).toString();
    }
    if (!message.inputWeight.equals(Long.UZERO)) {
      obj.inputWeight = (message.inputWeight || Long.UZERO).toString();
    }
    if (!message.outputWeight.equals(Long.UZERO)) {
      obj.outputWeight = (message.outputWeight || Long.UZERO).toString();
    }
    if (!message.featuresAndScriptsBytesPerGram.equals(Long.UZERO)) {
      obj.featuresAndScriptsBytesPerGram = (message.featuresAndScriptsBytesPerGram || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WeightParams>, I>>(base?: I): WeightParams {
    return WeightParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WeightParams>, I>>(object: I): WeightParams {
    const message = createBaseWeightParams();
    message.kernelWeight =
      object.kernelWeight !== undefined && object.kernelWeight !== null
        ? Long.fromValue(object.kernelWeight)
        : Long.UZERO;
    message.inputWeight =
      object.inputWeight !== undefined && object.inputWeight !== null ? Long.fromValue(object.inputWeight) : Long.UZERO;
    message.outputWeight =
      object.outputWeight !== undefined && object.outputWeight !== null
        ? Long.fromValue(object.outputWeight)
        : Long.UZERO;
    message.featuresAndScriptsBytesPerGram =
      object.featuresAndScriptsBytesPerGram !== undefined && object.featuresAndScriptsBytesPerGram !== null
        ? Long.fromValue(object.featuresAndScriptsBytesPerGram)
        : Long.UZERO;
    return message;
  },
};

function createBaseOutputsVersion(): OutputsVersion {
  return { outputs: undefined, features: undefined };
}

export const OutputsVersion: MessageFns<OutputsVersion> = {
  encode(message: OutputsVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputs !== undefined) {
      Range.encode(message.outputs, writer.uint32(10).fork()).join();
    }
    if (message.features !== undefined) {
      Range.encode(message.features, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputsVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputsVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputs = Range.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.features = Range.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputsVersion {
    return {
      outputs: isSet(object.outputs) ? Range.fromJSON(object.outputs) : undefined,
      features: isSet(object.features) ? Range.fromJSON(object.features) : undefined,
    };
  },

  toJSON(message: OutputsVersion): unknown {
    const obj: any = {};
    if (message.outputs !== undefined) {
      obj.outputs = Range.toJSON(message.outputs);
    }
    if (message.features !== undefined) {
      obj.features = Range.toJSON(message.features);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputsVersion>, I>>(base?: I): OutputsVersion {
    return OutputsVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputsVersion>, I>>(object: I): OutputsVersion {
    const message = createBaseOutputsVersion();
    message.outputs =
      object.outputs !== undefined && object.outputs !== null ? Range.fromPartial(object.outputs) : undefined;
    message.features =
      object.features !== undefined && object.features !== null ? Range.fromPartial(object.features) : undefined;
    return message;
  },
};

function createBasePermittedRangeProofs(): PermittedRangeProofs {
  return { outputType: 0, rangeProofTypes: [] };
}

export const PermittedRangeProofs: MessageFns<PermittedRangeProofs> = {
  encode(message: PermittedRangeProofs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputType !== 0) {
      writer.uint32(8).int32(message.outputType);
    }
    writer.uint32(18).fork();
    for (const v of message.rangeProofTypes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermittedRangeProofs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermittedRangeProofs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.outputType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.rangeProofTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rangeProofTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermittedRangeProofs {
    return {
      outputType: isSet(object.outputType) ? outputTypeFromJSON(object.outputType) : 0,
      rangeProofTypes: globalThis.Array.isArray(object?.rangeProofTypes)
        ? object.rangeProofTypes.map((e: any) => rangeProofTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: PermittedRangeProofs): unknown {
    const obj: any = {};
    if (message.outputType !== 0) {
      obj.outputType = outputTypeToJSON(message.outputType);
    }
    if (message.rangeProofTypes?.length) {
      obj.rangeProofTypes = message.rangeProofTypes.map((e) => rangeProofTypeToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermittedRangeProofs>, I>>(base?: I): PermittedRangeProofs {
    return PermittedRangeProofs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermittedRangeProofs>, I>>(object: I): PermittedRangeProofs {
    const message = createBasePermittedRangeProofs();
    message.outputType = object.outputType ?? 0;
    message.rangeProofTypes = object.rangeProofTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseRangeProof(): RangeProof {
  return { proofBytes: new Uint8Array(0) };
}

export const RangeProof: MessageFns<RangeProof> = {
  encode(message: RangeProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proofBytes.length !== 0) {
      writer.uint32(10).bytes(message.proofBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RangeProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRangeProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RangeProof {
    return { proofBytes: isSet(object.proofBytes) ? bytesFromBase64(object.proofBytes) : new Uint8Array(0) };
  },

  toJSON(message: RangeProof): unknown {
    const obj: any = {};
    if (message.proofBytes.length !== 0) {
      obj.proofBytes = base64FromBytes(message.proofBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RangeProof>, I>>(base?: I): RangeProof {
    return RangeProof.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RangeProof>, I>>(object: I): RangeProof {
    const message = createBaseRangeProof();
    message.proofBytes = object.proofBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseConsensusConstants(): ConsensusConstants {
  return {
    coinbaseMinMaturity: Long.UZERO,
    blockchainVersion: 0,
    futureTimeLimit: Long.UZERO,
    difficultyBlockWindow: Long.UZERO,
    maxBlockTransactionWeight: Long.UZERO,
    powAlgoCount: Long.UZERO,
    medianTimestampCount: Long.UZERO,
    emissionInitial: Long.UZERO,
    emissionDecay: [],
    emissionTail: Long.UZERO,
    minSha3xPowDifficulty: Long.UZERO,
    blockWeightInputs: Long.UZERO,
    blockWeightOutputs: Long.UZERO,
    blockWeightKernels: Long.UZERO,
    preMineValue: Long.UZERO,
    maxScriptByteSize: Long.UZERO,
    effectiveFromHeight: Long.UZERO,
    validBlockchainVersionRange: undefined,
    maxRandomxSeedHeight: Long.UZERO,
    proofOfWork: {},
    transactionWeight: undefined,
    inputVersionRange: undefined,
    outputVersionRange: undefined,
    kernelVersionRange: undefined,
    permittedOutputTypes: [],
    epochLength: Long.UZERO,
    validatorNodeRegistrationMinDepositAmount: Long.UZERO,
    validatorNodeRegistrationMinLockHeight: Long.UZERO,
    validatorNodeRegistrationShuffleIntervalEpoch: Long.UZERO,
    permittedRangeProofTypes: [],
    inflationBips: Long.UZERO,
    tailEpochLength: Long.UZERO,
    maxBlockCoinbaseCount: Long.UZERO,
    vnRegistrationMaxVnsInitialEpoch: 0,
    vnRegistrationMaxVnsPerEpoch: 0,
  };
}

export const ConsensusConstants: MessageFns<ConsensusConstants> = {
  encode(message: ConsensusConstants, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.coinbaseMinMaturity.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.coinbaseMinMaturity.toString());
    }
    if (message.blockchainVersion !== 0) {
      writer.uint32(16).uint32(message.blockchainVersion);
    }
    if (!message.futureTimeLimit.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.futureTimeLimit.toString());
    }
    if (!message.difficultyBlockWindow.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.difficultyBlockWindow.toString());
    }
    if (!message.maxBlockTransactionWeight.equals(Long.UZERO)) {
      writer.uint32(56).uint64(message.maxBlockTransactionWeight.toString());
    }
    if (!message.powAlgoCount.equals(Long.UZERO)) {
      writer.uint32(64).uint64(message.powAlgoCount.toString());
    }
    if (!message.medianTimestampCount.equals(Long.UZERO)) {
      writer.uint32(72).uint64(message.medianTimestampCount.toString());
    }
    if (!message.emissionInitial.equals(Long.UZERO)) {
      writer.uint32(80).uint64(message.emissionInitial.toString());
    }
    writer.uint32(90).fork();
    for (const v of message.emissionDecay) {
      writer.uint64(v.toString());
    }
    writer.join();
    if (!message.emissionTail.equals(Long.UZERO)) {
      writer.uint32(96).uint64(message.emissionTail.toString());
    }
    if (!message.minSha3xPowDifficulty.equals(Long.UZERO)) {
      writer.uint32(104).uint64(message.minSha3xPowDifficulty.toString());
    }
    if (!message.blockWeightInputs.equals(Long.UZERO)) {
      writer.uint32(112).uint64(message.blockWeightInputs.toString());
    }
    if (!message.blockWeightOutputs.equals(Long.UZERO)) {
      writer.uint32(120).uint64(message.blockWeightOutputs.toString());
    }
    if (!message.blockWeightKernels.equals(Long.UZERO)) {
      writer.uint32(128).uint64(message.blockWeightKernels.toString());
    }
    if (!message.preMineValue.equals(Long.UZERO)) {
      writer.uint32(136).uint64(message.preMineValue.toString());
    }
    if (!message.maxScriptByteSize.equals(Long.UZERO)) {
      writer.uint32(144).uint64(message.maxScriptByteSize.toString());
    }
    if (!message.effectiveFromHeight.equals(Long.UZERO)) {
      writer.uint32(160).uint64(message.effectiveFromHeight.toString());
    }
    if (message.validBlockchainVersionRange !== undefined) {
      Range.encode(message.validBlockchainVersionRange, writer.uint32(170).fork()).join();
    }
    if (!message.maxRandomxSeedHeight.equals(Long.UZERO)) {
      writer.uint32(176).uint64(message.maxRandomxSeedHeight.toString());
    }
    Object.entries(message.proofOfWork).forEach(([key, value]) => {
      ConsensusConstants_ProofOfWorkEntry.encode({ key: key as any, value }, writer.uint32(186).fork()).join();
    });
    if (message.transactionWeight !== undefined) {
      WeightParams.encode(message.transactionWeight, writer.uint32(194).fork()).join();
    }
    if (message.inputVersionRange !== undefined) {
      Range.encode(message.inputVersionRange, writer.uint32(210).fork()).join();
    }
    if (message.outputVersionRange !== undefined) {
      OutputsVersion.encode(message.outputVersionRange, writer.uint32(218).fork()).join();
    }
    if (message.kernelVersionRange !== undefined) {
      Range.encode(message.kernelVersionRange, writer.uint32(226).fork()).join();
    }
    writer.uint32(234).fork();
    for (const v of message.permittedOutputTypes) {
      writer.int32(v);
    }
    writer.join();
    if (!message.epochLength.equals(Long.UZERO)) {
      writer.uint32(240).uint64(message.epochLength.toString());
    }
    if (!message.validatorNodeRegistrationMinDepositAmount.equals(Long.UZERO)) {
      writer.uint32(248).uint64(message.validatorNodeRegistrationMinDepositAmount.toString());
    }
    if (!message.validatorNodeRegistrationMinLockHeight.equals(Long.UZERO)) {
      writer.uint32(256).uint64(message.validatorNodeRegistrationMinLockHeight.toString());
    }
    if (!message.validatorNodeRegistrationShuffleIntervalEpoch.equals(Long.UZERO)) {
      writer.uint32(264).uint64(message.validatorNodeRegistrationShuffleIntervalEpoch.toString());
    }
    for (const v of message.permittedRangeProofTypes) {
      PermittedRangeProofs.encode(v!, writer.uint32(274).fork()).join();
    }
    if (!message.inflationBips.equals(Long.UZERO)) {
      writer.uint32(280).uint64(message.inflationBips.toString());
    }
    if (!message.tailEpochLength.equals(Long.UZERO)) {
      writer.uint32(288).uint64(message.tailEpochLength.toString());
    }
    if (!message.maxBlockCoinbaseCount.equals(Long.UZERO)) {
      writer.uint32(296).uint64(message.maxBlockCoinbaseCount.toString());
    }
    if (message.vnRegistrationMaxVnsInitialEpoch !== 0) {
      writer.uint32(304).uint32(message.vnRegistrationMaxVnsInitialEpoch);
    }
    if (message.vnRegistrationMaxVnsPerEpoch !== 0) {
      writer.uint32(312).uint32(message.vnRegistrationMaxVnsPerEpoch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsensusConstants {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsensusConstants();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.coinbaseMinMaturity = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockchainVersion = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.futureTimeLimit = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.difficultyBlockWindow = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxBlockTransactionWeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.powAlgoCount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.medianTimestampCount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.emissionInitial = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 11: {
          if (tag === 88) {
            message.emissionDecay.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.emissionDecay.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.emissionTail = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.minSha3xPowDifficulty = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.blockWeightInputs = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.blockWeightOutputs = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.blockWeightKernels = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.preMineValue = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.maxScriptByteSize = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.effectiveFromHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.validBlockchainVersionRange = Range.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.maxRandomxSeedHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          const entry23 = ConsensusConstants_ProofOfWorkEntry.decode(reader, reader.uint32());
          if (entry23.value !== undefined) {
            message.proofOfWork[entry23.key] = entry23.value;
          }
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.transactionWeight = WeightParams.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.inputVersionRange = Range.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.outputVersionRange = OutputsVersion.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.kernelVersionRange = Range.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag === 232) {
            message.permittedOutputTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 234) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.permittedOutputTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.epochLength = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.validatorNodeRegistrationMinDepositAmount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.validatorNodeRegistrationMinLockHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.validatorNodeRegistrationShuffleIntervalEpoch = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.permittedRangeProofTypes.push(PermittedRangeProofs.decode(reader, reader.uint32()));
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.inflationBips = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.tailEpochLength = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.maxBlockCoinbaseCount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }

          message.vnRegistrationMaxVnsInitialEpoch = reader.uint32();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.vnRegistrationMaxVnsPerEpoch = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsensusConstants {
    return {
      coinbaseMinMaturity: isSet(object.coinbaseMinMaturity) ? Long.fromValue(object.coinbaseMinMaturity) : Long.UZERO,
      blockchainVersion: isSet(object.blockchainVersion) ? globalThis.Number(object.blockchainVersion) : 0,
      futureTimeLimit: isSet(object.futureTimeLimit) ? Long.fromValue(object.futureTimeLimit) : Long.UZERO,
      difficultyBlockWindow: isSet(object.difficultyBlockWindow)
        ? Long.fromValue(object.difficultyBlockWindow)
        : Long.UZERO,
      maxBlockTransactionWeight: isSet(object.maxBlockTransactionWeight)
        ? Long.fromValue(object.maxBlockTransactionWeight)
        : Long.UZERO,
      powAlgoCount: isSet(object.powAlgoCount) ? Long.fromValue(object.powAlgoCount) : Long.UZERO,
      medianTimestampCount: isSet(object.medianTimestampCount)
        ? Long.fromValue(object.medianTimestampCount)
        : Long.UZERO,
      emissionInitial: isSet(object.emissionInitial) ? Long.fromValue(object.emissionInitial) : Long.UZERO,
      emissionDecay: globalThis.Array.isArray(object?.emissionDecay)
        ? object.emissionDecay.map((e: any) => Long.fromValue(e))
        : [],
      emissionTail: isSet(object.emissionTail) ? Long.fromValue(object.emissionTail) : Long.UZERO,
      minSha3xPowDifficulty: isSet(object.minSha3xPowDifficulty)
        ? Long.fromValue(object.minSha3xPowDifficulty)
        : Long.UZERO,
      blockWeightInputs: isSet(object.blockWeightInputs) ? Long.fromValue(object.blockWeightInputs) : Long.UZERO,
      blockWeightOutputs: isSet(object.blockWeightOutputs) ? Long.fromValue(object.blockWeightOutputs) : Long.UZERO,
      blockWeightKernels: isSet(object.blockWeightKernels) ? Long.fromValue(object.blockWeightKernels) : Long.UZERO,
      preMineValue: isSet(object.preMineValue) ? Long.fromValue(object.preMineValue) : Long.UZERO,
      maxScriptByteSize: isSet(object.maxScriptByteSize) ? Long.fromValue(object.maxScriptByteSize) : Long.UZERO,
      effectiveFromHeight: isSet(object.effectiveFromHeight) ? Long.fromValue(object.effectiveFromHeight) : Long.UZERO,
      validBlockchainVersionRange: isSet(object.validBlockchainVersionRange)
        ? Range.fromJSON(object.validBlockchainVersionRange)
        : undefined,
      maxRandomxSeedHeight: isSet(object.maxRandomxSeedHeight)
        ? Long.fromValue(object.maxRandomxSeedHeight)
        : Long.UZERO,
      proofOfWork: isObject(object.proofOfWork)
        ? Object.entries(object.proofOfWork).reduce<{ [key: number]: PowAlgorithmConstants }>((acc, [key, value]) => {
            acc[globalThis.Number(key)] = PowAlgorithmConstants.fromJSON(value);
            return acc;
          }, {})
        : {},
      transactionWeight: isSet(object.transactionWeight) ? WeightParams.fromJSON(object.transactionWeight) : undefined,
      inputVersionRange: isSet(object.inputVersionRange) ? Range.fromJSON(object.inputVersionRange) : undefined,
      outputVersionRange: isSet(object.outputVersionRange)
        ? OutputsVersion.fromJSON(object.outputVersionRange)
        : undefined,
      kernelVersionRange: isSet(object.kernelVersionRange) ? Range.fromJSON(object.kernelVersionRange) : undefined,
      permittedOutputTypes: globalThis.Array.isArray(object?.permittedOutputTypes)
        ? object.permittedOutputTypes.map((e: any) => outputTypeFromJSON(e))
        : [],
      epochLength: isSet(object.epochLength) ? Long.fromValue(object.epochLength) : Long.UZERO,
      validatorNodeRegistrationMinDepositAmount: isSet(object.validatorNodeRegistrationMinDepositAmount)
        ? Long.fromValue(object.validatorNodeRegistrationMinDepositAmount)
        : Long.UZERO,
      validatorNodeRegistrationMinLockHeight: isSet(object.validatorNodeRegistrationMinLockHeight)
        ? Long.fromValue(object.validatorNodeRegistrationMinLockHeight)
        : Long.UZERO,
      validatorNodeRegistrationShuffleIntervalEpoch: isSet(object.validatorNodeRegistrationShuffleIntervalEpoch)
        ? Long.fromValue(object.validatorNodeRegistrationShuffleIntervalEpoch)
        : Long.UZERO,
      permittedRangeProofTypes: globalThis.Array.isArray(object?.permittedRangeProofTypes)
        ? object.permittedRangeProofTypes.map((e: any) => PermittedRangeProofs.fromJSON(e))
        : [],
      inflationBips: isSet(object.inflationBips) ? Long.fromValue(object.inflationBips) : Long.UZERO,
      tailEpochLength: isSet(object.tailEpochLength) ? Long.fromValue(object.tailEpochLength) : Long.UZERO,
      maxBlockCoinbaseCount: isSet(object.maxBlockCoinbaseCount)
        ? Long.fromValue(object.maxBlockCoinbaseCount)
        : Long.UZERO,
      vnRegistrationMaxVnsInitialEpoch: isSet(object.vnRegistrationMaxVnsInitialEpoch)
        ? globalThis.Number(object.vnRegistrationMaxVnsInitialEpoch)
        : 0,
      vnRegistrationMaxVnsPerEpoch: isSet(object.vnRegistrationMaxVnsPerEpoch)
        ? globalThis.Number(object.vnRegistrationMaxVnsPerEpoch)
        : 0,
    };
  },

  toJSON(message: ConsensusConstants): unknown {
    const obj: any = {};
    if (!message.coinbaseMinMaturity.equals(Long.UZERO)) {
      obj.coinbaseMinMaturity = (message.coinbaseMinMaturity || Long.UZERO).toString();
    }
    if (message.blockchainVersion !== 0) {
      obj.blockchainVersion = Math.round(message.blockchainVersion);
    }
    if (!message.futureTimeLimit.equals(Long.UZERO)) {
      obj.futureTimeLimit = (message.futureTimeLimit || Long.UZERO).toString();
    }
    if (!message.difficultyBlockWindow.equals(Long.UZERO)) {
      obj.difficultyBlockWindow = (message.difficultyBlockWindow || Long.UZERO).toString();
    }
    if (!message.maxBlockTransactionWeight.equals(Long.UZERO)) {
      obj.maxBlockTransactionWeight = (message.maxBlockTransactionWeight || Long.UZERO).toString();
    }
    if (!message.powAlgoCount.equals(Long.UZERO)) {
      obj.powAlgoCount = (message.powAlgoCount || Long.UZERO).toString();
    }
    if (!message.medianTimestampCount.equals(Long.UZERO)) {
      obj.medianTimestampCount = (message.medianTimestampCount || Long.UZERO).toString();
    }
    if (!message.emissionInitial.equals(Long.UZERO)) {
      obj.emissionInitial = (message.emissionInitial || Long.UZERO).toString();
    }
    if (message.emissionDecay?.length) {
      obj.emissionDecay = message.emissionDecay.map((e) => (e || Long.UZERO).toString());
    }
    if (!message.emissionTail.equals(Long.UZERO)) {
      obj.emissionTail = (message.emissionTail || Long.UZERO).toString();
    }
    if (!message.minSha3xPowDifficulty.equals(Long.UZERO)) {
      obj.minSha3xPowDifficulty = (message.minSha3xPowDifficulty || Long.UZERO).toString();
    }
    if (!message.blockWeightInputs.equals(Long.UZERO)) {
      obj.blockWeightInputs = (message.blockWeightInputs || Long.UZERO).toString();
    }
    if (!message.blockWeightOutputs.equals(Long.UZERO)) {
      obj.blockWeightOutputs = (message.blockWeightOutputs || Long.UZERO).toString();
    }
    if (!message.blockWeightKernels.equals(Long.UZERO)) {
      obj.blockWeightKernels = (message.blockWeightKernels || Long.UZERO).toString();
    }
    if (!message.preMineValue.equals(Long.UZERO)) {
      obj.preMineValue = (message.preMineValue || Long.UZERO).toString();
    }
    if (!message.maxScriptByteSize.equals(Long.UZERO)) {
      obj.maxScriptByteSize = (message.maxScriptByteSize || Long.UZERO).toString();
    }
    if (!message.effectiveFromHeight.equals(Long.UZERO)) {
      obj.effectiveFromHeight = (message.effectiveFromHeight || Long.UZERO).toString();
    }
    if (message.validBlockchainVersionRange !== undefined) {
      obj.validBlockchainVersionRange = Range.toJSON(message.validBlockchainVersionRange);
    }
    if (!message.maxRandomxSeedHeight.equals(Long.UZERO)) {
      obj.maxRandomxSeedHeight = (message.maxRandomxSeedHeight || Long.UZERO).toString();
    }
    if (message.proofOfWork) {
      const entries = Object.entries(message.proofOfWork);
      if (entries.length > 0) {
        obj.proofOfWork = {};
        entries.forEach(([k, v]) => {
          obj.proofOfWork[k] = PowAlgorithmConstants.toJSON(v);
        });
      }
    }
    if (message.transactionWeight !== undefined) {
      obj.transactionWeight = WeightParams.toJSON(message.transactionWeight);
    }
    if (message.inputVersionRange !== undefined) {
      obj.inputVersionRange = Range.toJSON(message.inputVersionRange);
    }
    if (message.outputVersionRange !== undefined) {
      obj.outputVersionRange = OutputsVersion.toJSON(message.outputVersionRange);
    }
    if (message.kernelVersionRange !== undefined) {
      obj.kernelVersionRange = Range.toJSON(message.kernelVersionRange);
    }
    if (message.permittedOutputTypes?.length) {
      obj.permittedOutputTypes = message.permittedOutputTypes.map((e) => outputTypeToJSON(e));
    }
    if (!message.epochLength.equals(Long.UZERO)) {
      obj.epochLength = (message.epochLength || Long.UZERO).toString();
    }
    if (!message.validatorNodeRegistrationMinDepositAmount.equals(Long.UZERO)) {
      obj.validatorNodeRegistrationMinDepositAmount = (
        message.validatorNodeRegistrationMinDepositAmount || Long.UZERO
      ).toString();
    }
    if (!message.validatorNodeRegistrationMinLockHeight.equals(Long.UZERO)) {
      obj.validatorNodeRegistrationMinLockHeight = (
        message.validatorNodeRegistrationMinLockHeight || Long.UZERO
      ).toString();
    }
    if (!message.validatorNodeRegistrationShuffleIntervalEpoch.equals(Long.UZERO)) {
      obj.validatorNodeRegistrationShuffleIntervalEpoch = (
        message.validatorNodeRegistrationShuffleIntervalEpoch || Long.UZERO
      ).toString();
    }
    if (message.permittedRangeProofTypes?.length) {
      obj.permittedRangeProofTypes = message.permittedRangeProofTypes.map((e) => PermittedRangeProofs.toJSON(e));
    }
    if (!message.inflationBips.equals(Long.UZERO)) {
      obj.inflationBips = (message.inflationBips || Long.UZERO).toString();
    }
    if (!message.tailEpochLength.equals(Long.UZERO)) {
      obj.tailEpochLength = (message.tailEpochLength || Long.UZERO).toString();
    }
    if (!message.maxBlockCoinbaseCount.equals(Long.UZERO)) {
      obj.maxBlockCoinbaseCount = (message.maxBlockCoinbaseCount || Long.UZERO).toString();
    }
    if (message.vnRegistrationMaxVnsInitialEpoch !== 0) {
      obj.vnRegistrationMaxVnsInitialEpoch = Math.round(message.vnRegistrationMaxVnsInitialEpoch);
    }
    if (message.vnRegistrationMaxVnsPerEpoch !== 0) {
      obj.vnRegistrationMaxVnsPerEpoch = Math.round(message.vnRegistrationMaxVnsPerEpoch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsensusConstants>, I>>(base?: I): ConsensusConstants {
    return ConsensusConstants.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsensusConstants>, I>>(object: I): ConsensusConstants {
    const message = createBaseConsensusConstants();
    message.coinbaseMinMaturity =
      object.coinbaseMinMaturity !== undefined && object.coinbaseMinMaturity !== null
        ? Long.fromValue(object.coinbaseMinMaturity)
        : Long.UZERO;
    message.blockchainVersion = object.blockchainVersion ?? 0;
    message.futureTimeLimit =
      object.futureTimeLimit !== undefined && object.futureTimeLimit !== null
        ? Long.fromValue(object.futureTimeLimit)
        : Long.UZERO;
    message.difficultyBlockWindow =
      object.difficultyBlockWindow !== undefined && object.difficultyBlockWindow !== null
        ? Long.fromValue(object.difficultyBlockWindow)
        : Long.UZERO;
    message.maxBlockTransactionWeight =
      object.maxBlockTransactionWeight !== undefined && object.maxBlockTransactionWeight !== null
        ? Long.fromValue(object.maxBlockTransactionWeight)
        : Long.UZERO;
    message.powAlgoCount =
      object.powAlgoCount !== undefined && object.powAlgoCount !== null
        ? Long.fromValue(object.powAlgoCount)
        : Long.UZERO;
    message.medianTimestampCount =
      object.medianTimestampCount !== undefined && object.medianTimestampCount !== null
        ? Long.fromValue(object.medianTimestampCount)
        : Long.UZERO;
    message.emissionInitial =
      object.emissionInitial !== undefined && object.emissionInitial !== null
        ? Long.fromValue(object.emissionInitial)
        : Long.UZERO;
    message.emissionDecay = object.emissionDecay?.map((e) => Long.fromValue(e)) || [];
    message.emissionTail =
      object.emissionTail !== undefined && object.emissionTail !== null
        ? Long.fromValue(object.emissionTail)
        : Long.UZERO;
    message.minSha3xPowDifficulty =
      object.minSha3xPowDifficulty !== undefined && object.minSha3xPowDifficulty !== null
        ? Long.fromValue(object.minSha3xPowDifficulty)
        : Long.UZERO;
    message.blockWeightInputs =
      object.blockWeightInputs !== undefined && object.blockWeightInputs !== null
        ? Long.fromValue(object.blockWeightInputs)
        : Long.UZERO;
    message.blockWeightOutputs =
      object.blockWeightOutputs !== undefined && object.blockWeightOutputs !== null
        ? Long.fromValue(object.blockWeightOutputs)
        : Long.UZERO;
    message.blockWeightKernels =
      object.blockWeightKernels !== undefined && object.blockWeightKernels !== null
        ? Long.fromValue(object.blockWeightKernels)
        : Long.UZERO;
    message.preMineValue =
      object.preMineValue !== undefined && object.preMineValue !== null
        ? Long.fromValue(object.preMineValue)
        : Long.UZERO;
    message.maxScriptByteSize =
      object.maxScriptByteSize !== undefined && object.maxScriptByteSize !== null
        ? Long.fromValue(object.maxScriptByteSize)
        : Long.UZERO;
    message.effectiveFromHeight =
      object.effectiveFromHeight !== undefined && object.effectiveFromHeight !== null
        ? Long.fromValue(object.effectiveFromHeight)
        : Long.UZERO;
    message.validBlockchainVersionRange =
      object.validBlockchainVersionRange !== undefined && object.validBlockchainVersionRange !== null
        ? Range.fromPartial(object.validBlockchainVersionRange)
        : undefined;
    message.maxRandomxSeedHeight =
      object.maxRandomxSeedHeight !== undefined && object.maxRandomxSeedHeight !== null
        ? Long.fromValue(object.maxRandomxSeedHeight)
        : Long.UZERO;
    message.proofOfWork = Object.entries(object.proofOfWork ?? {}).reduce<{ [key: number]: PowAlgorithmConstants }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = PowAlgorithmConstants.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.transactionWeight =
      object.transactionWeight !== undefined && object.transactionWeight !== null
        ? WeightParams.fromPartial(object.transactionWeight)
        : undefined;
    message.inputVersionRange =
      object.inputVersionRange !== undefined && object.inputVersionRange !== null
        ? Range.fromPartial(object.inputVersionRange)
        : undefined;
    message.outputVersionRange =
      object.outputVersionRange !== undefined && object.outputVersionRange !== null
        ? OutputsVersion.fromPartial(object.outputVersionRange)
        : undefined;
    message.kernelVersionRange =
      object.kernelVersionRange !== undefined && object.kernelVersionRange !== null
        ? Range.fromPartial(object.kernelVersionRange)
        : undefined;
    message.permittedOutputTypes = object.permittedOutputTypes?.map((e) => e) || [];
    message.epochLength =
      object.epochLength !== undefined && object.epochLength !== null ? Long.fromValue(object.epochLength) : Long.UZERO;
    message.validatorNodeRegistrationMinDepositAmount =
      object.validatorNodeRegistrationMinDepositAmount !== undefined &&
      object.validatorNodeRegistrationMinDepositAmount !== null
        ? Long.fromValue(object.validatorNodeRegistrationMinDepositAmount)
        : Long.UZERO;
    message.validatorNodeRegistrationMinLockHeight =
      object.validatorNodeRegistrationMinLockHeight !== undefined &&
      object.validatorNodeRegistrationMinLockHeight !== null
        ? Long.fromValue(object.validatorNodeRegistrationMinLockHeight)
        : Long.UZERO;
    message.validatorNodeRegistrationShuffleIntervalEpoch =
      object.validatorNodeRegistrationShuffleIntervalEpoch !== undefined &&
      object.validatorNodeRegistrationShuffleIntervalEpoch !== null
        ? Long.fromValue(object.validatorNodeRegistrationShuffleIntervalEpoch)
        : Long.UZERO;
    message.permittedRangeProofTypes =
      object.permittedRangeProofTypes?.map((e) => PermittedRangeProofs.fromPartial(e)) || [];
    message.inflationBips =
      object.inflationBips !== undefined && object.inflationBips !== null
        ? Long.fromValue(object.inflationBips)
        : Long.UZERO;
    message.tailEpochLength =
      object.tailEpochLength !== undefined && object.tailEpochLength !== null
        ? Long.fromValue(object.tailEpochLength)
        : Long.UZERO;
    message.maxBlockCoinbaseCount =
      object.maxBlockCoinbaseCount !== undefined && object.maxBlockCoinbaseCount !== null
        ? Long.fromValue(object.maxBlockCoinbaseCount)
        : Long.UZERO;
    message.vnRegistrationMaxVnsInitialEpoch = object.vnRegistrationMaxVnsInitialEpoch ?? 0;
    message.vnRegistrationMaxVnsPerEpoch = object.vnRegistrationMaxVnsPerEpoch ?? 0;
    return message;
  },
};

function createBaseConsensusConstants_ProofOfWorkEntry(): ConsensusConstants_ProofOfWorkEntry {
  return { key: 0, value: undefined };
}

export const ConsensusConstants_ProofOfWorkEntry: MessageFns<ConsensusConstants_ProofOfWorkEntry> = {
  encode(message: ConsensusConstants_ProofOfWorkEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      PowAlgorithmConstants.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsensusConstants_ProofOfWorkEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsensusConstants_ProofOfWorkEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = PowAlgorithmConstants.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsensusConstants_ProofOfWorkEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? PowAlgorithmConstants.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ConsensusConstants_ProofOfWorkEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = PowAlgorithmConstants.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsensusConstants_ProofOfWorkEntry>, I>>(
    base?: I,
  ): ConsensusConstants_ProofOfWorkEntry {
    return ConsensusConstants_ProofOfWorkEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsensusConstants_ProofOfWorkEntry>, I>>(
    object: I,
  ): ConsensusConstants_ProofOfWorkEntry {
    const message = createBaseConsensusConstants_ProofOfWorkEntry();
    message.key = object.key ?? 0;
    message.value =
      object.value !== undefined && object.value !== null ? PowAlgorithmConstants.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseUDecimalValue(): UDecimalValue {
  return { units: Long.UZERO, nanos: 0 };
}

export const UDecimalValue: MessageFns<UDecimalValue> = {
  encode(message: UDecimalValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.units.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.units.toString());
    }
    if (message.nanos !== 0) {
      writer.uint32(21).fixed32(message.nanos);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UDecimalValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUDecimalValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.units = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.nanos = reader.fixed32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UDecimalValue {
    return {
      units: isSet(object.units) ? Long.fromValue(object.units) : Long.UZERO,
      nanos: isSet(object.nanos) ? globalThis.Number(object.nanos) : 0,
    };
  },

  toJSON(message: UDecimalValue): unknown {
    const obj: any = {};
    if (!message.units.equals(Long.UZERO)) {
      obj.units = (message.units || Long.UZERO).toString();
    }
    if (message.nanos !== 0) {
      obj.nanos = Math.round(message.nanos);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UDecimalValue>, I>>(base?: I): UDecimalValue {
    return UDecimalValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UDecimalValue>, I>>(object: I): UDecimalValue {
    const message = createBaseUDecimalValue();
    message.units = object.units !== undefined && object.units !== null ? Long.fromValue(object.units) : Long.UZERO;
    message.nanos = object.nanos ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
    ? string | number | Long
    : T extends globalThis.Array<infer U>
      ? globalThis.Array<DeepPartial<U>>
      : T extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : T extends {}
          ? { [K in keyof T]?: DeepPartial<T[K]> }
          : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
